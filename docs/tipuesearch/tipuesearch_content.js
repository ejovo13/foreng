var tipuesearch = {"pages":[{"title":" Fortran Program ","text":"Fortran Program Hi, my name is ejovo13. Developer Info Evan Voyles Learning Fortran.","tags":"home","loc":"index.html"},{"title":"chapter_4.f90 – Fortran Program","text":"Contents Modules chapter_4 Source Code chapter_4.f90 Source Code module chapter_4 !! All of the programming exercises for Chapter 4: Loops and Character Manipulation use iso_fortran_env implicit none contains ! //TODO CLEAN UP OUTPUT OF ALL PROGRAMS subroutine p4_1 () !! Test if the following equalities are valid statements, and if they are, !! evaluate them logical :: a , b character ( 5 ) :: c , d a = '123' > 'abc' ! b = '9478' == 9478 c = ACHAR ( 65 ) // ACHAR ( 95 ) // ACHAR ( 72 ) d = ACHAR ( IACHAR ( 'j' ) + 5 ) print * , \"a: \" , a , \"b: \" , b , \"c: \" , c , \"d: \" , d end subroutine subroutine p4_3 () !! Write a Fortran program to evaluate the equation y(x) = x&#94;2 - 3x + 2 for all values between -1 and 3, !! in steps of 0.1. ! // TODO add latex support ! Puprose: to solve exercise 4.3 ! Data dictionary :: declared variables integer , parameter :: start_index = - 1 , end_index = 3 real , parameter :: step_size = 0.1 integer , parameter :: array_size = int (( end_index - start_index ) / step_size ) integer :: i real , dimension ( array_size ) :: output = [( 0.1 * i + - 1 , i = 0 ,( array_size - 1 ))] integer :: x do x = 1 , array_size output ( x ) = x ** 2 - 3 * x + 2 end do write ( * , 100 ) output 100 format ( ES9 . 2 ) end subroutine subroutine p4_4 () !! Write the Fortran statements required to calculate y(t) from the equation: !! !!   y(t) = ------ -3t&#94;2 + 5    t >= 0 !!           \\---   3t&#94;2 + 5    t < 0 !! ! //TODO print function to stdin real :: y , t print * , \"Please enter a t value that you would like to compute\" read * , t if ( t >= 0 ) then y = - 3 * ( t ** 2 ) + 5 else y = 3 * ( t ** 2 ) + 5 end if print 100 , \"y(t) with t = \" , t , \" is equal to \" , y 100 format ( A , ES9 . 2 , A , ES9 . 2 ) end subroutine subroutine p4_5 () !! Write a Fortran program to calculate the factorial function. Be sure to handle the special !! cases of 0! and of illegal input values. ! integer, parameter :: MY_INT_64 = selected_int_kind(38) integer ( int64 ) :: input , factorial , i = 1 , ierr ! logical :: value_accepted = .false. print * , \"Please enter an integer to find it's factorial, max value 33!\" read ( * , '(i10)' , iostat = ierr ) input do if ( ierr == 0 ) then exit end if print * , \"Value not accepted, please enter an integer\" read ( * , '(i2)' , iostat = ierr ) input end do if ( input == 0 ) then factorial = 1 end if do i = 1 , input if ( i == 1 ) then factorial = 1 else factorial = factorial * i end if if ( factorial < 0 ) then error stop \"Overflow error, input value too large\" end if end do print 99 , input , factorial 99 format ( I0 , \" factorial is: \" , I0 ) end subroutine subroutine p4_6 () !! What is the difference in behavior between a cycle statement and an exit statement? print * , \"A cycle statement sends the program control to the start of the loop, whereas the exit statement\" print * , \"exits the loop entirely\" end subroutine subroutine p4_7 () !! Modify program stats_2 to use the DO WHILE construct instaed of the while construct currently in the program !! !!     A modified statistical analysis program that avoids the divide-by-zero problems inherent in !! program stats_1. !! !! Purpose: !! !! To calculate mean and the standard deviation of an input !! !!  data set containing an arbitrary number of input values. !! !! Record of revisions: !! !!  Date      Programmer     Description of change !!  ====      ==========     ===================== !! 11/10/15  S. J. Chapman   Original code !! 11/12/15  S. J. Chapman   Correct divide-by-0 error if !!                           0 or 1 input values given. !! 02/16/21  E. J. Voyles    Add do-while construct !! IMPLICIT NONE ! Data dictionary: declare variable types, definitions, & units INTEGER :: n = 0 ! The number of input samples. REAL :: std_dev = 0. ! The standard deviation of the input samples. REAL :: sum_x = 0. ! The sum of the input values. REAL :: sum_x2 = 0. ! The sum of the squares of the input values. REAL :: x = 0. ! An input data value. REAL :: x_bar ! The average of the input samples. ! While Loop to read input values. DO ! Read in next value WRITE ( * , * ) 'Enter number: ' READ ( * , * ) x WRITE ( * , * ) 'The number is ' , x ! Test for loop exit IF ( x < 0 ) EXIT ! Otherwise, accumulate sums. n = n + 1 sum_x = sum_x + x sum_x2 = sum_x2 + x ** 2 END DO ! Check to see if we have enough input data. IF ( n < 2 ) THEN ! Insufficient information WRITE ( * , * ) 'At least 2 values must be entered!' ELSE ! There is enough information, so ! calculate the mean and standard deviation x_bar = sum_x / real ( n ) std_dev = sqrt ( ( real ( n ) * sum_x2 - sum_x ** 2 ) / ( real ( n ) * real ( n - 1 ))) ! Tell user. WRITE ( * , * ) 'The mean of this data set is:' , x_bar WRITE ( * , * ) 'The standard deviation is: ' , std_dev WRITE ( * , * ) 'The number of data points is:' , n END IF end subroutine subroutine p4_8 () !! Examine the following DO statements and determine how many times each loop will !! be exectued. implicit NONE integer :: irange , j , kount , i !, index integer :: count = 0 a : do irange = - 32768 , 32767 count = count + 1 end do a print * , \"(a) = \" , count count = 0 b : do j = 100 , 1 , - 10 count = count + 1 end do b print * , \"(b) = \" , count count = 0 c : do kount = 2 , 3 , 4 count = count + 1 end do c print * , \"(c) = \" , count count = 0 ! d: do index = -4,-7 !     count = count + 1 ! end do d print * , \"(d) = \" , count count = 0 e : do i = - 10 , 10 , 10 count = count + 1 end do e print * , \"(e) = \" , count count = 0 ! f: do i = 10, -2, 0 !     count = count + 1 ! end do f !!!!! This for loop shows an error, since the increment is 0 !!!!!!!!!! ! print *, \"(f) = \", count ! count = 0 end subroutine subroutine p4_9 () !! Examine the following loops, determine the value of ires and the number of times !! each loop executes integer :: ires ! (b) ! ires = 0 ! loop1: DO index1 = 1, 20, 5 !     IF ( index1 <= 10 ) CYCLE !     loop2: DO index2 = index1, 20, 5 !         ires = ires + index2 !     END DO loop2 ! END DO loop1 ! (c) ! ires = 0 ! loop1: do index1 = 10, 4, -2 !     loop2: do index2 = 2, index1, 2 !         if (index2 > 6) exit loop2 !         ires = ires + index2 !     end do loop2 ! end do loop1 ! (d) ! ires = 0 ! loop1: do index1 = 10, 4, -2 !     loop2: do index2 = 2, index1, 2 !         if (index2 > 6) exit loop1 !         ires = ires + index2 !     end do loop2 ! end do loop1 !! answers !! (b) ires = 43 !! (c) ires = 42 !! (d) loop2 is run 3 times, loop1 exits during it's first iteration, ires = 12 print * , \"Ires = \" , ires end subroutine subroutine p4_10 () !! Examine the followin while loops and determine the value of ires at the end of each of !! the loops. integer :: ires , count ! (a) !  ires = 0 ! loop1: DO !     ires = ires + 1 !     IF ( (ires / 10 ) * 10 == ires ) EXIT ! END DO loop1 ! (b) ! count = 0 ! ires = 2 ! loop2: DO !     ires = ires**2 !     count = count + 1 !     IF ( ires > 200 ) EXIT ! END DO loop2 ! ! (c) ! count = 0 ! ires = 2 ! DO WHILE ( ires > 200 ) ! ires = ires**2 ! count = count + 1 ! END DO print * , \"ires = \" , ires , \" count = \" , count end subroutine subroutine p4_11 () !! Modify program ball from example 4-7 to read in the acceleration due to gravity !! at a particular location, and to calculate the maximum range of the ball for that acceleration. !! After modifying the program, run it with accelerations of -9.8, -9.7, and -9.6m/s2. !! !! What effect does the reduction in gravitational attraction have on the range ofthe ball? !! What effect does the reduction in gravitational attraction have on the best angle theta at which to throw the ball? ! Purpose: ! !       To test how the flight of a ball changes in different gravitational fields ! ! ! Data Dictionary: Declare constants and variables implicit none real :: g ! The gravitational constant, g. This value will be read in at the start of every execution real :: vx ! The horizontal velocity of the ball real :: vy ! The vertical velocity of the ball real :: v0 = 20 ! The initial velocity of the ball real :: tf ! Time when the ball lands real :: max_distance = 0 ! Maximum distance traveled integer :: theta = 0 ! Angle at which the ball is thrown integer :: max_theta ! The theta for which the ball travels the most distance real , dimension ( 0 : 90 ) :: distance_traveled ! The distance traveled for each theta value character ( 50 ) :: FMT ! The format of the output table real , parameter :: PI = 3.1415927 ! Mathematical constant pi integer :: ierr ! flag for reading in the gravitational value character ( 50 ) :: errmsg ! the error message for reagding in FMT = \"(I3, A, F5.2, A, F6.2, A, F5.2)\" 100 print * , \"Please enter a real, negative value for the gravitational constant\" read ( * , * , iostat = ierr , iomsg = errmsg ) g if ( ierr /= 0 ) then print * , \"ierr = \" , ierr , \" iomsg = \" , errmsg goto 100 end if print * , \"Theta | time in air(s) | distance traveled(m) | vy\" print * , \"--------------------------------------------------\" do theta = 0 , 90 , 1 vx = v0 * cos (( theta / 18 0. ) * PI ) vy = v0 * sin (( theta / 18 0. ) * PI ) ! Find tf tf = vy / ( - g / 2 ) distance_traveled ( theta ) = tf * vx if ( distance_traveled ( theta ) > max_distance ) then max_distance = distance_traveled ( theta ) max_theta = theta end if print ( FMT ), theta , \" | \" , tf , \" | \" , distance_traveled ( theta ), \" | \" , vy end do print * , \"Max distance traveled: \" , max_distance , \"With theta: \" , max_theta end subroutine subroutine p4_12 () !! Modify program ball from Example 4-7 to read in the initial velocity with which the ball !! is thrown. After modifying the program, run it with initial velocities of 10, 20, and 20 !! m/sec. What effect does changin the initial velocity have on the range of the ball? What !! effect does it have on the best angle theta at which to throw the ball? ! Purpose: ! !       To test how the flight of a ball changes with different initial velocites ! ! ! Data Dictionary: Declare constants and variables implicit none real :: g = - 9.8 ! The gravitational constant, g. real :: vx ! The horizontal velocity of the ball, m/sec real :: vy ! The vertical velocity of the ball real :: v0 ! The initial velocity of the ball, this will be read in upon execution real :: tf ! Time when the ball lands real :: max_distance = 0 ! Maximum distance traveled integer :: theta = 0 ! Angle at which the ball is thrown integer :: max_theta ! The theta for which the ball travels the most distance real , dimension ( 0 : 90 ) :: distance_traveled ! The distance traveled for each theta value character ( 50 ) :: FMT ! The format of the output table real , parameter :: PI = 3.1415927 ! Mathematical constant pi integer :: ierr ! flag for reading in the gravitational value character ( 50 ) :: errmsg ! the error message for reagding in FMT = \"(I3, A, F5.2, A, F6.2, A, F5.2)\" 100 print * , \"Please enter a real value for the initial velocity\" read ( * , * , iostat = ierr , iomsg = errmsg ) v0 if ( ierr /= 0 ) then print * , \"ierr = \" , ierr , \" iomsg = \" , errmsg goto 100 end if print * , \"Theta | time in air(s) | distance traveled(m) | vy\" print * , \"--------------------------------------------------\" do theta = 0 , 90 , 1 vx = v0 * cos (( theta / 18 0. ) * PI ) vy = v0 * sin (( theta / 18 0. ) * PI ) ! Find tf tf = vy / ( - g / 2 ) distance_traveled ( theta ) = tf * vx if ( distance_traveled ( theta ) > max_distance ) then max_distance = distance_traveled ( theta ) max_theta = theta end if print ( FMT ), theta , \" | \" , tf , \" | \" , distance_traveled ( theta ), \" | \" , vy end do print * , \"Max distance traveled: \" , max_distance , \"With theta: \" , max_theta end subroutine subroutine p4_13 () print * , \"Work in progress\" end subroutine subroutine p4_14 () !! Write a Fortran program to evaluate the function !! y(x) = ln(1/1-x) !! for any user-specified value of x, where ln is the natural logarithm. !! Write the program with a while loop, so that the program repeats the calculation !! for each legal value of x entered into the program. When an illegal value of x is entered, !! terminate the program. !   Purpose: !       This program calculates the value of ln(1/(1-x)) for all valid !       values of x entered by the user ! ! IMPLICIT NONE ! Data dictionary: declare variable types, definitions, & units. real :: x ! The x value to be evaluated integer :: ierr = 0 ! The error status when reading in the value character ( 100 ) :: errmsg ! The error message generated when reading in a value do while ( ierr == 0 ) print * , \"Please enter a real number greater than 1\" read ( * , * , iostat = ierr , iomsg = errmsg ) x if ( x <= 1 . or . ierr /= 0 ) exit print 100 , x , log (( 1 ) / ( x - 1 )) end do 100 Format ( \"f(\" , f10 . 2 , \") = \" , f7 . 3 ) end subroutine subroutine p4_15 () !! Write a Fortran program to convert all uppercase characters in a user-supplied character !! string to lowercase, without changing the uppercase and nonalphabetic characters in the string. !! Assume that your computer uses the ASCII collating sequence. !   Purpose: !       This program converts all uppercase letters to lowercase letters IMPLICIT NONE ! Data Dictionary: declare variable types, definitions, and units integer , parameter :: MAX_LENGTH = 30 character ( len = MAX_LENGTH ) :: start_string character ( MAX_LENGTH ) :: end_string integer :: i integer :: this_char_index character :: this_char print * , \"Please enter a string you would like to convert to lowercase\" read '(30A)' , start_string do i = 1 , MAX_LENGTH this_char = start_string ( i : i ) this_char_index = iachar ( this_char ) if ( this_char_index >= 65 . and . this_char_index <= 90 ) then end_string ( i : i ) = achar ( this_char_index + 32 ) else end_string ( i : i ) = this_char end if end do print * , \"Converted string: \" , start_string , \" to string: \" , end_string end subroutine subroutine p4_16 () !! Calculating Orbits. !! !! When a satellinte orbits the Eath, the satellite's orbit will form an ellipse with the !! Earth located at one of the focal points of the ellipse. The satellite's orbit can be !! expressed in polar coordintaes as !! !! r = p/(1 - \\epsilon * cos( \\theta )) !! !! Where r and theta are the distance and angle of the satellite from the center of the earth, !! p is a parameter specifying the size of the orbit, and \\epsilon is a parameter representing the !! eccentricity of the orbit. A circular orbit has an eccentricity of zero. An elliptical orbit has !! an eccentricity of 0 <= e <= 1. If \\epsilon > 1, the satellite follows a hyperbolic path and escapes !! from Earth's gravitational field. !! !! Consider a satellite with a size parameter p = 1200 km. Write a program to calculate the !! distance of the satellite from the center of the Earth as a function of theta if the satellite has !! an eccentricity of (a) e = 0; (b) e = 0.25; (c) e = 0.5. Write a single program in which !! r and e are both input values. !! !! How close does each orbit come to the earth? How far away does each orbit get from the earth? !   Purpose: !      To calculate the position of a satellite orbiting the Earth. ! Data dictionary: declare variable types, definitions, and units integer , parameter :: P = 1200 ! Size of the orbit, in km. integer , parameter :: NTHETA = 200 real , parameter :: PI = 3.1415927 real , parameter :: THETA_STEP = ( 2 * PI ) / NTHETA real :: eccentricity ! Eccentricity of the orbit, 0 <= e <= 1 real :: theta ! Polar coordinate for the satellite. real :: r ! Distance from the center of the earth. real :: apoapsis = P ! Farthest distance from the center of the earth real :: periapsis = P ! Closest distance from the center of the earth integer :: ierr character ( 30 ) :: errmsg integer itheta print * , \"Please enter an eccentricity value, between 0 and 1.\" read ( * , * , iostat = ierr , iomsg = errmsg ) eccentricity do while ( ierr /= 0 . and . ( eccentricity > 1 . or . eccentricity < 0 )) print * , \"Input invalid, please enter a real value between 0 and 1.\" read ( * , * , iostat = ierr , iomsg = errmsg ) eccentricity end do do itheta = 1 , NTHETA theta = itheta * THETA_STEP r = p / ( 1 - ( eccentricity * cos ( theta ))) if ( r < periapsis ) periapsis = r if ( r > apoapsis ) apoapsis = r print * , theta , r end do print * , \"The periapsis is: \" , periapsis , \"km, and the apoapsis is: \" , apoapsis , \"km\" end subroutine subroutine p4_17 () !! Write a program caps that reads in a character string, searches for all of the words !! within the string, and capitalizes the first letter of each word, while shifting the !! remainder of the word to lowercase. Assume that all nonalphabetic and nonumeric characters !! can mark the boundaries of a word within the character variable (periods, commas,etc.). !! Nonalphabetic characters should be left unchanged. ! 2. Define the input and output ! input: A character string from the terminal. ! output: The same string with the only the first letter per word capitalized. ! 3. Describe the algorithm ! We should first read in the string ! Alphabetic character ranges: !   lowercase: [97, 122] !   uppercase: [65, 90] ! Numeric character ranges: !   [48, 57] ! ! We assume that all nonalphabetic and nonnumeric characters can mark the boundaries of a word. ! Purpose: !   To capitalize the first letter per word in a character string. ! Data dictionary: integer , parameter :: MAX_STR_LEN = 500 character (:), allocatable :: input_str character ( 30 ) :: FMT integer :: i integer :: num_chars character ( 1 ) :: prev_char , this_char print * , \"Please enter a the number of characters to record\" read ( * , \"(I10)\" ) num_chars allocate ( character ( num_chars ) :: input_str ) write ( FMT , '(\"(A\", I0, \")\")' ) num_chars ! print *, \"Format statement saved as: \", FMT print * , \"Now please enter the string you would like to transform\" read ( * , FMT ) input_str print * , \"String before transformation: \" , input_str if ( is_alph ( input_str ( 1 :))) then call to_upper ( input_str ( 1 :)) end if do i = 2 , MAX_STR_LEN prev_char = input_str ( i - 1 :) this_char = input_str ( i :) ! If the character is the start of the word, then capitalize it if (. not . is_alphnum ( prev_char )) then ! If the previous character is a word boundary if ( is_lower ( this_char )) then ! And this character is lowercase call to_upper ( input_str ( i :)) ! Then capitalize it end if else if ( is_upper ( this_char )) then call to_lower ( input_str ( i :)) end if end if end do print * , \"String after transformation: \" , input_str end subroutine subroutine p4_18 () !!Write a computer program to calculate the current flowing through this diode !! for all voltages from -1.0V to +0.6 V, in 0.1 V steps. Repeat this process for the !! following temperatures: 75F, 100F, and 125F ! Purpose: !   To calculate the current flowing through a semiconductor diode real ( real64 ), dimension ( 3 ) :: T_f = [ 75 , 100 , 125 ] real ( real64 ), dimension ( 3 ) :: T_k real ( real64 ), parameter :: I_O = 2.0E-6 real ( real64 ), dimension ( 17 ) :: v_D real ( real64 ), dimension ( 3 , 17 ) :: i_D integer :: i , j do i = 1 , 17 v_D ( i ) = - 1.0 + ( 0.1 * ( i - 1 )) end do ! print *, v_D T_k = to_kelvin ( T_f ) print * , \" \" print * , \"Calculating the current flowing through a semiconductor diode for three separate temperatures\" print * , \"and voltages ranging from -1.0 to 0.6 V\" print * , \" \" print 999 , v_D print 100 100 format ( 250 ( \"-\" )) do i = 1 , 3 do j = 1 , 17 i_D ( i , j ) = calc_current_flow ( v_D ( j ), I_O , T_k ( i )) end do print 99 , T_k ( i ), i_D ( i ,:) 99 format ( F9 . 3 , 2 X , \" | \" , 17 ( ES10 . 3 , 3 X )) 999 format ( \"  T(K) \\ V \" , \" | \" , 17 ( F6 . 3 , 7 X )) end do end subroutine subroutine p4_19 () !! Write a program that promps a user for a binary number, which will be entered as a string !! of 0s and 1s in a character variable. This program should be able to handle numbers whos !! binary representation is up to 10 bits, corresponding to values from 0 to 1023. ! Purpose: !   To convert binary numbers to decimal. implicit none ! Data dictionary integer , parameter :: MAX_LEN = 10 integer , parameter :: ZERO_ASCII = 48 integer , parameter :: ONE_ASCII = 49 character ( MAX_LEN ) :: binary_representation character (:), allocatable :: binary_trimmed integer :: len_trim = 0 logical :: input_is_valid = . true . integer :: i = 0 character ( 1 ) :: this_char = '' integer :: char_value = 0 real :: decimal_representation = 0 integer :: this_bit = 0 ! print *, \"decimal_representation = \", decimal_representation print * , \"Please enter a binary number that is between 1 and 10 bits\" read ( * , \"(A10)\" ) binary_representation ! print *, \"Converting binary number: \", binary_representation binary_trimmed = trim ( binary_representation ) len_trim = len ( binary_trimmed ) ! First let's validate the input do i = 1 , len_trim this_char = binary_trimmed ( i :) char_value = ichar ( this_char ) if ( char_value /= ZERO_ASCII . and . char_value /= ONE_ASCII ) then input_is_valid = . false . print * , \"invalid char = \" , this_char print * , \"invalid val = \" , char_value print * , \"invalid pos = \" , i print * , \"\" print * , \"ZERO_ASCII = \" , ZERO_ASCII print * , \"ONE_ASCII = \" , ONE_ASCII exit end if end do if ( input_is_valid ) then ! print *, \"input is valid, converting now\" do i = 1 , len_trim read ( binary_representation ( i :), \"(I1)\" ) this_bit ! print *, \"Current working bit: \", this_bit decimal_representation = ( this_bit * 2 ** ( len_trim - i )) + decimal_representation end do else print * , \"input is invalid, please try restarting the program\" end if print 99 , binary_representation , int ( decimal_representation ) 99 format ( \"binary num: \" , T15 , A10 , / , 'decimal:' , T15 , I0 ) decimal_representation = 0 end subroutine !-------------------------------------! !------- HELPER FUNCTIONS ------------! !-------------------------------------! logical function is_alphnum ( char ) !! Test whether an ASCII character is alpha-numeric character ( 1 ), intent ( in ) :: char if ( is_num ( char ) . or . is_alph ( char )) then is_alphnum = . true . else is_alphnum = . false . end if end function logical function is_alph ( char ) !! Test whether an ASCII character is a letter character ( 1 ), intent ( in ) :: char if ( is_upper ( char ) . or . is_lower ( char )) then is_alph = . true . else is_alph = . false . end if end function logical function is_num ( char ) !! Test whether an ASCII character is numeric character ( 1 ), intent ( in ) :: char integer :: char_value char_value = iachar ( char ) if ( char_value >= 48 . and . char_value <= 57 ) then is_num = . true . else is_num = . false . end if end function logical function is_lower ( char ) !! Test whether an ASCII character is a lowercase letter character ( 1 ), intent ( in ) :: char integer :: char_value !! ASCII value char_value = iachar ( char ) if ( char_value >= 97 . and . char_value <= 122 ) then is_lower = . true . else is_lower = . false . end if end function logical function is_upper ( char ) !! Test whether an ASCII character is an uppercase letter character ( 1 ), intent ( in ) :: char integer :: char_value !! ASCII value char_value = iachar ( char ) if ( char_value >= 65 . and . char_value <= 90 ) then is_upper = . true . else is_upper = . false . end if end function subroutine to_lower ( char ) !! Convert a single character to lowercase character ( 1 ), intent ( inout ) :: char if ( is_upper ( char )) char = achar (( iachar ( char ) + 32 )) end subroutine subroutine to_upper ( char ) !! Convert a single character to uppercase character ( 1 ), intent ( inout ) :: char if ( is_lower ( char )) char = achar (( iachar ( char ) - 32 )) end subroutine elemental function calc_current_flow ( v_D , I_O , T ) result ( i_D ) ! Data Dictionary ! // TODO add proper documentation real ( real64 ) :: i_D !! The current flow through the diode in amperes real ( real64 ), intent ( in ) :: v_D !! The voltage across the diode, in volts real ( real64 ), intent ( in ) :: I_O !! The leakage current of the diode, in amperes real ( real64 ), intent ( in ) :: T !! Temperature, in kelvins (K) real ( real64 ), parameter :: q = 1.602E-19 !! The charge on an electron, 1.602 X 10-19 Coulombs real ( real64 ), parameter :: k = 1.38E-23 !! Boltzmann's constant, 1.38 X 10-23 J/K i_D = I_O * ( exp (( q * v_D ) / ( k * T )) - 1 ) end function elemental real ( real64 ) function to_kelvin ( F ) !! Convert a temperature in Fahrenheit to Kelvin real ( real64 ), intent ( in ) :: F to_kelvin = to_celcius ( F ) + 273 end function elemental real ( real64 ) function to_celcius ( F ) !! Convert a temperature from Fahrenheit to celcius real ( real64 ), intent ( in ) :: F to_celcius = ( F - 32 ) * ( 5. / 9. ) end function end module","tags":"","loc":"sourcefile/chapter_4.f90.html"},{"title":"chapter_7.f90 – Fortran Program","text":"Contents Modules chapter_7 Source Code chapter_7.f90 Source Code module chapter_7 !! All of the programming exercises for Chapter 7: Procedures use iso_fortran_env implicit none contains subroutine p7_1 () !! ** DISCUSSION QUESTION **\\ !! What is the difference between a subroutine and a function? print * , \"A subroutine can modify arguments that are passed to it, but it will never have\" print * , \"a return value. Functions in Fortran, just like their mathematical definition,\" print * , \"necessarily have a return value. A subroutine and function is similar with\" print * , \"respect to the fact that they both are a tool to repeat and reuse code.\" end subroutine subroutine p7_2 () !! ** DISCUSSION QUESTION **\\ !! When a subroutine is called, how is data passed from the calling program to the subroutine, !! and how are the results of the subroutine returned to the calling program? print * , \"Parameters are passed around inside subroutines as references, that is to say\" print * , \"that there is not a block of memory that is copied to the subroutine, instead\" print * , \"the argument is passed with a pointer to the block of memory that stores the value.\" end subroutine subroutine p7_3 () !! ** DISCUSSION QUESTION **\\ !! What are the advantages and disadvantages of the pass-by-reference scheme used in Fortran? print * , \"Advantages: \" print * , \" - Don't have to copy large amounts of data (which can be slow)\" print * , \"Disadvantages: \" print * , \" - Data address might be far away from the caller, leading to slow load times\" print * , \" - Modifiying the data in the subroutine can affect the original parameter\" end subroutine subroutine p7_4 () !! ** DISCUSSION QUESTION ** \\ !! What are the advantages and disadvantages of each procedure array type? print * , \"Explicit shaped dummy arrays:\" print * , \" - Compiler knows exactly the shape and size of an argument, and\" print * , \"can therefore check for out-of-bounds errors during compilation\" print * , \" - We have to pass the size of the array when calling the procedure\" print * print * , \"Assumed-shape dummy arrays:\" print * , \" - Allow the compiler to check SOME indexing errors, and avoids having\" print * , \"to pass a size parameter\" print * , \" - can be used in full-matrix statements (e.g. A + B)\" print * print * , \"Assumed-size dummy arrays:\" print * , \" - Should NEVER be used because the compiler can't check for errors.\" end subroutine subroutine p7_5 () !! ** DISCUSSION QUESTION **<br> I put a br here.. !! Suppose a 15-element array is passed to a subroutine. What happens if the subroutine attempts !! to write to element a(16)? print * , \"If the array is explicit-shaped, then there will be an error at compile time.\" print * , \"If the array is assumed-shape, then there will be an error at run time.\" print * , \"An assumed-size error will allow the unsafe access to be performed.\" end subroutine end module chapter_7","tags":"","loc":"sourcefile/chapter_7.f90.html"},{"title":"chapter_6.f90 – Fortran Program","text":"Contents Modules chapter_6 Source Code chapter_6.f90 Source Code module chapter_6 !! Arrays use iso_fortran_env implicit none contains subroutine p6_1 () !! ** DISCUSSION QUESTION ** !! How may arrays be declared? integer , dimension ( 1 : 10 ) :: my_array integer , dimension ( - 10 : - 1 ) :: my_neg_array double precision , dimension ( 10 ) :: my_product my_array = 3 my_neg_array = - 2 my_product = real ( my_array ) ** real ( my_neg_array ) print * , my_product end subroutine subroutine p6_3 () !! ** DISCUSSION QUESTION ** !! Execute this subroutine on your computer with both bounds checking turned on and !! bounds checking turned off. What happens? real , dimension ( 5 ) :: test = [ 1. , 2. , 3. , 4. , 5. ] real , dimension ( 5 ) :: test1 integer :: i do i = 1 , 5 test1 ( i ) = sqrt ( test ( i )) write ( * , 100 ) 'SQRT(' , test ( i ), ') = ' , test1 ( i ) 100 format ( A , F6 . 3 , A , F14 . 4 ) end do end subroutine subroutine p6_4 () !! ** DISCUSSION QUESTION ** !! Determine the shape and size of the arrays specified by the following statements: ! (a) ! character(len=80), dimension(60) :: line ! An array that is 1 dimensionsal, has 60 entries, and each entry is a charactar of length 80. ! (b) ! integer, parameter :: ISTART = 32 ! INTEGER, PARAMETER :: ISTOP = 256 ! INTEGER, DIMENSION(ISTART:ISTOP) :: char ! char is an array of size (256-32 + 1) = 225 ! (c) ! INTEGER, PARAMETER :: NUM_CLASS = 3 ! INTEGER, PARAMETER :: NUM_STUDENT = 35 ! LOGICAL, DIMENSION(NUM_STUDENT, NUM_CLASS) :: passfail ! passfail is an array of size 33. end subroutine subroutine p6_5 () !! ** DISCUSSION QUESTION ** !! Determine which of the following Fortran program fragments are valid. For each valid statement, !! specify what will happen in the program. (Assume default typing for any variables that are not !! explicitly typed within the program fragments.) ! (a) ! INTEGER, DIMENSION(100) :: icount, jcount !. . . ! icount = [ (i, i=1, 100)] ! implied do loop ! jcount = icount + 1 ! (a) has valid syntax, this will create two arrays, icount which is a size 100 array that ! contains the sequence of natural numbers from 1 to 100, and jcount contains the sequence of ! natural numbers from 2 to 101. ! print *, icount ! print *, jcount ! (b) ! REAL, DIMENSION(10) :: value ! value(1:10:2) = [5., 4., 3., 2., 1. ] ! value(2:11:2) = [10., 9., 8., 7., 6. ] ! write (*, 100) value ! 100 format ('Value = ',/,(F10.2)) ! (c) ! INTEGER, DIMENSION(6) :: a ! INTEGER, DIMENSION(6) :: b ! a = [1, -3, 0, -5, -9, 3] ! b = [-6, 6, 0, 5, 2, -1] ! WRITE (*, *) a > b ! All the fragments are valid! print * , \"All code fragments are valid\" end subroutine subroutine p6_6 () !! ** DISCUSSION QUESTION ** !! What is meant by each of the following array terms? Size, shape, extent, rank, conformable. integer , parameter :: DEFINITION_LENGTH = 65 character ( DEFINITION_LENGTH ) :: sizeDef , shapeDef , extentDef , rankDef , conformableDef sizeDef = \"Number of elements of A\" shapeDef = \"Return the dimensions of A\" extentDef = \"The number of elements in a single dimension\" rankDef = \"The number of dimensions\" conformableDef = \"Two arrays that have the same shape and extent are conformable\" print 100 , sizeDef , shapeDef , extentDef , rankDef , conformableDef 100 Format ( \"size: \" , T30 , A , / , \"shape: \" , T30 , A , / , \"extent: \" , T30 , A , / , \"rank: \" , T30 , A , / , \"conformable: \" , T30 , A ) end subroutine subroutine p6_7 () !! ** DISCUSSION QUESTION ** !! Given an array my_array defined as shown, determine whether each of the following !! array sections is valid REAL , DIMENSION ( - 2 : 7 ) :: my_array = [ - 3 , - 2 , - 1 , 0 , 1 , 2 , 3 , 4 , 5 , 6 ] INTEGER , DIMENSION ( 5 ) :: list = [ - 2 , 1 , 2 , 4 , 2 ] ! (a) ! print *, my_array(-3, 3) ! (b) print * , my_array ( - 2 : 2 ) ! (c) print * , my_array ( 1 : 5 : 2 ) ! (d) print * , my_array ( list ) end subroutine subroutine p6_8 () !! ** DISCUSSION QUESTION ** !! What will the output from each of the WRITE statements in the following subroutine be? !! Why is the output of the two statements different? INTEGER , DIMENSION ( 0 : 7 ) :: my_data INTEGER :: i , j my_data = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 ] DO i = 0 , 1 WRITE ( * , 100 ) ( my_data ( 4 * i + j ), j = 0 , 3 ) ! Will write two lists of 4 items 100 FORMAT ( 6 ( 1 X , I4 )) END DO WRITE ( * , 100 ) (( my_data ( 4 * i + j ), j = 0 , 3 ), i = 0 , 1 ) ! Will write one line with 6 items and a second line with 2 itmes end subroutine subroutine p6_10 () !! Polar to Rectangular Conversion !! Write a program that reads the polar coordinates of a 2D vector into a rank !! 1 array POLAR. polar(1) will contain the mgnitude and polar(2) will contain the !! angle theta in degrees, and converts the vector from !! polar to rectangular form, storing the result in a rank1 array RECT. !! Rect(1) should be the x component and rect(2) will be the y component. real ( real64 ), parameter :: PI = 3.141592653589793 real ( real64 ), dimension ( 2 ) :: polar , rect real ( real64 ) :: rads integer :: ierr character ( 100 ) :: errmsg print * , \"Please enter the magnitude and angle (degrees) of a point in polar coordinates\" read ( * , * , iostat = ierr , iomsg = errmsg ) polar ( 1 ), polar ( 2 ) if ( ierr == 0 ) then ! No error occurred rads = ( polar ( 2 ) / 180 ) * ( PI ) print * , polar ( 2 ), \" in rads is: \" , rads rect ( 1 ) = polar ( 1 ) * cos ( rads ) rect ( 2 ) = polar ( 1 ) * sin ( rads ) end if print * , \"The polar coordinates \" , polar , \" in rectangular form are:\" print * , rect end subroutine subroutine p6_11 () !! Rectangular to Polar Conversion !! Write a program that reads the rectangular components of a 2D vector into a rank 1 !! array rect. real ( real64 ), parameter :: PI = 3.141592653589793 real ( real64 ), dimension ( 2 ) :: polar , rect real ( real64 ) :: rads , mag integer :: ierr character ( 100 ) :: errmsg print * , \"Please enter the x and y components of a point in rectangular coordinates\" read ( * , * , iostat = ierr , iomsg = errmsg ) rect ( 1 ), rect ( 2 ) if ( ierr == 0 ) then ! No error occurred rads = atan2 ( rect ( 2 ), rect ( 1 )) polar ( 2 ) = rads * ( 180 ) / PI mag = sqrt (( rect ( 1 ) ** 2 + rect ( 2 ) ** 2 )) print * , rads , \" in degrees is \" , polar ( 2 ) polar ( 1 ) = mag end if print * , \"The rect coordinates \" , rect , \" in polar form are:\" print * , polar end subroutine end module","tags":"","loc":"sourcefile/chapter_6.f90.html"},{"title":"chapter_5.f90 – Fortran Program","text":"Contents Modules chapter_5 Source Code chapter_5.f90 Source Code module chapter_5 !! All of the programming exercises for Chapter 5: Basic IO use iso_fortran_env contains subroutine p5_1 () !! ** DISCUSSION QUESTION ** !! What is the purpose of a format? What are the three ways to define a format? print * , \"The purpose of a format is to have complete control of the output/input of a program.\" print * , \"We can, for example, style the output into a table using formats. \" print * , \"We can define a format three different ways.\" print 99 , 1 , \"Using a raw format string in the call: \" print 111 , \"write(*, '(F5.3, A)') my_float, my_character\" print 99 , 2 , \"Using a label combined with a format call:\" print 111 , \"100 FORMAT(F5.3, A) ... write(*,100) my_float, my_character\" print 99 , 3 , \"Storing the format with a variable:\" print 111 , \"FMT = '(F5.3,A)' ... write(*, FMT) my_float, my_character\" 111 format ( T15 , a ) 99 format ( I0 , \"). \" , a ) end subroutine subroutine p5_2 () !! ** DISCUSSION QUESTION ** !! What is printed out by the following Fortran statements? print * , \"(a)\" print * , \"integer :: i\" print * , \"character(len=20) :: fmt\" print * , \"fmt = '('i = ', I8.5)'\" print * , \"i = -123\" print * , \"write(*,fmt) i\" print * , \"write(*, '(I0)') i\" ! (b) ! real :: a, b, sum, difference ! a = 1.0020E6 ! b = 1.0001E6 ! sum = a + b ! difference = a - b ! write (*, 101) a, b, sum, difference ! 101 FORMAT('A = ', ES14.6, ' B = ', E14.6, & ! ' Sum = ', E14.6, ' Diff = ', F14.6) ! (c) ! integer :: i1, i2 ! i1 = 10 ! i2 = 4**2 ! write (*, 300) i1 > i2 ! 300 FORMAT ('Result = ', L6) end subroutine subroutine p5_3 () !! ** DISCUSSION QUESTION ** !! What is printed out by the following Fortran statements? real :: a = 1.602E-19 , b = 5 7.2957795 , c = - 1 print * , \"File:\" print * , \"----\" print * , \"real :: a = 1.602E-19, b = 57.2957795, c = -1\" print * , \"write (*, '(ES14.7, 2(1X, E13.7))') a, b, c\" print * print * , \"Output:\" print * , \"-------\" write ( * , '(ES14.7, 2(1X, E13.7))' ) a , b , c end subroutine subroutine p5_4 ( file_name ) !! ** DISCUSSION QUESTION ** !! Read in 5_4.dat and find out what the output will be for the following statements: character ( * ), intent ( in ) :: file_name Character ( 5 ) :: a Character ( 10 ) :: b character ( 15 ) :: c character ( 100 ) :: errmsg integer :: ierr open ( unit = 10 , file = file_name , iostat = ierr , iomsg = errmsg , status = \"old\" ) if ( ierr /= 0 ) then print * , \"ERR: \" , errmsg else READ ( unit = 10 , fmt = '(3A10)' ) a , b , c close ( unit = 10 ) print * , \"a: \" , a , \" b: \" , b , \" c: \" , c end if end subroutine subroutine p5_5 ( file_name ) !! ** DISCUSSION QUESTION ** !! Read in 5_5.dat and find out what the value of each variable will be when the !! READ statements have been completed character ( * ), intent ( in ) :: file_name integer :: item1 , item2 , item3 , item4 , item5 integer :: item6 , item7 , item8 , item9 , item10 integer :: ierr character ( 100 ) :: errmsg open ( unit = 10 , file = file_name , status = 'old' , action = 'read' , iostat = ierr , iomsg = errmsg ) if ( ierr /= 0 ) then print * , \"ERR: \" , errmsg else ! (a) read ( 10 , * ) item1 , item2 , item3 , item4 , item5 , item6 read ( 10 , * ) item7 , item8 , item9 , item10 ! (b) ! read (10, 8) item1, item2, item3, item4, item5, item6 ! read (10, 8) item7, item8, item9, item10 ! 8 FORMAT(4I10) print * , item1 , item2 , item3 , item4 , item5 , item6 , item7 , item8 , item9 , item10 close ( unit = 10 ) end if end subroutine subroutine p5_6 () !! Generate a table of the base 10 logarithms between 1 and 10 in steps of 0.1 integer :: ipower , jpower , i real , dimension ( 10 , 0 : 9 ) :: result ones_place : do ipower = 1 , 10 tenths_place : do jpower = 0 , 9 result ( ipower , jpower ) = log10 ( ipower + 0.1 * jpower ) end do tenths_place end do ones_place write ( * , 200 ) ( i , i = 0 , 9 ) write ( * , 300 ) write ( * , 100 ) ( i , result ( i ,:), i = 1 , 10 ) 100 format ( I3 , \".0  | \" , 10 F7 . 4 ) 200 format ( 7 ( \" \" ), \"|\" , 10 ( 4 X , \"X.\" , I0 )) 300 format ( 80 ( \"-\" )) end subroutine end module chapter_5","tags":"","loc":"sourcefile/chapter_5.f90.html"},{"title":"flight_of_ball.f90 – Fortran Program","text":"Contents Programs flight_of_ball Source Code flight_of_ball.f90 Source Code program flight_of_ball ! Assuming that a ball is thrown with initial velocity of 20 m/s from a height of 0, find the distance that the ball travels ! for each theta, and then report which theta has the furthest distance travelled. This computation was made much simpler since ! The ball started on the ground. Had it not, we would need to invoke the quadratic formula. (Which in hindsight is not too bad). ! ! Data dictionary: ! ----------------------------------------- ! vx = horizontal component of velocity ! vy = vertical component of velocity ! v0 = initial velocity, 20 m/s ! theta = angle at which ball is released, in degrees ! tf = time when the ball lands ! distance_traveled = an array that keeps track of how long each throw travels along the horizontal component ! FMT = the format for printing a nice table ! max_distance = the maximum amount of distance traveled implicit none real :: vx , vy , v0 = 20 , tf , max_distance = 0 integer :: theta = 0 , max_theta real , dimension ( 0 : 90 ) :: distance_traveled character ( 50 ) :: FMT real , parameter :: PI = 3.1415927 FMT = \"(I3, A, F5.2, A, F6.2, A, F5.2)\" print * , \"Theta | time in air(s) | distance traveled(m) | vy\" print * , \"--------------------------------------------------\" do theta = 0 , 90 , 1 vx = v0 * cos (( theta / 18 0. ) * PI ) vy = v0 * sin (( theta / 18 0. ) * PI ) ! Find tf tf = vy / ( 4.9 ) distance_traveled ( theta ) = tf * vx if ( distance_traveled ( theta ) > max_distance ) then max_distance = distance_traveled ( theta ) max_theta = theta end if print ( FMT ), theta , \" | \" , tf , \" | \" , distance_traveled ( theta ), \" | \" , vy end do print * , \"Max distance traveled: \" , max_distance , \"With theta: \" , max_theta end program","tags":"","loc":"sourcefile/flight_of_ball.f90.html"},{"title":"error_test.f90 – Fortran Program","text":"Contents Programs error_test Source Code error_test.f90 Source Code program error_test ! This program allows me to observe how the error function works integer , allocatable , dimension (:) :: unknown_array allocate ( unknown_array ( 1 )) error stop \"You can't do that!\" end program","tags":"","loc":"sourcefile/error_test.f90.html"},{"title":"demo.f90 – Fortran Program","text":"Contents Programs demo Source Code demo.f90 Source Code program demo use chapter_4 use chapter_5 use chapter_6 integer :: i = 0 , j = 0 , ierr character ( 100 ) :: errmsg print * ! empty line print 123 print 121 , \"| Fortran for Engineers demo suite - Evan Voyles |\" print 123 121 format ( T16 , a ) 123 format ( T16 , 50 ( \"-\" )) mainloop : do call chapter_select () print * , \"[4] Chapter 4: Loops & Character Manipulation\" print * , \"[5] Chapter 5: Basic IO\" print * , \"[6] Chapter 6: Arrays\" print * , \"[7] Chapter 7: Procedures\" print * , \"[8] Chapter 8: Additional Features of Arrays\" print * , \"[9] Chapter 9: Additional Features of Procedures\" print * , \"[10] Chapter 10: Character Variables\" print * print * , \"0 to exit\" read ( unit = 5 , fmt =* , iostat = ierr , iomsg = errmsg ) i if ( ierr /= 0 ) then print * , \"please enter a valid integer from [0:10]\" cycle mainloop end if select case ( i ) case ( 4 ) call chapter_selected ( i ) chapter4 : do print * , \"Problem 1: Legal expressions\" print * , \"Problem 2: Squares of even integers\" print * , \"Problem 3: Function evaluation\" print * , \"Problem 4: Piecewise function evaluation\" print * , \"Problem 5: Factorial\" print * , \"Problem 6: Difference between CYCLE and EXIT\" print * , \"Problem 7: Simple statistics\" print * , \"Problem 8: Loop execution counts\" print * , \"Problem 9: Loop execution values\" print * , \"Problem 10: Loop execution values (pt II)\" print * , \"Problem 11: Flight of ball\" print * , \"Problem 12: Flight of ball (pt II)\" print * , \"Problem 13: Day of the year\" print * , \"Problem 14: Logarithmic function evaluation\" print * , \"Problem 15: Uppercase to lowercase\" print * , \"Problem 16: Calculating orbits\" print * , \"Problem 17: Capitalize first letter\" print * , \"Problem 18: Current through a diode\" print * , \"Problem 19: Binary to decimal\" call problem_select () read ( unit = 5 , fmt =* , iostat = ierr , iomsg = errmsg ) j if ( ierr /= 0 ) then print * , \"please enter a valid integer from [-1:19]\" cycle chapter4 end if call program_start () select case ( j ) case ( 1 ) call p4_1 () case ( 2 ) print * , \"Problem 2 selected\" case ( 3 ) call p4_3 () case ( 4 ) call p4_4 () case ( 5 ) call p4_5 () case ( 6 ) call p4_6 () case ( 7 ) call p4_7 () case ( 8 ) call p4_8 () case ( 9 ) call p4_9 () case ( 10 ) call p4_10 () case ( 11 ) call p4_11 () case ( 12 ) call p4_12 () case ( 13 ) call p4_13 () case ( 14 ) call p4_14 () case ( 15 ) call p4_15 () case ( 16 ) call p4_16 () case ( 17 ) call p4_17 () case ( 18 ) call p4_18 () case ( 19 ) call p4_19 () case ( - 1 ) print * , \"Going to chapter select\" exit chapter4 case ( 0 ) print * , \"Exiting demo\" exit mainloop case default print * , \"Please enter a valid number 1-19, -1 to go back, or 0 to exit\" end select call program_end () end do chapter4 case ( 5 ) call chapter_selected ( i ) chapter5 : do print * , \"Problem 1: What is the purpose of a format?\" print * , \"Problem 2: What is printed?\" print * , \"Problem 3: What is printed? (pt II)\" print * , \"Problem 4: For 5_4.dat, what is read in?\" print * , \"Problem 5: For 5_5.dat, what is read in?\" print * , \"Problem 6: Table of logarithms\" ! print *, \"Problem 7: Simple statistics\" ! print *, \"Problem 8: Loop execution counts\" ! print *, \"Problem 9: Loop execution values\" ! print *, \"Problem 10: Loop execution values (pt II)\" ! print *, \"Problem 11: Flight of ball\" ! print *, \"Problem 12: Flight of ball (pt II)\" ! print *, \"Problem 13: Day of the year\" ! print *, \"Problem 14: Logarithmic function evaluation\" ! print *, \"Problem 15: Uppercase to lowercase\" ! print *, \"Problem 16: Calculating orbits\" ! print *, \"Problem 17: Capitalize first letter\" ! print *, \"Problem 18: Current through a diode\" ! print *, \"Problem 19: Binary to decimal\" call problem_select () read ( unit = 5 , fmt =* , iostat = ierr , iomsg = errmsg ) j if ( ierr /= 0 ) then print * , \"please enter a valid integer from [-1:19]\" cycle chapter5 end if call program_start () select case ( j ) case ( 1 ) call p5_1 () case ( 2 ) call p5_2 () case ( 3 ) call p5_3 () case ( 4 ) call p5_4 ( \"5_4.dat\" ) case ( 5 ) call p5_5 ( \"5_5.dat\" ) case ( 6 ) call p5_6 () ! case(7) !     call p4_7() ! case(8) !     call p4_8() ! case(9) !     call p4_9() ! case(10) !     call p4_10() ! case(11) !     call p4_11() ! case(12) !     call p4_12() ! case(13) !     call p4_13() ! case(14) !     call p4_14() ! case(15) !     call p4_15() ! case(16) !     call p4_16() ! case(17) !     call p4_17() ! case(18) !     call p4_18() ! case(19) !     call p4_19() case ( - 1 ) print * , \"Going to chapter select\" exit chapter5 case ( 0 ) print * , \"Exiting demo\" exit mainloop case default print * , \"Please enter a valid number 1-6, -1 to go back, or 0 to exit\" end select call program_end () end do chapter5 case ( 6 ) call chapter_selected ( i ) chapter6 : do print * , \"Problem 6: Array Terminology\" print * , \"Problem 10: Polar to Rectangular Conversion\" print * , \"Problem 11: Rectangular to Polar Conversion\" ! print *, \"Problem 12: Flight of ball (pt II)\" ! print *, \"Problem 13: Day of the year\" ! print *, \"Problem 14: Logarithmic function evaluation\" ! print *, \"Problem 15: Uppercase to lowercase\" ! print *, \"Problem 16: Calculating orbits\" ! print *, \"Problem 17: Capitalize first letter\" ! print *, \"Problem 18: Current through a diode\" ! print *, \"Problem 19: Binary to decimal\" call problem_select () read ( unit = 5 , fmt =* , iostat = ierr , iomsg = errmsg ) j if ( ierr /= 0 ) then print * , \"please enter a valid integer from [-1:19]\" cycle chapter6 end if call program_start () select case ( j ) ! case(1) !     call p4_1() ! case(2) !     print *, \"Problem 2 selected\" ! case(3) !     call p4_3() ! case(4) !     call p4_4() ! case(5) !     call p4_5() case ( 6 ) call p6_6 () ! case(7) !     call p4_7() ! case(8) !     call p4_8() ! case(9) !     call p4_9() case ( 10 ) call p6_10 () case ( 11 ) call p6_11 () ! case(12) !     call p4_12() ! case(13) !     call p4_13() ! case(14) !     call p4_14() ! case(15) !     call p4_15() ! case(16) !     call p4_16() ! case(17) !     call p4_17() ! case(18) !     call p4_18() ! case(19) !     call p4_19() case ( - 1 ) print * , \"Going to chapter select\" exit chapter6 case ( 0 ) print * , \"Exiting demo\" exit mainloop case default print * , \"Please enter a valid number 6, 10, or 11, -1 to go back, or 0 to exit\" end select call program_end () end do chapter6 ! // TODO ADD ALL OTHER CHAPTERS case ( 7 ) print * , \"Chapter 7 selected\" case ( 8 ) print * , \"Chapter 8 selected\" case ( 9 ) print * , \"Chapter 9 selected\" case ( 10 ) print * , \"Chapter 10 selected\" case ( 11 ) print * , \"Chapter 11 selected\" case ( 12 ) print * , \"Chapter 12 selected\" case ( 13 ) print * , \"Chapter 13 selected\" case ( 14 ) print * , \"Chapter 14 selected\" case ( 15 ) print * , \"Chapter 15 selected\" case ( 16 ) print * , \"Chapter 16 selected\" case ( 17 ) print * , \"Chapter 17 selected\" case ( 0 ) print * , \"Exiting succesfully\" exit mainloop case default print * , \"Please enter a number 1-17\" end select ! print*, \"Example 1: Demo for xy plot\" ! print*, \"Example 2: Line specification\" ! print*, \"Example 3: Plot several data series at the same time\" ! print*, \"Example 4: Plot four data series at the same time\" ! print*, \"Example 5: Use line style, line colors and more...\" ! print*, \"Example 6: An interesting plot, sin(x) and its zero on the same plot\" ! print*, \"Example 7: Plot a matrix against a vector\" ! print*, \"Example 8: Plot a matrix against a vector and set the linespec and legend\" ! print*, \"Example 9: Use gnuplot for animation\" ! print*, \"Example 10: Use ogpf options\" ! print*, \"Example 11: simple polar plot\" ! print*, \"Example 12: A plot with logarithmic x axis\" ! print*, \"Example 13: A matrix plot with logarithmic y axis\" ! print*, \"Example 14: A loglog plot\" ! print*, \"Example 15: Plotting a function\" ! print*, \"Example 16: Save the gnuplot script into a file for future use\" ! print*, \"Example 17: Multi window plots, using script\" ! print*, \"Example 18: Running an external script file\" ! print*, \"Example 19: Multiple linestyle in matrix plot\" ! print*, \"Example 20: Scatter plot\" ! print*, \"Example 21: Stem plot\" ! print*, \"Example 22: Stem plot animation\" ! print*, \"Example 23: Another animation using matrix plot\" ! print*, \"Example 24: Multiplot layout\" ! print*, \"Example 25: Multiplot layout followed by simple plot\" ! print*, \"Example 26: Plot matrix vs. matrix\" ! print*, \"Example 27: Using secondary y axis\" ! print*, \"Example 28: Using secondary x and y axis\" ! print*, \"Example 29: Using color and size for title and labels\" ! print*, \"Example 30: More on labels color and size with secondary axes\" ! print* ! print*, \"***   Surface and Contour Plots ***\" ! print* ! print*, \"Example 101: Simple 3D plot using surf\" ! print*, \"Example 102: Surface plot and color palette \" ! print*, \"Example 103: Surface plot with hidden details and its contour\" ! print*, \"Example 104: Cylindrical mapping\" ! print*, \"Example 105: More contour plot\" ! print*, \"Example 106: Animation of 3D plots\" ! print*, \"Example 106: Multiplot layout in 3D\" ! print*, \"Example 107: Multiplot layout for 3D data\" ! print*, \"Example 108: Plot a 2D grid\" ! print* ! write (unit=*, fmt='(a)') \"2D plots: select an example: 1 through 30\" ! write (unit=*, fmt='(a)') \"3D plots: select an example: 101 through 108\" ! write (unit=*, fmt='(a)', advance='no') \"enter 0 for exit:  \" ! read*, i ! select case(i) !     case(1) !         call exmp01 !     case(2) !         call exmp02 !     case(3) !         call exmp03 !     case(4) !         call exmp04 !     case(5) !         call exmp05 !     case(6) !         call exmp06 !     case(7) !         call exmp07 !     case(8) !         call exmp08 !     case(9) !         call exmp09 !     case(10) !         call exmp10 !     case(11) !         call exmp11 !     case(12) !         call exmp12 !     case(13) !         call exmp13 !     case(14) !         call exmp14 !     case(15) !         call exmp15 !     case(16) !         call exmp16 !     case(17) !         call exmp17 !     case(18) !         call exmp18 !     case(19) !         call exmp19 !     case(20) !         call exmp20 !     case(21) !         call exmp21 !     case(22) !         call exmp22 !     case(23) !         call exmp23 !     case(24) !         call exmp24 !     case(25) !         call exmp25 !     case(26) !         call exmp26 !     case(27) !         call exmp27 !     case(28) !         call exmp28 !     case(29) !         call exmp29 !    case(30) !         call exmp30 !         ! 3D plots !     case(101) !         call exmp101 !     case(102) !         call exmp102 !     case(103) !         call exmp103 !     case(104) !         call exmp104 !     case(105) !         call exmp105 !     case(106) !         call exmp106 !     case(107) !         call exmp107 !    case(108) !         call exmp108 !     case (0) !         print*, \"Program terminated successfully\" !         exit mainloop !     case default !         print*, \"Try again, use a valid example number\" !         print*, \"Enter 0 to exit\" ! end select ! print* ! print*, \"press any key to continue...\" ! read* end do mainloop contains subroutine chapter_select () 999 format ( 80 ( \"*\" )) 111 format ( \"*\" , T34 , a , T80 , \"*\" ) print * print 999 print 111 , \"Select chapter\" print 999 print * end subroutine subroutine chapter_selected ( chp ) integer , intent ( in ) :: chp 999 format ( 80 ( \"*\" )) 111 format ( \"*\" , T34 , a , I0 , a , T80 , \"*\" ) print * print 999 print 111 , \"Chapter \" , chp , \" selected\" print 999 print * end subroutine subroutine problem_select () 999 format ( 80 ( \"*\" )) 111 format ( \"*\" , T34 , a , T80 , \"*\" ) print * print 999 print 111 , \"Select problem\" print 999 print * print * , \"  0 to exit, -1 to go back\" end subroutine subroutine program_start () 999 format ( 80 ( \"*\" )) 111 format ( \"*\" , T34 , a , T80 , \"*\" ) print * print 999 print 111 , \"Program start\" print 999 print * end subroutine subroutine program_end () 999 format ( 80 ( \"*\" )) 111 format ( \"*\" , T34 , a , T80 , \"*\" ) print * print 999 print 111 , \"Program ended\" print 999 print * call to_continue () end subroutine subroutine to_continue () print * , \"Press return to continue....\" read * end subroutine end program","tags":"","loc":"sourcefile/demo.f90.html"},{"title":"coordinates.f95 – Fortran Program","text":"Contents Modules coordinates Source Code coordinates.f95 Source Code module coordinates interface compass_to_cart ! Convert from compass coordinates to cartesian module subroutine compass_to_cart end subroutine end interface end module","tags":"","loc":"sourcefile/coordinates.f95.html"},{"title":"points_t@polar.f95 – Fortran Program","text":"Contents Submodules polar cart Source Code points_t@polar.f95 Source Code ! This module implements the polar functions submodule ( points_t ) polar contains ! module procedure pol_plus_pol ! end procedure module procedure pol_to_cart c1 % x = p1 % r c1 % y = p1 % th end procedure end submodule submodule ( points_t ) cart contains ! module procedure pol_plus_pol ! end procedure module procedure cart_to_pol p1 % r = c1 % x p1 % th = c1 % y end procedure end submodule","tags":"","loc":"sourcefile/points_t@polar.f95.html"},{"title":"trig.f95 – Fortran Program","text":"Contents Modules trig Source Code trig.f95 Source Code module trig real ( 8 ), parameter :: PI_D = 3.141592653589793 real , parameter :: PI = 3.14159265 integer , parameter :: SGL = selected_int_kind ( 7 ) integer , parameter :: DBL = selected_int_kind ( 15 ) interface deg_to_rad module procedure deg_to_rad_sgl module procedure deg_to_rad_dbl module procedure deg_to_rad_int end interface interface rad_to_deg module procedure rad_to_deg_sgl module procedure rad_to_deg_dbl module procedure rad_to_deg_int end interface interface module elemental real function sind ( theta ) real , intent ( in ) :: theta end function module elemental real function cosd ( theta ) real , intent ( in ) :: theta end function module elemental real function tand ( theta ) real , intent ( in ) :: theta end function module elemental real function asind ( theta ) real , intent ( in ) :: theta end function module elemental real function acosd ( theta ) real , intent ( in ) :: theta end function module elemental real function atand ( theta ) real , intent ( in ) :: theta end function end interface contains elemental real ( SGL ) function deg_to_rad_sgl ( degrees ) result ( rad ) real ( SGL ), intent ( in ) :: degrees rad = degrees / 18 0.0 * PI end function elemental real ( DBL ) function deg_to_rad_dbl ( degrees ) result ( rad ) real ( DBL ), intent ( in ) :: degrees rad = degrees / 18 0.0 * PI_D end function elemental real ( SGL ) function deg_to_rad_int ( degrees ) result ( rad ) integer , intent ( in ) :: degrees rad = degrees / 18 0.0 * PI end function elemental real ( SGL ) function rad_to_deg_sgl ( rad ) result ( degrees ) real ( SGL ), intent ( in ) :: rad degrees = rad / PI * 18 0.0 end function elemental real ( DBL ) function rad_to_deg_dbl ( rad ) result ( degrees ) real ( DBL ), intent ( in ) :: rad degrees = rad / PI_D * 18 0.0 end function elemental real ( SGL ) function rad_to_deg_int ( rad ) result ( degrees ) integer , intent ( in ) :: rad degrees = rad / PI * 18 0.0 end function end module","tags":"","loc":"sourcefile/trig.f95.html"},{"title":"trig_degrees.f95 – Fortran Program","text":"Contents Submodules trig_degrees Source Code trig_degrees.f95 Source Code submodule ( trig ) trig_degrees contains module procedure sind sind = sin ( deg_to_rad ( theta )) end procedure module procedure cosd cosd = cos ( deg_to_rad ( theta )) end procedure module procedure tand tand = tan ( deg_to_rad ( theta )) end procedure module procedure acosd acosd = acos ( deg_to_rad ( theta )) end procedure module procedure asind asind = asin ( deg_to_rad ( theta )) end procedure module procedure atand atand = atan ( deg_to_rad ( theta )) end procedure end submodule","tags":"","loc":"sourcefile/trig_degrees.f95.html"},{"title":"radar.f95 – Fortran Program","text":"Contents Modules radar Source Code radar.f95 Source Code module radar use trig real , parameter :: ALPHA = 0.7 real , parameter :: BETA = 0.38 type :: vector real :: x real :: y contains generic :: operator ( + ) => vector_addition generic :: operator ( - ) => vector_substraction generic :: operator ( * ) => vector_times_scalar generic :: operator ( / ) => vector_divided_scalar procedure :: vector_addition procedure :: vector_substraction procedure :: vector_times_scalar procedure :: vector_divided_scalar end type type :: detection real :: range real :: azimuth ! The azimuth in compass degrees real :: time ! The time of detection type ( vector ) :: cart = vector ( 0.0 , 0.0 ) contains procedure :: to_cart procedure :: time_diff procedure :: pos_diff procedure :: compute_velocity end type interface detection procedure :: new_detection end interface interface operator ( * ) procedure :: scalar_times_vector end interface contains type ( detection ) function new_detection ( range , azimuth , time ) real , intent ( in ) :: range , azimuth , time new_detection % range = range new_detection % azimuth = azimuth new_detection % time = time new_detection % cart = new_detection % to_cart () print * , \"new_detection called\" end function elemental type ( vector ) function to_cart ( detect ) result ( cart ) class ( detection ), intent ( in ) :: detect real :: theta theta = compass_to_theta ( detect % azimuth ) cart % x = detect % range * cosd ( theta ) cart % y = detect % range * sind ( theta ) end function elemental real function compass_to_theta ( azimuth ) result ( theta ) ! Convert compass angle to standard unit circle angle real , intent ( in ) :: azimuth theta = azimuth * ( - 1 ) + 90 if ( theta < 0 ) then theta = theta + 36 0.0 else if ( theta >= 36 0.0 ) then theta = theat - 36 0.0 end if end function elemental real function time_diff ( det1 , det2 ) class ( detection ), intent ( in ) :: det1 , det2 time_diff = det2 % time - det1 % time end function elemental type ( vector ) function pos_diff ( det1 , det2 ) class ( detection ), intent ( in ) :: det1 , det2 pos_diff = det1 % cart - det2 % cart end function elemental type ( vector ) function compute_velocity ( det_t0 , det_tf ) class ( detection ), intent ( in ) :: det_t0 , det_tf real :: delta_time type ( vector ) :: delta_pos delta_time = det_t0 % time_diff ( det_tf ) delta_pos = det_t0 % pos_diff ( det_tf ) compute_velocity = delta_pos / delta_time end function elemental type ( vector ) function vector_addition ( v1 , v2 ) result ( v3 ) class ( vector ), intent ( in ) :: v1 , v2 v3 % x = v1 % x + v2 % x v3 % y = v1 % y + v2 % y end function elemental type ( vector ) function vector_substraction ( v1 , v2 ) result ( v3 ) class ( vector ), intent ( in ) :: v1 , v2 v3 % x = v1 % x - v2 % x v3 % y = v1 % y - v2 % y end function elemental type ( vector ) function scalar_times_vector ( scalar , vec ) result ( v2 ) real , intent ( in ) :: scalar class ( vector ), intent ( in ) :: vec v2 % x = vec % x * scalar v2 % y = vec % y * scalar end function elemental type ( vector ) function vector_times_scalar ( vec , scalar ) result ( v2 ) class ( vector ), intent ( in ) :: vec real , intent ( in ) :: scalar v2 % x = vec % x * scalar v2 % y = vec % y * scalar end function elemental type ( vector ) function vector_divided_scalar ( vec , scalar ) result ( v2 ) class ( vector ), intent ( in ) :: vec real , intent ( in ) :: scalar v2 % x = vec % x / scalar v2 % y = vec % y / scalar end function elemental type ( vector ) function predict_position ( smooth_pos , prev_velocity , delta_time ) type ( vector ), intent ( in ) :: smooth_pos , prev_velocity real , intent ( in ) :: delta_time predict_position = smooth_pos + ( prev_velocity * delta_time ) end function elemental type ( vector ) function update_velocity ( prev_velocity , measured_pos , predicted_position , delta_time ) type ( vector ), intent ( in ) :: prev_velocity , measured_pos , predicted_position real , intent ( in ) :: delta_time update_velocity = prev_velocity + ( BETA / delta_time ) * ( measured_pos - predicted_position ) end function elemental type ( vector ) function update_position ( predicted_position , measured_position ) type ( vector ), intent ( in ) :: predicted_position , measured_position update_position = predicted_position + ALPHA * ( measured_position - predicted_position ) end function end module","tags":"","loc":"sourcefile/radar.f95.html"},{"title":"compass_trig.f95 – Fortran Program","text":"Contents Submodules compass Source Code compass_trig.f95 Source Code submodule ( coordinates ) compass use trig contains end submodule","tags":"","loc":"sourcefile/compass_trig.f95.html"},{"title":"test_radar.f95 – Fortran Program","text":"Contents Programs radar_test Source Code test_radar.f95 Source Code ! This program tests the radar module functionality program radar_test use radar implicit none type ( detection ) :: det1 , det2 type ( vector ) :: my_velocity det1 = new_detection ( range = 1 0.0 , azimuth = 4 5.0 , time = 1 0.0 ) det2 = new_detection ( range = 1 5.0 , azimuth = 9 0.0 , time = 1 5.0 ) my_velocity = det1 % compute_velocity ( det2 ) print * , det1 print * , det2 print * , \"The change in pos between det1 and det2 is: \" , det1 % pos_diff ( det2 ) print * , \"Velocity is :\" , my_velocity print * , \"The difference in detection between 1 and 2 is: \" , det1 % time_diff ( det2 ) end program","tags":"","loc":"sourcefile/test_radar.f95.html"},{"title":"points_t.f95 – Fortran Program","text":"Contents Programs test_drive Modules points_t Source Code points_t.f95 Source Code ! A module that defines the polar type, which is a coordinate represented in ! polar coordinates. module points_t type , abstract :: point integer :: kind = 8 end type type , extends ( point ) :: polar real :: r real :: th contains ! generic :: operator(+) => add_pol procedure :: to_cart => pol_to_cart ! procedure :: add_pol => pol_plus_cart, pol_plus_pol end type type , extends ( point ) :: cart real :: x real :: y contains ! generic :: operator(+) => add procedure :: to_pol => cart_to_pol ! procedure :: add => cart_plus_cart, cart_plus_pol end type interface ! module type(polar) function pol_plus_pol(p1, p2) !     class(polar), intent(in) :: p1, p2 ! end function ! module type(polar) function pol_plus_cart(p1, c1) !     class(polar), intent(in) :: p1 !     class(cart), intent(in) :: c1 ! end function ! module type(cart) function cart_plus_cart(c1, c2) !     class(cart), intent(in) :: c1, c2 ! end function ! module type(cart) function cart_plus_pol(c1, p1) !     class(cart), intent(in) :: c1 !     class(polar), intent(in) :: p1 ! end function module type ( cart ) function pol_to_cart ( p1 ) result ( c1 ) class ( polar ), intent ( in ) :: p1 end function module type ( polar ) function cart_to_pol ( c1 ) result ( p1 ) class ( cart ), intent ( in ) :: c1 end function end interface end module program test_drive use points_t type ( polar ) :: my_p type ( cart ) :: my_c my_p = polar ( kind = 8 , r = 3 , th = 10 ) print * , my_p my_c = my_p % to_cart () print * , my_c end program","tags":"","loc":"sourcefile/points_t.f95.html"},{"title":"vector – Fortran Program ","text":"type, public :: vector Contents Variables x y Type-Bound Procedures operator(+) operator(-) operator(*) operator(/) vector_addition vector_substraction vector_times_scalar vector_divided_scalar Components Type Visibility Attributes Name Initial real, public :: x real, public :: y Type-Bound Procedures generic, public :: operator(+) => vector_addition public elemental function vector_addition (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: v1 class( vector ), intent(in) :: v2 Return Value type( vector ) generic, public :: operator(-) => vector_substraction public elemental function vector_substraction (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: v1 class( vector ), intent(in) :: v2 Return Value type( vector ) generic, public :: operator(*) => vector_times_scalar public elemental function vector_times_scalar (vec, scalar) result(v2) Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: vec real, intent(in) :: scalar Return Value type( vector ) generic, public :: operator(/) => vector_divided_scalar public elemental function vector_divided_scalar (vec, scalar) result(v2) Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: vec real, intent(in) :: scalar Return Value type( vector ) procedure, public :: vector_addition public elemental function vector_addition (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: v1 class( vector ), intent(in) :: v2 Return Value type( vector ) procedure, public :: vector_substraction public elemental function vector_substraction (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: v1 class( vector ), intent(in) :: v2 Return Value type( vector ) procedure, public :: vector_times_scalar public elemental function vector_times_scalar (vec, scalar) result(v2) Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: vec real, intent(in) :: scalar Return Value type( vector ) procedure, public :: vector_divided_scalar public elemental function vector_divided_scalar (vec, scalar) result(v2) Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: vec real, intent(in) :: scalar Return Value type( vector )","tags":"","loc":"type/vector.html"},{"title":"detection – Fortran Program ","text":"type, public :: detection Contents Variables range azimuth time cart Constructor detection Type-Bound Procedures to_cart time_diff pos_diff compute_velocity Components Type Visibility Attributes Name Initial real, public :: range real, public :: azimuth real, public :: time type( vector ), public :: cart = vector(0.0, 0.0) Constructor public interface detection public function new_detection (range, azimuth, time) Arguments Type Intent Optional Attributes Name real, intent(in) :: range real, intent(in) :: azimuth real, intent(in) :: time Return Value type( detection ) Type-Bound Procedures procedure, public :: to_cart public elemental function to_cart (detect) result(cart) Arguments Type Intent Optional Attributes Name class( detection ), intent(in) :: detect Return Value type( vector ) procedure, public :: time_diff public elemental function time_diff (det1, det2) Arguments Type Intent Optional Attributes Name class( detection ), intent(in) :: det1 class( detection ), intent(in) :: det2 Return Value real procedure, public :: pos_diff public elemental function pos_diff (det1, det2) Arguments Type Intent Optional Attributes Name class( detection ), intent(in) :: det1 class( detection ), intent(in) :: det2 Return Value type( vector ) procedure, public :: compute_velocity public elemental function compute_velocity (det_t0, det_tf) Arguments Type Intent Optional Attributes Name class( detection ), intent(in) :: det_t0 class( detection ), intent(in) :: det_tf Return Value type( vector )","tags":"","loc":"type/detection.html"},{"title":"point – Fortran Program ","text":"type, public, abstract :: point Contents Variables kind Components Type Visibility Attributes Name Initial integer, public :: kind = 8","tags":"","loc":"type/point.html"},{"title":"polar – Fortran Program ","text":"type, public, extends( point ) :: polar Contents Variables kind r th Type-Bound Procedures to_cart Components Type Visibility Attributes Name Initial integer, public :: kind = 8 real, public :: r real, public :: th Type-Bound Procedures procedure, public :: to_cart => pol_to_cart interface public module function pol_to_cart(p1) result(c1) Arguments Type Intent Optional Attributes Name class( polar ), intent(in) :: p1 Return Value type( cart )","tags":"","loc":"type/polar.html"},{"title":"cart – Fortran Program ","text":"type, public, extends( point ) :: cart Contents Variables kind x y Type-Bound Procedures to_pol Components Type Visibility Attributes Name Initial integer, public :: kind = 8 real, public :: x real, public :: y Type-Bound Procedures procedure, public :: to_pol => cart_to_pol interface public module function cart_to_pol(c1) result(p1) Arguments Type Intent Optional Attributes Name class( cart ), intent(in) :: c1 Return Value type( polar )","tags":"","loc":"type/cart.html"},{"title":"is_alphnum – Fortran Program","text":"public function is_alphnum(char) Test whether an ASCII character is alpha-numeric Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: char Return Value logical Contents None","tags":"","loc":"proc/is_alphnum.html"},{"title":"is_alph – Fortran Program","text":"public function is_alph(char) Test whether an ASCII character is a letter Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: char Return Value logical Contents None","tags":"","loc":"proc/is_alph.html"},{"title":"is_num – Fortran Program","text":"public function is_num(char) Test whether an ASCII character is numeric Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: char Return Value logical Contents None","tags":"","loc":"proc/is_num.html"},{"title":"is_lower – Fortran Program","text":"public function is_lower(char) Test whether an ASCII character is a lowercase letter Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: char Return Value logical Contents None","tags":"","loc":"proc/is_lower.html"},{"title":"is_upper – Fortran Program","text":"public function is_upper(char) Test whether an ASCII character is an uppercase letter Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: char Return Value logical Contents None","tags":"","loc":"proc/is_upper.html"},{"title":"calc_current_flow – Fortran Program","text":"public elemental function calc_current_flow(v_D, I_O, T) result(i_D) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: v_D The voltage across the diode, in volts real(kind=real64), intent(in) :: I_O The leakage current of the diode, in amperes real(kind=real64), intent(in) :: T Temperature, in kelvins (K) Return Value real(kind=real64) The current flow through the diode in amperes Contents None","tags":"","loc":"proc/calc_current_flow.html"},{"title":"to_kelvin – Fortran Program","text":"public elemental function to_kelvin(F) Convert a temperature in Fahrenheit to Kelvin Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: F Return Value real(kind=real64) Contents None","tags":"","loc":"proc/to_kelvin.html"},{"title":"to_celcius – Fortran Program","text":"public elemental function to_celcius(F) Convert a temperature from Fahrenheit to celcius Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: F Return Value real(kind=real64) Contents None","tags":"","loc":"proc/to_celcius.html"},{"title":"p4_1 – Fortran Program","text":"public subroutine p4_1() Test if the following equalities are valid statements, and if they are,\n evaluate them Arguments None Contents None","tags":"","loc":"proc/p4_1.html"},{"title":"p4_3 – Fortran Program","text":"public subroutine p4_3() Write a Fortran program to evaluate the equation y(x) = x&#94;2 - 3x + 2 for all values between -1 and 3,\n in steps of 0.1. Arguments None Contents None","tags":"","loc":"proc/p4_3.html"},{"title":"p4_4 – Fortran Program","text":"public subroutine p4_4() Write the Fortran statements required to calculate y(t) from the equation: y(t) = ------ -3t&#94;2 + 5    t >= 0\n           ---   3t&#94;2 + 5    t < 0 Arguments None Contents None","tags":"","loc":"proc/p4_4.html"},{"title":"p4_5 – Fortran Program","text":"public subroutine p4_5() Write a Fortran program to calculate the factorial function. Be sure to handle the special \n cases of 0! and of illegal input values. Arguments None Contents None","tags":"","loc":"proc/p4_5.html"},{"title":"p4_6 – Fortran Program","text":"public subroutine p4_6() What is the difference in behavior between a cycle statement and an exit statement? Arguments None Contents None","tags":"","loc":"proc/p4_6.html"},{"title":"p4_7 – Fortran Program","text":"public subroutine p4_7() Modify program stats_2 to use the DO WHILE construct instaed of the while construct currently in the program A modified statistical analysis program that avoids the divide-by-zero problems inherent in program stats_1. Purpose: To calculate mean and the standard deviation of an input data set containing an arbitrary number of input values. Record of revisions: Date      Programmer     Description of change\n  ====      ==========     =====================\n 11/10/15  S. J. Chapman   Original code\n 11/12/15  S. J. Chapman   Correct divide-by-0 error if\n                           0 or 1 input values given.\n 02/16/21  E. J. Voyles    Add do-while construct Arguments None Contents None","tags":"","loc":"proc/p4_7.html"},{"title":"p4_8 – Fortran Program","text":"public subroutine p4_8() Examine the following DO statements and determine how many times each loop will\n be exectued. !!! This for loop shows an error, since the increment is 0 !!!!!!!!!! Arguments None Contents None","tags":"","loc":"proc/p4_8.html"},{"title":"p4_9 – Fortran Program","text":"public subroutine p4_9() Examine the following loops, determine the value of ires and the number of times\n each loop executes Arguments None Contents None","tags":"","loc":"proc/p4_9.html"},{"title":"p4_10 – Fortran Program","text":"public subroutine p4_10() Examine the followin while loops and determine the value of ires at the end of each of \n the loops. Arguments None Contents None","tags":"","loc":"proc/p4_10.html"},{"title":"p4_11 – Fortran Program","text":"public subroutine p4_11() Modify program ball from example 4-7 to read in the acceleration due to gravity\n at a particular location, and to calculate the maximum range of the ball for that acceleration.\n After modifying the program, run it with accelerations of -9.8, -9.7, and -9.6m/s2. What effect does the reduction in gravitational attraction have on the range ofthe ball?\n What effect does the reduction in gravitational attraction have on the best angle theta at which to throw the ball? Arguments None Contents None","tags":"","loc":"proc/p4_11.html"},{"title":"p4_12 – Fortran Program","text":"public subroutine p4_12() Modify program ball from Example 4-7 to read in the initial velocity with which the ball\n is thrown. After modifying the program, run it with initial velocities of 10, 20, and 20 \n m/sec. What effect does changin the initial velocity have on the range of the ball? What\n effect does it have on the best angle theta at which to throw the ball? Arguments None Contents None","tags":"","loc":"proc/p4_12.html"},{"title":"p4_13 – Fortran Program","text":"public subroutine p4_13() Arguments None Contents None","tags":"","loc":"proc/p4_13.html"},{"title":"p4_14 – Fortran Program","text":"public subroutine p4_14() Write a Fortran program to evaluate the function \n y(x) = ln(1/1-x)\n for any user-specified value of x, where ln is the natural logarithm.\n Write the program with a while loop, so that the program repeats the calculation \n for each legal value of x entered into the program. When an illegal value of x is entered,\n terminate the program. Arguments None Contents None","tags":"","loc":"proc/p4_14.html"},{"title":"p4_15 – Fortran Program","text":"public subroutine p4_15() Write a Fortran program to convert all uppercase characters in a user-supplied character\n string to lowercase, without changing the uppercase and nonalphabetic characters in the string.\n Assume that your computer uses the ASCII collating sequence. Arguments None Contents None","tags":"","loc":"proc/p4_15.html"},{"title":"p4_16 – Fortran Program","text":"public subroutine p4_16() Calculating Orbits. When a satellinte orbits the Eath, the satellite's orbit will form an ellipse with the \n Earth located at one of the focal points of the ellipse. The satellite's orbit can be \n expressed in polar coordintaes as r = p/(1 - \\epsilon * cos( \\theta )) Where r and theta are the distance and angle of the satellite from the center of the earth,\n p is a parameter specifying the size of the orbit, and \\epsilon is a parameter representing the\n eccentricity of the orbit. A circular orbit has an eccentricity of zero. An elliptical orbit has \n an eccentricity of 0 <= e <= 1. If \\epsilon > 1, the satellite follows a hyperbolic path and escapes\n from Earth's gravitational field. Consider a satellite with a size parameter p = 1200 km. Write a program to calculate the \n distance of the satellite from the center of the Earth as a function of theta if the satellite has \n an eccentricity of (a) e = 0; (b) e = 0.25; (c) e = 0.5. Write a single program in which\n r and e are both input values. How close does each orbit come to the earth? How far away does each orbit get from the earth? Arguments None Contents None","tags":"","loc":"proc/p4_16.html"},{"title":"p4_17 – Fortran Program","text":"public subroutine p4_17() Write a program caps that reads in a character string, searches for all of the words \n within the string, and capitalizes the first letter of each word, while shifting the \n remainder of the word to lowercase. Assume that all nonalphabetic and nonumeric characters\n can mark the boundaries of a word within the character variable (periods, commas,etc.). \n Nonalphabetic characters should be left unchanged. Arguments None Contents None","tags":"","loc":"proc/p4_17.html"},{"title":"p4_18 – Fortran Program","text":"public subroutine p4_18() Write a computer program to calculate the current flowing through this diode\n for all voltages from -1.0V to +0.6 V, in 0.1 V steps. Repeat this process for the \n following temperatures: 75F, 100F, and 125F Arguments None Contents None","tags":"","loc":"proc/p4_18.html"},{"title":"p4_19 – Fortran Program","text":"public subroutine p4_19() Write a program that promps a user for a binary number, which will be entered as a string\n of 0s and 1s in a character variable. This program should be able to handle numbers whos\n binary representation is up to 10 bits, corresponding to values from 0 to 1023. Arguments None Contents None","tags":"","loc":"proc/p4_19.html"},{"title":"to_lower – Fortran Program","text":"public subroutine to_lower(char) Convert a single character to lowercase Arguments Type Intent Optional Attributes Name character(len=1), intent(inout) :: char Contents None","tags":"","loc":"proc/to_lower.html"},{"title":"to_upper – Fortran Program","text":"public subroutine to_upper(char) Convert a single character to uppercase Arguments Type Intent Optional Attributes Name character(len=1), intent(inout) :: char Contents None","tags":"","loc":"proc/to_upper.html"},{"title":"p7_1 – Fortran Program","text":"public subroutine p7_1() DISCUSSION QUESTION \\\n What is the difference between a subroutine and a function? Arguments None Contents None","tags":"","loc":"proc/p7_1.html"},{"title":"p7_2 – Fortran Program","text":"public subroutine p7_2() DISCUSSION QUESTION \\\n When a subroutine is called, how is data passed from the calling program to the subroutine,\n and how are the results of the subroutine returned to the calling program? Arguments None Contents None","tags":"","loc":"proc/p7_2.html"},{"title":"p7_3 – Fortran Program","text":"public subroutine p7_3() DISCUSSION QUESTION \\\n What are the advantages and disadvantages of the pass-by-reference scheme used in Fortran? Arguments None Contents None","tags":"","loc":"proc/p7_3.html"},{"title":"p7_4 – Fortran Program","text":"public subroutine p7_4() DISCUSSION QUESTION \\\n What are the advantages and disadvantages of each procedure array type? Arguments None Contents None","tags":"","loc":"proc/p7_4.html"},{"title":"p7_5 – Fortran Program","text":"public subroutine p7_5() DISCUSSION QUESTION I put a br here..\n Suppose a 15-element array is passed to a subroutine. What happens if the subroutine attempts\n to write to element a(16)? Arguments None Contents None","tags":"","loc":"proc/p7_5.html"},{"title":"p6_1 – Fortran Program","text":"public subroutine p6_1() DISCUSSION QUESTION How may arrays be declared? Arguments None Contents None","tags":"","loc":"proc/p6_1.html"},{"title":"p6_3 – Fortran Program","text":"public subroutine p6_3() DISCUSSION QUESTION Execute this subroutine on your computer with both bounds checking turned on and \n bounds checking turned off. What happens? Arguments None Contents None","tags":"","loc":"proc/p6_3.html"},{"title":"p6_4 – Fortran Program","text":"public subroutine p6_4() DISCUSSION QUESTION Determine the shape and size of the arrays specified by the following statements: Arguments None Contents None","tags":"","loc":"proc/p6_4.html"},{"title":"p6_5 – Fortran Program","text":"public subroutine p6_5() DISCUSSION QUESTION Determine which of the following Fortran program fragments are valid. For each valid statement,\n specify what will happen in the program. (Assume default typing for any variables that are not \n explicitly typed within the program fragments.) Arguments None Contents None","tags":"","loc":"proc/p6_5.html"},{"title":"p6_6 – Fortran Program","text":"public subroutine p6_6() DISCUSSION QUESTION What is meant by each of the following array terms? Size, shape, extent, rank, conformable. Arguments None Contents None","tags":"","loc":"proc/p6_6.html"},{"title":"p6_7 – Fortran Program","text":"public subroutine p6_7() DISCUSSION QUESTION Given an array my_array defined as shown, determine whether each of the following\n array sections is valid Arguments None Contents None","tags":"","loc":"proc/p6_7.html"},{"title":"p6_8 – Fortran Program","text":"public subroutine p6_8() DISCUSSION QUESTION What will the output from each of the WRITE statements in the following subroutine be?\n Why is the output of the two statements different? Arguments None Contents None","tags":"","loc":"proc/p6_8.html"},{"title":"p6_10 – Fortran Program","text":"public subroutine p6_10() Polar to Rectangular Conversion Write a program that reads the polar coordinates of a 2D vector into a rank\n 1 array POLAR. polar(1) will contain the mgnitude and polar(2) will contain the \n angle theta in degrees, and converts the vector from\n polar to rectangular form, storing the result in a rank1 array RECT.\n Rect(1) should be the x component and rect(2) will be the y component. Arguments None Contents None","tags":"","loc":"proc/p6_10.html"},{"title":"p6_11 – Fortran Program","text":"public subroutine p6_11() Rectangular to Polar Conversion Write a program that reads the rectangular components of a 2D vector into a rank 1\n array rect. Arguments None Contents None","tags":"","loc":"proc/p6_11.html"},{"title":"p5_1 – Fortran Program","text":"public subroutine p5_1() DISCUSSION QUESTION What is the purpose of a format? What are the three ways to define a format? Arguments None Contents None","tags":"","loc":"proc/p5_1.html"},{"title":"p5_2 – Fortran Program","text":"public subroutine p5_2() DISCUSSION QUESTION What is printed out by the following Fortran statements? Arguments None Contents None","tags":"","loc":"proc/p5_2.html"},{"title":"p5_3 – Fortran Program","text":"public subroutine p5_3() DISCUSSION QUESTION What is printed out by the following Fortran statements? Arguments None Contents None","tags":"","loc":"proc/p5_3.html"},{"title":"p5_4 – Fortran Program","text":"public subroutine p5_4(file_name) DISCUSSION QUESTION Read in 5_4.dat and find out what the output will be for the following statements: Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name Contents None","tags":"","loc":"proc/p5_4.html"},{"title":"p5_5 – Fortran Program","text":"public subroutine p5_5(file_name) DISCUSSION QUESTION Read in 5_5.dat and find out what the value of each variable will be when the \n READ statements have been completed Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name Contents None","tags":"","loc":"proc/p5_5.html"},{"title":"p5_6 – Fortran Program","text":"public subroutine p5_6() Generate a table of the base 10 logarithms between 1 and 10 in steps of 0.1 Arguments None Contents None","tags":"","loc":"proc/p5_6.html"},{"title":"chapter_select – Fortran Program","text":"subroutine chapter_select() Arguments None Contents None","tags":"","loc":"proc/chapter_select.html"},{"title":"chapter_selected – Fortran Program","text":"subroutine chapter_selected(chp) Arguments Type Intent Optional Attributes Name integer, intent(in) :: chp Contents None","tags":"","loc":"proc/chapter_selected.html"},{"title":"problem_select – Fortran Program","text":"subroutine problem_select() Arguments None Contents None","tags":"","loc":"proc/problem_select.html"},{"title":"program_start – Fortran Program","text":"subroutine program_start() Arguments None Contents None","tags":"","loc":"proc/program_start.html"},{"title":"program_end – Fortran Program","text":"subroutine program_end() Arguments None Contents None","tags":"","loc":"proc/program_end.html"},{"title":"to_continue – Fortran Program","text":"subroutine to_continue() Arguments None Contents None","tags":"","loc":"proc/to_continue.html"},{"title":"compass_to_cart – Fortran Program","text":"public interface compass_to_cart Contents Subroutines compass_to_cart Subroutines public subroutine compass_to_cart() Arguments None","tags":"","loc":"interface/compass_to_cart.html"},{"title":"deg_to_rad_sgl – Fortran Program","text":"public elemental function deg_to_rad_sgl(degrees) result(rad) Arguments Type Intent Optional Attributes Name real(kind=SGL), intent(in) :: degrees Return Value real(kind=SGL) Contents None","tags":"","loc":"proc/deg_to_rad_sgl.html"},{"title":"deg_to_rad_dbl – Fortran Program","text":"public elemental function deg_to_rad_dbl(degrees) result(rad) Arguments Type Intent Optional Attributes Name real(kind=DBL), intent(in) :: degrees Return Value real(kind=DBL) Contents None","tags":"","loc":"proc/deg_to_rad_dbl.html"},{"title":"deg_to_rad_int – Fortran Program","text":"public elemental function deg_to_rad_int(degrees) result(rad) Arguments Type Intent Optional Attributes Name integer, intent(in) :: degrees Return Value real(kind=SGL) Contents None","tags":"","loc":"proc/deg_to_rad_int.html"},{"title":"rad_to_deg_sgl – Fortran Program","text":"public elemental function rad_to_deg_sgl(rad) result(degrees) Arguments Type Intent Optional Attributes Name real(kind=SGL), intent(in) :: rad Return Value real(kind=SGL) Contents None","tags":"","loc":"proc/rad_to_deg_sgl.html"},{"title":"rad_to_deg_dbl – Fortran Program","text":"public elemental function rad_to_deg_dbl(rad) result(degrees) Arguments Type Intent Optional Attributes Name real(kind=DBL), intent(in) :: rad Return Value real(kind=DBL) Contents None","tags":"","loc":"proc/rad_to_deg_dbl.html"},{"title":"rad_to_deg_int – Fortran Program","text":"public elemental function rad_to_deg_int(rad) result(degrees) Arguments Type Intent Optional Attributes Name integer, intent(in) :: rad Return Value real(kind=SGL) Contents None","tags":"","loc":"proc/rad_to_deg_int.html"},{"title":"deg_to_rad – Fortran Program","text":"public interface deg_to_rad Contents Module Procedures deg_to_rad_sgl deg_to_rad_dbl deg_to_rad_int Module Procedures public elemental function deg_to_rad_sgl (degrees) result(rad) Arguments Type Intent Optional Attributes Name real(kind=SGL), intent(in) :: degrees Return Value real(kind=SGL) public elemental function deg_to_rad_dbl (degrees) result(rad) Arguments Type Intent Optional Attributes Name real(kind=DBL), intent(in) :: degrees Return Value real(kind=DBL) public elemental function deg_to_rad_int (degrees) result(rad) Arguments Type Intent Optional Attributes Name integer, intent(in) :: degrees Return Value real(kind=SGL)","tags":"","loc":"interface/deg_to_rad.html"},{"title":"rad_to_deg – Fortran Program","text":"public interface rad_to_deg Contents Module Procedures rad_to_deg_sgl rad_to_deg_dbl rad_to_deg_int Module Procedures public elemental function rad_to_deg_sgl (rad) result(degrees) Arguments Type Intent Optional Attributes Name real(kind=SGL), intent(in) :: rad Return Value real(kind=SGL) public elemental function rad_to_deg_dbl (rad) result(degrees) Arguments Type Intent Optional Attributes Name real(kind=DBL), intent(in) :: rad Return Value real(kind=DBL) public elemental function rad_to_deg_int (rad) result(degrees) Arguments Type Intent Optional Attributes Name integer, intent(in) :: rad Return Value real(kind=SGL)","tags":"","loc":"interface/rad_to_deg.html"},{"title":"sind – Fortran Program","text":"interface public elemental module function sind(theta) Arguments Type Intent Optional Attributes Name real, intent(in) :: theta Return Value real","tags":"","loc":"interface/sind.html"},{"title":"cosd – Fortran Program","text":"interface public elemental module function cosd(theta) Arguments Type Intent Optional Attributes Name real, intent(in) :: theta Return Value real","tags":"","loc":"interface/cosd.html"},{"title":"tand – Fortran Program","text":"interface public elemental module function tand(theta) Arguments Type Intent Optional Attributes Name real, intent(in) :: theta Return Value real","tags":"","loc":"interface/tand.html"},{"title":"asind – Fortran Program","text":"interface public elemental module function asind(theta) Arguments Type Intent Optional Attributes Name real, intent(in) :: theta Return Value real","tags":"","loc":"interface/asind.html"},{"title":"acosd – Fortran Program","text":"interface public elemental module function acosd(theta) Arguments Type Intent Optional Attributes Name real, intent(in) :: theta Return Value real","tags":"","loc":"interface/acosd.html"},{"title":"atand – Fortran Program","text":"interface public elemental module function atand(theta) Arguments Type Intent Optional Attributes Name real, intent(in) :: theta Return Value real","tags":"","loc":"interface/atand.html"},{"title":"new_detection – Fortran Program","text":"public function new_detection(range, azimuth, time) Arguments Type Intent Optional Attributes Name real, intent(in) :: range real, intent(in) :: azimuth real, intent(in) :: time Return Value type( detection ) Contents None","tags":"","loc":"proc/new_detection.html"},{"title":"to_cart – Fortran Program","text":"public elemental function to_cart(detect) result(cart) Arguments Type Intent Optional Attributes Name class( detection ), intent(in) :: detect Return Value type( vector ) Contents None","tags":"","loc":"proc/to_cart.html"},{"title":"compass_to_theta – Fortran Program","text":"public elemental function compass_to_theta(azimuth) result(theta) Arguments Type Intent Optional Attributes Name real, intent(in) :: azimuth Return Value real Contents None","tags":"","loc":"proc/compass_to_theta.html"},{"title":"time_diff – Fortran Program","text":"public elemental function time_diff(det1, det2) Arguments Type Intent Optional Attributes Name class( detection ), intent(in) :: det1 class( detection ), intent(in) :: det2 Return Value real Contents None","tags":"","loc":"proc/time_diff.html"},{"title":"pos_diff – Fortran Program","text":"public elemental function pos_diff(det1, det2) Arguments Type Intent Optional Attributes Name class( detection ), intent(in) :: det1 class( detection ), intent(in) :: det2 Return Value type( vector ) Contents None","tags":"","loc":"proc/pos_diff.html"},{"title":"compute_velocity – Fortran Program","text":"public elemental function compute_velocity(det_t0, det_tf) Arguments Type Intent Optional Attributes Name class( detection ), intent(in) :: det_t0 class( detection ), intent(in) :: det_tf Return Value type( vector ) Contents None","tags":"","loc":"proc/compute_velocity.html"},{"title":"vector_addition – Fortran Program","text":"public elemental function vector_addition(v1, v2) result(v3) Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: v1 class( vector ), intent(in) :: v2 Return Value type( vector ) Contents None","tags":"","loc":"proc/vector_addition.html"},{"title":"vector_substraction – Fortran Program","text":"public elemental function vector_substraction(v1, v2) result(v3) Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: v1 class( vector ), intent(in) :: v2 Return Value type( vector ) Contents None","tags":"","loc":"proc/vector_substraction.html"},{"title":"scalar_times_vector – Fortran Program","text":"public elemental function scalar_times_vector(scalar, vec) result(v2) Arguments Type Intent Optional Attributes Name real, intent(in) :: scalar class( vector ), intent(in) :: vec Return Value type( vector ) Contents None","tags":"","loc":"proc/scalar_times_vector.html"},{"title":"vector_times_scalar – Fortran Program","text":"public elemental function vector_times_scalar(vec, scalar) result(v2) Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: vec real, intent(in) :: scalar Return Value type( vector ) Contents None","tags":"","loc":"proc/vector_times_scalar.html"},{"title":"vector_divided_scalar – Fortran Program","text":"public elemental function vector_divided_scalar(vec, scalar) result(v2) Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: vec real, intent(in) :: scalar Return Value type( vector ) Contents None","tags":"","loc":"proc/vector_divided_scalar.html"},{"title":"predict_position – Fortran Program","text":"public elemental function predict_position(smooth_pos, prev_velocity, delta_time) Arguments Type Intent Optional Attributes Name type( vector ), intent(in) :: smooth_pos type( vector ), intent(in) :: prev_velocity real, intent(in) :: delta_time Return Value type( vector ) Contents None","tags":"","loc":"proc/predict_position.html"},{"title":"update_velocity – Fortran Program","text":"public elemental function update_velocity(prev_velocity, measured_pos, predicted_position, delta_time) Arguments Type Intent Optional Attributes Name type( vector ), intent(in) :: prev_velocity type( vector ), intent(in) :: measured_pos type( vector ), intent(in) :: predicted_position real, intent(in) :: delta_time Return Value type( vector ) Contents None","tags":"","loc":"proc/update_velocity.html"},{"title":"update_position – Fortran Program","text":"public elemental function update_position(predicted_position, measured_position) Arguments Type Intent Optional Attributes Name type( vector ), intent(in) :: predicted_position type( vector ), intent(in) :: measured_position Return Value type( vector ) Contents None","tags":"","loc":"proc/update_position.html"},{"title":"detection – Fortran Program","text":"public interface detection Contents Module Procedures new_detection Module Procedures public function new_detection (range, azimuth, time) Arguments Type Intent Optional Attributes Name real, intent(in) :: range real, intent(in) :: azimuth real, intent(in) :: time Return Value type( detection )","tags":"","loc":"interface/detection.html"},{"title":"operator(*) – Fortran Program","text":"public interface operator(*) Contents Module Procedures scalar_times_vector Module Procedures public elemental function scalar_times_vector (scalar, vec) result(v2) Arguments Type Intent Optional Attributes Name real, intent(in) :: scalar class( vector ), intent(in) :: vec Return Value type( vector )","tags":"","loc":"interface/operator(*).html"},{"title":"pol_to_cart – Fortran Program","text":"interface public module function pol_to_cart(p1) result(c1) Arguments Type Intent Optional Attributes Name class( polar ), intent(in) :: p1 Return Value type( cart )","tags":"","loc":"interface/pol_to_cart.html"},{"title":"cart_to_pol – Fortran Program","text":"interface public module function cart_to_pol(c1) result(p1) Arguments Type Intent Optional Attributes Name class( cart ), intent(in) :: c1 Return Value type( polar )","tags":"","loc":"interface/cart_to_pol.html"},{"title":"chapter_4 – Fortran Program","text":"All of the programming exercises for Chapter 4: Loops and Character Manipulation Uses iso_fortran_env Contents Functions is_alphnum is_alph is_num is_lower is_upper calc_current_flow to_kelvin to_celcius Subroutines p4_1 p4_3 p4_4 p4_5 p4_6 p4_7 p4_8 p4_9 p4_10 p4_11 p4_12 p4_13 p4_14 p4_15 p4_16 p4_17 p4_18 p4_19 to_lower to_upper Functions public function is_alphnum (char) Test whether an ASCII character is alpha-numeric Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: char Return Value logical public function is_alph (char) Test whether an ASCII character is a letter Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: char Return Value logical public function is_num (char) Test whether an ASCII character is numeric Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: char Return Value logical public function is_lower (char) Test whether an ASCII character is a lowercase letter Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: char Return Value logical public function is_upper (char) Test whether an ASCII character is an uppercase letter Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: char Return Value logical public elemental function calc_current_flow (v_D, I_O, T) result(i_D) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: v_D The voltage across the diode, in volts real(kind=real64), intent(in) :: I_O The leakage current of the diode, in amperes real(kind=real64), intent(in) :: T Temperature, in kelvins (K) Return Value real(kind=real64) The current flow through the diode in amperes public elemental function to_kelvin (F) Convert a temperature in Fahrenheit to Kelvin Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: F Return Value real(kind=real64) public elemental function to_celcius (F) Convert a temperature from Fahrenheit to celcius Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: F Return Value real(kind=real64) Subroutines public subroutine p4_1 () Test if the following equalities are valid statements, and if they are,\n evaluate them Arguments None public subroutine p4_3 () Write a Fortran program to evaluate the equation y(x) = x&#94;2 - 3x + 2 for all values between -1 and 3,\n in steps of 0.1. Arguments None public subroutine p4_4 () Write the Fortran statements required to calculate y(t) from the equation: Read more… Arguments None public subroutine p4_5 () Write a Fortran program to calculate the factorial function. Be sure to handle the special \n cases of 0! and of illegal input values. Arguments None public subroutine p4_6 () What is the difference in behavior between a cycle statement and an exit statement? Arguments None public subroutine p4_7 () Modify program stats_2 to use the DO WHILE construct instaed of the while construct currently in the program Read more… Arguments None public subroutine p4_8 () Examine the following DO statements and determine how many times each loop will\n be exectued. Read more… Arguments None public subroutine p4_9 () Examine the following loops, determine the value of ires and the number of times\n each loop executes Arguments None public subroutine p4_10 () Examine the followin while loops and determine the value of ires at the end of each of \n the loops. Arguments None public subroutine p4_11 () Modify program ball from example 4-7 to read in the acceleration due to gravity\n at a particular location, and to calculate the maximum range of the ball for that acceleration.\n After modifying the program, run it with accelerations of -9.8, -9.7, and -9.6m/s2. Read more… Arguments None public subroutine p4_12 () Modify program ball from Example 4-7 to read in the initial velocity with which the ball\n is thrown. After modifying the program, run it with initial velocities of 10, 20, and 20 \n m/sec. What effect does changin the initial velocity have on the range of the ball? What\n effect does it have on the best angle theta at which to throw the ball? Arguments None public subroutine p4_13 () Arguments None public subroutine p4_14 () Write a Fortran program to evaluate the function \n y(x) = ln(1/1-x)\n for any user-specified value of x, where ln is the natural logarithm.\n Write the program with a while loop, so that the program repeats the calculation \n for each legal value of x entered into the program. When an illegal value of x is entered,\n terminate the program. Arguments None public subroutine p4_15 () Write a Fortran program to convert all uppercase characters in a user-supplied character\n string to lowercase, without changing the uppercase and nonalphabetic characters in the string.\n Assume that your computer uses the ASCII collating sequence. Arguments None public subroutine p4_16 () Calculating Orbits. Read more… Arguments None public subroutine p4_17 () Write a program caps that reads in a character string, searches for all of the words \n within the string, and capitalizes the first letter of each word, while shifting the \n remainder of the word to lowercase. Assume that all nonalphabetic and nonumeric characters\n can mark the boundaries of a word within the character variable (periods, commas,etc.). \n Nonalphabetic characters should be left unchanged. Arguments None public subroutine p4_18 () Write a computer program to calculate the current flowing through this diode\n for all voltages from -1.0V to +0.6 V, in 0.1 V steps. Repeat this process for the \n following temperatures: 75F, 100F, and 125F Arguments None public subroutine p4_19 () Write a program that promps a user for a binary number, which will be entered as a string\n of 0s and 1s in a character variable. This program should be able to handle numbers whos\n binary representation is up to 10 bits, corresponding to values from 0 to 1023. Arguments None public subroutine to_lower (char) Convert a single character to lowercase Arguments Type Intent Optional Attributes Name character(len=1), intent(inout) :: char public subroutine to_upper (char) Convert a single character to uppercase Arguments Type Intent Optional Attributes Name character(len=1), intent(inout) :: char","tags":"","loc":"module/chapter_4.html"},{"title":"chapter_7 – Fortran Program","text":"All of the programming exercises for Chapter 7: Procedures Uses iso_fortran_env Contents Subroutines p7_1 p7_2 p7_3 p7_4 p7_5 Subroutines public subroutine p7_1 () DISCUSSION QUESTION \\\n What is the difference between a subroutine and a function? Arguments None public subroutine p7_2 () DISCUSSION QUESTION \\\n When a subroutine is called, how is data passed from the calling program to the subroutine,\n and how are the results of the subroutine returned to the calling program? Arguments None public subroutine p7_3 () DISCUSSION QUESTION \\\n What are the advantages and disadvantages of the pass-by-reference scheme used in Fortran? Arguments None public subroutine p7_4 () DISCUSSION QUESTION \\\n What are the advantages and disadvantages of each procedure array type? Arguments None public subroutine p7_5 () DISCUSSION QUESTION I put a br here..\n Suppose a 15-element array is passed to a subroutine. What happens if the subroutine attempts\n to write to element a(16)? Arguments None","tags":"","loc":"module/chapter_7.html"},{"title":"chapter_6 – Fortran Program","text":"Arrays Uses iso_fortran_env Contents Subroutines p6_1 p6_3 p6_4 p6_5 p6_6 p6_7 p6_8 p6_10 p6_11 Subroutines public subroutine p6_1 () DISCUSSION QUESTION How may arrays be declared? Arguments None public subroutine p6_3 () DISCUSSION QUESTION Execute this subroutine on your computer with both bounds checking turned on and \n bounds checking turned off. What happens? Arguments None public subroutine p6_4 () DISCUSSION QUESTION Determine the shape and size of the arrays specified by the following statements: Arguments None public subroutine p6_5 () DISCUSSION QUESTION Determine which of the following Fortran program fragments are valid. For each valid statement,\n specify what will happen in the program. (Assume default typing for any variables that are not \n explicitly typed within the program fragments.) Arguments None public subroutine p6_6 () DISCUSSION QUESTION What is meant by each of the following array terms? Size, shape, extent, rank, conformable. Arguments None public subroutine p6_7 () DISCUSSION QUESTION Given an array my_array defined as shown, determine whether each of the following\n array sections is valid Arguments None public subroutine p6_8 () DISCUSSION QUESTION What will the output from each of the WRITE statements in the following subroutine be?\n Why is the output of the two statements different? Arguments None public subroutine p6_10 () Polar to Rectangular Conversion Read more… Arguments None public subroutine p6_11 () Rectangular to Polar Conversion Read more… Arguments None","tags":"","loc":"module/chapter_6.html"},{"title":"chapter_5 – Fortran Program","text":"All of the programming exercises for Chapter 5: Basic IO Uses iso_fortran_env Contents Subroutines p5_1 p5_2 p5_3 p5_4 p5_5 p5_6 Subroutines public subroutine p5_1 () DISCUSSION QUESTION What is the purpose of a format? What are the three ways to define a format? Arguments None public subroutine p5_2 () DISCUSSION QUESTION What is printed out by the following Fortran statements? Arguments None public subroutine p5_3 () DISCUSSION QUESTION What is printed out by the following Fortran statements? Arguments None public subroutine p5_4 (file_name) DISCUSSION QUESTION Read in 5_4.dat and find out what the output will be for the following statements: Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name public subroutine p5_5 (file_name) DISCUSSION QUESTION Read in 5_5.dat and find out what the value of each variable will be when the \n READ statements have been completed Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name public subroutine p5_6 () Generate a table of the base 10 logarithms between 1 and 10 in steps of 0.1 Arguments None","tags":"","loc":"module/chapter_5.html"},{"title":"coordinates – Fortran Program","text":"Used by Descendants: compass Contents Interfaces compass_to_cart Interfaces public interface compass_to_cart public subroutine compass_to_cart() Arguments None","tags":"","loc":"module/coordinates.html"},{"title":"trig – Fortran Program","text":"Used by Descendants: trig_degrees Contents Variables PI_D PI SGL DBL Interfaces deg_to_rad rad_to_deg sind cosd tand asind acosd atand Functions deg_to_rad_sgl deg_to_rad_dbl deg_to_rad_int rad_to_deg_sgl rad_to_deg_dbl rad_to_deg_int Variables Type Visibility Attributes Name Initial real(kind=8), public, parameter :: PI_D = 3.141592653589793 real, public, parameter :: PI = 3.14159265 integer, public, parameter :: SGL = selected_int_kind(7) integer, public, parameter :: DBL = selected_int_kind(15) Interfaces public interface deg_to_rad public elemental function deg_to_rad_sgl (degrees) result(rad) Arguments Type Intent Optional Attributes Name real(kind=SGL), intent(in) :: degrees Return Value real(kind=SGL) public elemental function deg_to_rad_dbl (degrees) result(rad) Arguments Type Intent Optional Attributes Name real(kind=DBL), intent(in) :: degrees Return Value real(kind=DBL) public elemental function deg_to_rad_int (degrees) result(rad) Arguments Type Intent Optional Attributes Name integer, intent(in) :: degrees Return Value real(kind=SGL) public interface rad_to_deg public elemental function rad_to_deg_sgl (rad) result(degrees) Arguments Type Intent Optional Attributes Name real(kind=SGL), intent(in) :: rad Return Value real(kind=SGL) public elemental function rad_to_deg_dbl (rad) result(degrees) Arguments Type Intent Optional Attributes Name real(kind=DBL), intent(in) :: rad Return Value real(kind=DBL) public elemental function rad_to_deg_int (rad) result(degrees) Arguments Type Intent Optional Attributes Name integer, intent(in) :: rad Return Value real(kind=SGL) interface public elemental module function sind(theta) Arguments Type Intent Optional Attributes Name real, intent(in) :: theta Return Value real interface public elemental module function cosd(theta) Arguments Type Intent Optional Attributes Name real, intent(in) :: theta Return Value real interface public elemental module function tand(theta) Arguments Type Intent Optional Attributes Name real, intent(in) :: theta Return Value real interface public elemental module function asind(theta) Arguments Type Intent Optional Attributes Name real, intent(in) :: theta Return Value real interface public elemental module function acosd(theta) Arguments Type Intent Optional Attributes Name real, intent(in) :: theta Return Value real interface public elemental module function atand(theta) Arguments Type Intent Optional Attributes Name real, intent(in) :: theta Return Value real Functions public elemental function deg_to_rad_sgl (degrees) result(rad) Arguments Type Intent Optional Attributes Name real(kind=SGL), intent(in) :: degrees Return Value real(kind=SGL) public elemental function deg_to_rad_dbl (degrees) result(rad) Arguments Type Intent Optional Attributes Name real(kind=DBL), intent(in) :: degrees Return Value real(kind=DBL) public elemental function deg_to_rad_int (degrees) result(rad) Arguments Type Intent Optional Attributes Name integer, intent(in) :: degrees Return Value real(kind=SGL) public elemental function rad_to_deg_sgl (rad) result(degrees) Arguments Type Intent Optional Attributes Name real(kind=SGL), intent(in) :: rad Return Value real(kind=SGL) public elemental function rad_to_deg_dbl (rad) result(degrees) Arguments Type Intent Optional Attributes Name real(kind=DBL), intent(in) :: rad Return Value real(kind=DBL) public elemental function rad_to_deg_int (rad) result(degrees) Arguments Type Intent Optional Attributes Name integer, intent(in) :: rad Return Value real(kind=SGL)","tags":"","loc":"module/trig.html"},{"title":"radar – Fortran Program","text":"Uses trig Contents Variables ALPHA BETA Interfaces detection operator(*) Derived Types vector detection Functions new_detection to_cart compass_to_theta time_diff pos_diff compute_velocity vector_addition vector_substraction scalar_times_vector vector_times_scalar vector_divided_scalar predict_position update_velocity update_position Variables Type Visibility Attributes Name Initial real, public, parameter :: ALPHA = 0.7 real, public, parameter :: BETA = 0.38 Interfaces public interface detection public function new_detection (range, azimuth, time) Arguments Type Intent Optional Attributes Name real, intent(in) :: range real, intent(in) :: azimuth real, intent(in) :: time Return Value type( detection ) public interface operator(*) public elemental function scalar_times_vector (scalar, vec) result(v2) Arguments Type Intent Optional Attributes Name real, intent(in) :: scalar class( vector ), intent(in) :: vec Return Value type( vector ) Derived Types type, public :: vector Components Type Visibility Attributes Name Initial real, public :: x real, public :: y Type-Bound Procedures generic, public :: operator(+) => vector_addition generic, public :: operator(-) => vector_substraction generic, public :: operator(*) => vector_times_scalar generic, public :: operator(/) => vector_divided_scalar procedure, public :: vector_addition procedure, public :: vector_substraction procedure, public :: vector_times_scalar procedure, public :: vector_divided_scalar type, public :: detection Components Type Visibility Attributes Name Initial real, public :: range real, public :: azimuth real, public :: time type( vector ), public :: cart = vector(0.0, 0.0) Constructor public  function new_detection (range, azimuth, time) Type-Bound Procedures procedure, public :: to_cart procedure, public :: time_diff procedure, public :: pos_diff procedure, public :: compute_velocity Functions public function new_detection (range, azimuth, time) Arguments Type Intent Optional Attributes Name real, intent(in) :: range real, intent(in) :: azimuth real, intent(in) :: time Return Value type( detection ) public elemental function to_cart (detect) result(cart) Arguments Type Intent Optional Attributes Name class( detection ), intent(in) :: detect Return Value type( vector ) public elemental function compass_to_theta (azimuth) result(theta) Arguments Type Intent Optional Attributes Name real, intent(in) :: azimuth Return Value real public elemental function time_diff (det1, det2) Arguments Type Intent Optional Attributes Name class( detection ), intent(in) :: det1 class( detection ), intent(in) :: det2 Return Value real public elemental function pos_diff (det1, det2) Arguments Type Intent Optional Attributes Name class( detection ), intent(in) :: det1 class( detection ), intent(in) :: det2 Return Value type( vector ) public elemental function compute_velocity (det_t0, det_tf) Arguments Type Intent Optional Attributes Name class( detection ), intent(in) :: det_t0 class( detection ), intent(in) :: det_tf Return Value type( vector ) public elemental function vector_addition (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: v1 class( vector ), intent(in) :: v2 Return Value type( vector ) public elemental function vector_substraction (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: v1 class( vector ), intent(in) :: v2 Return Value type( vector ) public elemental function scalar_times_vector (scalar, vec) result(v2) Arguments Type Intent Optional Attributes Name real, intent(in) :: scalar class( vector ), intent(in) :: vec Return Value type( vector ) public elemental function vector_times_scalar (vec, scalar) result(v2) Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: vec real, intent(in) :: scalar Return Value type( vector ) public elemental function vector_divided_scalar (vec, scalar) result(v2) Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: vec real, intent(in) :: scalar Return Value type( vector ) public elemental function predict_position (smooth_pos, prev_velocity, delta_time) Arguments Type Intent Optional Attributes Name type( vector ), intent(in) :: smooth_pos type( vector ), intent(in) :: prev_velocity real, intent(in) :: delta_time Return Value type( vector ) public elemental function update_velocity (prev_velocity, measured_pos, predicted_position, delta_time) Arguments Type Intent Optional Attributes Name type( vector ), intent(in) :: prev_velocity type( vector ), intent(in) :: measured_pos type( vector ), intent(in) :: predicted_position real, intent(in) :: delta_time Return Value type( vector ) public elemental function update_position (predicted_position, measured_position) Arguments Type Intent Optional Attributes Name type( vector ), intent(in) :: predicted_position type( vector ), intent(in) :: measured_position Return Value type( vector )","tags":"","loc":"module/radar.html"},{"title":"points_t – Fortran Program","text":"Used by Descendants: cart polar Contents Interfaces pol_to_cart cart_to_pol Derived Types point polar cart Interfaces interface public module function pol_to_cart(p1) result(c1) Arguments Type Intent Optional Attributes Name class( polar ), intent(in) :: p1 Return Value type( cart ) interface public module function cart_to_pol(c1) result(p1) Arguments Type Intent Optional Attributes Name class( cart ), intent(in) :: c1 Return Value type( polar ) Derived Types type, public, abstract :: point Components Type Visibility Attributes Name Initial integer, public :: kind = 8 type, public, extends( point ) :: polar Components Type Visibility Attributes Name Initial integer, public :: kind = 8 real, public :: r real, public :: th Type-Bound Procedures procedure, public :: to_cart => pol_to_cart type, public, extends( point ) :: cart Components Type Visibility Attributes Name Initial integer, public :: kind = 8 real, public :: x real, public :: y Type-Bound Procedures procedure, public :: to_pol => cart_to_pol","tags":"","loc":"module/points_t.html"},{"title":"polar – Fortran Program","text":"Uses Ancestors: points_t Contents None","tags":"","loc":"module/polar.html"},{"title":"cart – Fortran Program","text":"Uses Ancestors: points_t Contents None","tags":"","loc":"module/cart.html"},{"title":"trig_degrees – Fortran Program","text":"Uses Ancestors: trig Contents None","tags":"","loc":"module/trig_degrees.html"},{"title":"compass – Fortran Program","text":"Uses trig Ancestors: coordinates Contents None","tags":"","loc":"module/compass.html"},{"title":"flight_of_ball – Fortran Program","text":"Contents Variables vx vy v0 tf max_distance theta max_theta distance_traveled FMT PI Variables Type Attributes Name Initial real :: vx real :: vy real :: v0 = 20 real :: tf real :: max_distance = 0 integer :: theta = 0 integer :: max_theta real, dimension(0:90) :: distance_traveled character(len=50) :: FMT real, parameter :: PI = 3.1415927","tags":"","loc":"program/flight_of_ball.html"},{"title":"error_test – Fortran Program","text":"Contents Variables unknown_array Variables Type Attributes Name Initial integer, allocatable, dimension(:) :: unknown_array","tags":"","loc":"program/error_test.html"},{"title":"demo – Fortran Program","text":"Uses chapter_4 chapter_5 chapter_6 Contents Variables i j ierr errmsg Subroutines chapter_select chapter_selected problem_select program_start program_end to_continue Variables Type Attributes Name Initial integer :: i = 0 integer :: j = 0 integer :: ierr character(len=100) :: errmsg Subroutines subroutine chapter_select () Arguments None subroutine chapter_selected (chp) Arguments Type Intent Optional Attributes Name integer, intent(in) :: chp subroutine problem_select () Arguments None subroutine program_start () Arguments None subroutine program_end () Arguments None subroutine to_continue () Arguments None","tags":"","loc":"program/demo.html"},{"title":"radar_test – Fortran Program","text":"Uses radar Contents Variables det1 det2 my_velocity Variables Type Attributes Name Initial type( detection ) :: det1 type( detection ) :: det2 type( vector ) :: my_velocity","tags":"","loc":"program/radar_test.html"},{"title":"test_drive – Fortran Program","text":"Uses points_t Contents Variables my_p my_c Variables Type Attributes Name Initial type( polar ) :: my_p type( cart ) :: my_c","tags":"","loc":"program/test_drive.html"}]}