var tipuesearch = {"pages":[{"title":" Fortran Program ","text":"Fortran Program Foreng Formath is a set of Fortran modules that were developped while completing the exercises to Chapman's \"Fortran for Scientists and Engineers\" Note This Library is a work in process Developer Info Evan Voyles Learning Fortran by writing Fortran","tags":"home","loc":"index.html"},{"title":"chapter_4.f90 – Fortran Program","text":"Contents Modules chapter_4 Source Code chapter_4.f90 Source Code module chapter_4 !! All of the programming exercises for Chapter 4: Loops and Character Manipulation use iso_fortran_env implicit none contains ! //TODO CLEAN UP OUTPUT OF ALL PROGRAMS subroutine p4_1 () !! Test if the following equalities are valid statements, and if they are, !! evaluate them logical :: a , b character ( 5 ) :: c , d a = '123' > 'abc' ! b = '9478' == 9478 c = ACHAR ( 65 ) // ACHAR ( 95 ) // ACHAR ( 72 ) d = ACHAR ( IACHAR ( 'j' ) + 5 ) print * , \"a: \" , a , \"b: \" , b , \"c: \" , c , \"d: \" , d end subroutine subroutine p4_3 () !! Write a Fortran program to evaluate the equation y(x) = x&#94;2 - 3x + 2 for all values between -1 and 3, !! in steps of 0.1. ! // TODO add latex support ! Puprose: to solve exercise 4.3 ! Data dictionary :: declared variables integer , parameter :: start_index = - 1 , end_index = 3 real , parameter :: step_size = 0.1 integer , parameter :: array_size = int (( end_index - start_index ) / step_size ) integer :: i real , dimension ( array_size ) :: output = [( 0.1 * i + - 1 , i = 0 ,( array_size - 1 ))] integer :: x do x = 1 , array_size output ( x ) = x ** 2 - 3 * x + 2 end do write ( * , 100 ) output 100 format ( ES9 . 2 ) end subroutine subroutine p4_4 () !! Write the Fortran statements required to calculate y(t) from the equation: !! !!   y(t) = ------ -3t&#94;2 + 5    t >= 0 !!           \\---   3t&#94;2 + 5    t < 0 !! ! //TODO print function to stdin real :: y , t print * , \"Please enter a t value that you would like to compute\" read * , t if ( t >= 0 ) then y = - 3 * ( t ** 2 ) + 5 else y = 3 * ( t ** 2 ) + 5 end if print 100 , \"y(t) with t = \" , t , \" is equal to \" , y 100 format ( A , ES9 . 2 , A , ES9 . 2 ) end subroutine subroutine p4_5 () !! Write a Fortran program to calculate the factorial function. Be sure to handle the special !! cases of 0! and of illegal input values. ! integer, parameter :: MY_INT_64 = selected_int_kind(38) integer ( int64 ) :: input , factorial , i = 1 , ierr ! logical :: value_accepted = .false. print * , \"Please enter an integer to find it's factorial, max value 33!\" read ( * , '(i10)' , iostat = ierr ) input do if ( ierr == 0 ) then exit end if print * , \"Value not accepted, please enter an integer\" read ( * , '(i2)' , iostat = ierr ) input end do if ( input == 0 ) then factorial = 1 end if do i = 1 , input if ( i == 1 ) then factorial = 1 else factorial = factorial * i end if if ( factorial < 0 ) then error stop \"Overflow error, input value too large\" end if end do print 99 , input , factorial 99 format ( I0 , \" factorial is: \" , I0 ) end subroutine subroutine p4_6 () !! What is the difference in behavior between a cycle statement and an exit statement? print * , \"A cycle statement sends the program control to the start of the loop, whereas the exit statement\" print * , \"exits the loop entirely\" end subroutine subroutine p4_7 () !! Modify program stats_2 to use the DO WHILE construct instaed of the while construct currently in the program !! !!     A modified statistical analysis program that avoids the divide-by-zero problems inherent in !! program stats_1. !! !! Purpose: !! !! To calculate mean and the standard deviation of an input !! !!  data set containing an arbitrary number of input values. !! !! Record of revisions: !! !!  Date      Programmer     Description of change !!  ====      ==========     ===================== !! 11/10/15  S. J. Chapman   Original code !! 11/12/15  S. J. Chapman   Correct divide-by-0 error if !!                           0 or 1 input values given. !! 02/16/21  E. J. Voyles    Add do-while construct !! IMPLICIT NONE ! Data dictionary: declare variable types, definitions, & units INTEGER :: n = 0 ! The number of input samples. REAL :: std_dev = 0. ! The standard deviation of the input samples. REAL :: sum_x = 0. ! The sum of the input values. REAL :: sum_x2 = 0. ! The sum of the squares of the input values. REAL :: x = 0. ! An input data value. REAL :: x_bar ! The average of the input samples. ! While Loop to read input values. DO ! Read in next value WRITE ( * , * ) 'Enter number: ' READ ( * , * ) x WRITE ( * , * ) 'The number is ' , x ! Test for loop exit IF ( x < 0 ) EXIT ! Otherwise, accumulate sums. n = n + 1 sum_x = sum_x + x sum_x2 = sum_x2 + x ** 2 END DO ! Check to see if we have enough input data. IF ( n < 2 ) THEN ! Insufficient information WRITE ( * , * ) 'At least 2 values must be entered!' ELSE ! There is enough information, so ! calculate the mean and standard deviation x_bar = sum_x / real ( n ) std_dev = sqrt ( ( real ( n ) * sum_x2 - sum_x ** 2 ) / ( real ( n ) * real ( n - 1 ))) ! Tell user. WRITE ( * , * ) 'The mean of this data set is:' , x_bar WRITE ( * , * ) 'The standard deviation is: ' , std_dev WRITE ( * , * ) 'The number of data points is:' , n END IF end subroutine subroutine p4_8 () !! Examine the following DO statements and determine how many times each loop will !! be exectued. implicit NONE integer :: irange , j , kount , i !, index integer :: count = 0 a : do irange = - 32768 , 32767 count = count + 1 end do a print * , \"(a) = \" , count count = 0 b : do j = 100 , 1 , - 10 count = count + 1 end do b print * , \"(b) = \" , count count = 0 c : do kount = 2 , 3 , 4 count = count + 1 end do c print * , \"(c) = \" , count count = 0 ! d: do index = -4,-7 !     count = count + 1 ! end do d print * , \"(d) = \" , count count = 0 e : do i = - 10 , 10 , 10 count = count + 1 end do e print * , \"(e) = \" , count count = 0 ! f: do i = 10, -2, 0 !     count = count + 1 ! end do f !!!!! This for loop shows an error, since the increment is 0 !!!!!!!!!! ! print *, \"(f) = \", count ! count = 0 end subroutine subroutine p4_9 () !! Examine the following loops, determine the value of ires and the number of times !! each loop executes integer :: ires ! (b) ! ires = 0 ! loop1: DO index1 = 1, 20, 5 !     IF ( index1 <= 10 ) CYCLE !     loop2: DO index2 = index1, 20, 5 !         ires = ires + index2 !     END DO loop2 ! END DO loop1 ! (c) ! ires = 0 ! loop1: do index1 = 10, 4, -2 !     loop2: do index2 = 2, index1, 2 !         if (index2 > 6) exit loop2 !         ires = ires + index2 !     end do loop2 ! end do loop1 ! (d) ! ires = 0 ! loop1: do index1 = 10, 4, -2 !     loop2: do index2 = 2, index1, 2 !         if (index2 > 6) exit loop1 !         ires = ires + index2 !     end do loop2 ! end do loop1 !! answers !! (b) ires = 43 !! (c) ires = 42 !! (d) loop2 is run 3 times, loop1 exits during it's first iteration, ires = 12 print * , \"Ires = \" , ires end subroutine subroutine p4_10 () !! Examine the followin while loops and determine the value of ires at the end of each of !! the loops. integer :: ires , count ! (a) !  ires = 0 ! loop1: DO !     ires = ires + 1 !     IF ( (ires / 10 ) * 10 == ires ) EXIT ! END DO loop1 ! (b) ! count = 0 ! ires = 2 ! loop2: DO !     ires = ires**2 !     count = count + 1 !     IF ( ires > 200 ) EXIT ! END DO loop2 ! ! (c) ! count = 0 ! ires = 2 ! DO WHILE ( ires > 200 ) ! ires = ires**2 ! count = count + 1 ! END DO print * , \"ires = \" , ires , \" count = \" , count end subroutine subroutine p4_11 () !! Modify program ball from example 4-7 to read in the acceleration due to gravity !! at a particular location, and to calculate the maximum range of the ball for that acceleration. !! After modifying the program, run it with accelerations of -9.8, -9.7, and -9.6m/s2. !! !! What effect does the reduction in gravitational attraction have on the range ofthe ball? !! What effect does the reduction in gravitational attraction have on the best angle theta at which to throw the ball? ! Purpose: ! !       To test how the flight of a ball changes in different gravitational fields ! ! ! Data Dictionary: Declare constants and variables implicit none real :: g ! The gravitational constant, g. This value will be read in at the start of every execution real :: vx ! The horizontal velocity of the ball real :: vy ! The vertical velocity of the ball real :: v0 = 20 ! The initial velocity of the ball real :: tf ! Time when the ball lands real :: max_distance = 0 ! Maximum distance traveled integer :: theta = 0 ! Angle at which the ball is thrown integer :: max_theta ! The theta for which the ball travels the most distance real , dimension ( 0 : 90 ) :: distance_traveled ! The distance traveled for each theta value character ( 50 ) :: FMT ! The format of the output table real , parameter :: PI = 3.1415927 ! Mathematical constant pi integer :: ierr ! flag for reading in the gravitational value character ( 50 ) :: errmsg ! the error message for reagding in FMT = \"(I3, A, F5.2, A, F6.2, A, F5.2)\" 100 print * , \"Please enter a real, negative value for the gravitational constant\" read ( * , * , iostat = ierr , iomsg = errmsg ) g if ( ierr /= 0 ) then print * , \"ierr = \" , ierr , \" iomsg = \" , errmsg goto 100 end if print * , \"Theta | time in air(s) | distance traveled(m) | vy\" print * , \"--------------------------------------------------\" do theta = 0 , 90 , 1 vx = v0 * cos (( theta / 18 0. ) * PI ) vy = v0 * sin (( theta / 18 0. ) * PI ) ! Find tf tf = vy / ( - g / 2 ) distance_traveled ( theta ) = tf * vx if ( distance_traveled ( theta ) > max_distance ) then max_distance = distance_traveled ( theta ) max_theta = theta end if print ( FMT ), theta , \" | \" , tf , \" | \" , distance_traveled ( theta ), \" | \" , vy end do print * , \"Max distance traveled: \" , max_distance , \"With theta: \" , max_theta end subroutine subroutine p4_12 () !! Modify program ball from Example 4-7 to read in the initial velocity with which the ball !! is thrown. After modifying the program, run it with initial velocities of 10, 20, and 20 !! m/sec. What effect does changin the initial velocity have on the range of the ball? What !! effect does it have on the best angle theta at which to throw the ball? ! Purpose: ! !       To test how the flight of a ball changes with different initial velocites ! ! ! Data Dictionary: Declare constants and variables implicit none real :: g = - 9.8 ! The gravitational constant, g. real :: vx ! The horizontal velocity of the ball, m/sec real :: vy ! The vertical velocity of the ball real :: v0 ! The initial velocity of the ball, this will be read in upon execution real :: tf ! Time when the ball lands real :: max_distance = 0 ! Maximum distance traveled integer :: theta = 0 ! Angle at which the ball is thrown integer :: max_theta ! The theta for which the ball travels the most distance real , dimension ( 0 : 90 ) :: distance_traveled ! The distance traveled for each theta value character ( 50 ) :: FMT ! The format of the output table real , parameter :: PI = 3.1415927 ! Mathematical constant pi integer :: ierr ! flag for reading in the gravitational value character ( 50 ) :: errmsg ! the error message for reagding in FMT = \"(I3, A, F5.2, A, F6.2, A, F5.2)\" 100 print * , \"Please enter a real value for the initial velocity\" read ( * , * , iostat = ierr , iomsg = errmsg ) v0 if ( ierr /= 0 ) then print * , \"ierr = \" , ierr , \" iomsg = \" , errmsg goto 100 end if print * , \"Theta | time in air(s) | distance traveled(m) | vy\" print * , \"--------------------------------------------------\" do theta = 0 , 90 , 1 vx = v0 * cos (( theta / 18 0. ) * PI ) vy = v0 * sin (( theta / 18 0. ) * PI ) ! Find tf tf = vy / ( - g / 2 ) distance_traveled ( theta ) = tf * vx if ( distance_traveled ( theta ) > max_distance ) then max_distance = distance_traveled ( theta ) max_theta = theta end if print ( FMT ), theta , \" | \" , tf , \" | \" , distance_traveled ( theta ), \" | \" , vy end do print * , \"Max distance traveled: \" , max_distance , \"With theta: \" , max_theta end subroutine subroutine p4_13 () print * , \"Work in progress\" end subroutine subroutine p4_14 () !! Write a Fortran program to evaluate the function !! y(x) = ln(1/1-x) !! for any user-specified value of x, where ln is the natural logarithm. !! Write the program with a while loop, so that the program repeats the calculation !! for each legal value of x entered into the program. When an illegal value of x is entered, !! terminate the program. !   Purpose: !       This program calculates the value of ln(1/(1-x)) for all valid !       values of x entered by the user ! ! IMPLICIT NONE ! Data dictionary: declare variable types, definitions, & units. real :: x ! The x value to be evaluated integer :: ierr = 0 ! The error status when reading in the value character ( 100 ) :: errmsg ! The error message generated when reading in a value do while ( ierr == 0 ) print * , \"Please enter a real number greater than 1\" read ( * , * , iostat = ierr , iomsg = errmsg ) x if ( x <= 1 . or . ierr /= 0 ) exit print 100 , x , log (( 1 ) / ( x - 1 )) end do 100 Format ( \"f(\" , f10 . 2 , \") = \" , f7 . 3 ) end subroutine subroutine p4_15 () !! Write a Fortran program to convert all uppercase characters in a user-supplied character !! string to lowercase, without changing the uppercase and nonalphabetic characters in the string. !! Assume that your computer uses the ASCII collating sequence. !   Purpose: !       This program converts all uppercase letters to lowercase letters IMPLICIT NONE ! Data Dictionary: declare variable types, definitions, and units integer , parameter :: MAX_LENGTH = 30 character ( len = MAX_LENGTH ) :: start_string character ( MAX_LENGTH ) :: end_string integer :: i integer :: this_char_index character :: this_char print * , \"Please enter a string you would like to convert to lowercase\" read '(30A)' , start_string do i = 1 , MAX_LENGTH this_char = start_string ( i : i ) this_char_index = iachar ( this_char ) if ( this_char_index >= 65 . and . this_char_index <= 90 ) then end_string ( i : i ) = achar ( this_char_index + 32 ) else end_string ( i : i ) = this_char end if end do print * , \"Converted string: \" , start_string , \" to string: \" , end_string end subroutine subroutine p4_16 () !! Calculating Orbits. !! !! When a satellinte orbits the Eath, the satellite's orbit will form an ellipse with the !! Earth located at one of the focal points of the ellipse. The satellite's orbit can be !! expressed in polar coordintaes as !! !! r = p/(1 - \\epsilon * cos( \\theta )) !! !! Where r and theta are the distance and angle of the satellite from the center of the earth, !! p is a parameter specifying the size of the orbit, and \\epsilon is a parameter representing the !! eccentricity of the orbit. A circular orbit has an eccentricity of zero. An elliptical orbit has !! an eccentricity of 0 <= e <= 1. If \\epsilon > 1, the satellite follows a hyperbolic path and escapes !! from Earth's gravitational field. !! !! Consider a satellite with a size parameter p = 1200 km. Write a program to calculate the !! distance of the satellite from the center of the Earth as a function of theta if the satellite has !! an eccentricity of (a) e = 0; (b) e = 0.25; (c) e = 0.5. Write a single program in which !! r and e are both input values. !! !! How close does each orbit come to the earth? How far away does each orbit get from the earth? !   Purpose: !      To calculate the position of a satellite orbiting the Earth. ! Data dictionary: declare variable types, definitions, and units integer , parameter :: P = 1200 ! Size of the orbit, in km. integer , parameter :: NTHETA = 200 real , parameter :: PI = 3.1415927 real , parameter :: THETA_STEP = ( 2 * PI ) / NTHETA real :: eccentricity ! Eccentricity of the orbit, 0 <= e <= 1 real :: theta ! Polar coordinate for the satellite. real :: r ! Distance from the center of the earth. real :: apoapsis = P ! Farthest distance from the center of the earth real :: periapsis = P ! Closest distance from the center of the earth integer :: ierr character ( 30 ) :: errmsg integer itheta print * , \"Please enter an eccentricity value, between 0 and 1.\" read ( * , * , iostat = ierr , iomsg = errmsg ) eccentricity do while ( ierr /= 0 . and . ( eccentricity > 1 . or . eccentricity < 0 )) print * , \"Input invalid, please enter a real value between 0 and 1.\" read ( * , * , iostat = ierr , iomsg = errmsg ) eccentricity end do do itheta = 1 , NTHETA theta = itheta * THETA_STEP r = p / ( 1 - ( eccentricity * cos ( theta ))) if ( r < periapsis ) periapsis = r if ( r > apoapsis ) apoapsis = r print * , theta , r end do print * , \"The periapsis is: \" , periapsis , \"km, and the apoapsis is: \" , apoapsis , \"km\" end subroutine subroutine p4_17 () !! Write a program caps that reads in a character string, searches for all of the words !! within the string, and capitalizes the first letter of each word, while shifting the !! remainder of the word to lowercase. Assume that all nonalphabetic and nonumeric characters !! can mark the boundaries of a word within the character variable (periods, commas,etc.). !! Nonalphabetic characters should be left unchanged. ! 2. Define the input and output ! input: A character string from the terminal. ! output: The same string with the only the first letter per word capitalized. ! 3. Describe the algorithm ! We should first read in the string ! Alphabetic character ranges: !   lowercase: [97, 122] !   uppercase: [65, 90] ! Numeric character ranges: !   [48, 57] ! ! We assume that all nonalphabetic and nonnumeric characters can mark the boundaries of a word. ! Purpose: !   To capitalize the first letter per word in a character string. ! Data dictionary: integer , parameter :: MAX_STR_LEN = 500 character (:), allocatable :: input_str character ( 30 ) :: FMT integer :: i integer :: num_chars character ( 1 ) :: prev_char , this_char print * , \"Please enter a the number of characters to record\" read ( * , \"(I10)\" ) num_chars allocate ( character ( num_chars ) :: input_str ) write ( FMT , '(\"(A\", I0, \")\")' ) num_chars ! print *, \"Format statement saved as: \", FMT print * , \"Now please enter the string you would like to transform\" read ( * , FMT ) input_str print * , \"String before transformation: \" , input_str if ( is_alph ( input_str ( 1 :))) then call to_upper ( input_str ( 1 :)) end if do i = 2 , MAX_STR_LEN prev_char = input_str ( i - 1 :) this_char = input_str ( i :) ! If the character is the start of the word, then capitalize it if (. not . is_alphnum ( prev_char )) then ! If the previous character is a word boundary if ( is_lower ( this_char )) then ! And this character is lowercase call to_upper ( input_str ( i :)) ! Then capitalize it end if else if ( is_upper ( this_char )) then call to_lower ( input_str ( i :)) end if end if end do print * , \"String after transformation: \" , input_str end subroutine subroutine p4_18 () !!Write a computer program to calculate the current flowing through this diode !! for all voltages from -1.0V to +0.6 V, in 0.1 V steps. Repeat this process for the !! following temperatures: 75F, 100F, and 125F ! Purpose: !   To calculate the current flowing through a semiconductor diode real ( real64 ), dimension ( 3 ) :: T_f = [ 75 , 100 , 125 ] real ( real64 ), dimension ( 3 ) :: T_k real ( real64 ), parameter :: I_O = 2.0E-6 real ( real64 ), dimension ( 17 ) :: v_D real ( real64 ), dimension ( 3 , 17 ) :: i_D integer :: i , j do i = 1 , 17 v_D ( i ) = - 1.0 + ( 0.1 * ( i - 1 )) end do ! print *, v_D T_k = to_kelvin ( T_f ) print * , \" \" print * , \"Calculating the current flowing through a semiconductor diode for three separate temperatures\" print * , \"and voltages ranging from -1.0 to 0.6 V\" print * , \" \" print 999 , v_D print 100 100 format ( 250 ( \"-\" )) do i = 1 , 3 do j = 1 , 17 i_D ( i , j ) = calc_current_flow ( v_D ( j ), I_O , T_k ( i )) end do print 99 , T_k ( i ), i_D ( i ,:) 99 format ( F9 . 3 , 2 X , \" | \" , 17 ( ES10 . 3 , 3 X )) 999 format ( \"  T(K) \\ V \" , \" | \" , 17 ( F6 . 3 , 7 X )) end do end subroutine subroutine p4_19 () !! Write a program that promps a user for a binary number, which will be entered as a string !! of 0s and 1s in a character variable. This program should be able to handle numbers whos !! binary representation is up to 10 bits, corresponding to values from 0 to 1023. ! Purpose: !   To convert binary numbers to decimal. implicit none ! Data dictionary integer , parameter :: MAX_LEN = 10 integer , parameter :: ZERO_ASCII = 48 integer , parameter :: ONE_ASCII = 49 character ( MAX_LEN ) :: binary_representation character (:), allocatable :: binary_trimmed integer :: len_trim = 0 logical :: input_is_valid = . true . integer :: i = 0 character ( 1 ) :: this_char = '' integer :: char_value = 0 real :: decimal_representation = 0 integer :: this_bit = 0 ! print *, \"decimal_representation = \", decimal_representation print * , \"Please enter a binary number that is between 1 and 10 bits\" read ( * , \"(A10)\" ) binary_representation ! print *, \"Converting binary number: \", binary_representation binary_trimmed = trim ( binary_representation ) len_trim = len ( binary_trimmed ) ! First let's validate the input do i = 1 , len_trim this_char = binary_trimmed ( i :) char_value = ichar ( this_char ) if ( char_value /= ZERO_ASCII . and . char_value /= ONE_ASCII ) then input_is_valid = . false . print * , \"invalid char = \" , this_char print * , \"invalid val = \" , char_value print * , \"invalid pos = \" , i print * , \"\" print * , \"ZERO_ASCII = \" , ZERO_ASCII print * , \"ONE_ASCII = \" , ONE_ASCII exit end if end do if ( input_is_valid ) then ! print *, \"input is valid, converting now\" do i = 1 , len_trim read ( binary_representation ( i :), \"(I1)\" ) this_bit ! print *, \"Current working bit: \", this_bit decimal_representation = ( this_bit * 2 ** ( len_trim - i )) + decimal_representation end do else print * , \"input is invalid, please try restarting the program\" end if print 99 , binary_representation , int ( decimal_representation ) 99 format ( \"binary num: \" , T15 , A10 , / , 'decimal:' , T15 , I0 ) decimal_representation = 0 end subroutine !-------------------------------------! !------- HELPER FUNCTIONS ------------! !-------------------------------------! logical function is_alphnum ( char ) !! Test whether an ASCII character is alpha-numeric character ( 1 ), intent ( in ) :: char if ( is_num ( char ) . or . is_alph ( char )) then is_alphnum = . true . else is_alphnum = . false . end if end function logical function is_alph ( char ) !! Test whether an ASCII character is a letter character ( 1 ), intent ( in ) :: char if ( is_upper ( char ) . or . is_lower ( char )) then is_alph = . true . else is_alph = . false . end if end function logical function is_num ( char ) !! Test whether an ASCII character is numeric character ( 1 ), intent ( in ) :: char integer :: char_value char_value = iachar ( char ) if ( char_value >= 48 . and . char_value <= 57 ) then is_num = . true . else is_num = . false . end if end function logical function is_lower ( char ) !! Test whether an ASCII character is a lowercase letter character ( 1 ), intent ( in ) :: char integer :: char_value !! ASCII value char_value = iachar ( char ) if ( char_value >= 97 . and . char_value <= 122 ) then is_lower = . true . else is_lower = . false . end if end function logical function is_upper ( char ) !! Test whether an ASCII character is an uppercase letter character ( 1 ), intent ( in ) :: char integer :: char_value !! ASCII value char_value = iachar ( char ) if ( char_value >= 65 . and . char_value <= 90 ) then is_upper = . true . else is_upper = . false . end if end function subroutine to_lower ( char ) !! Convert a single character to lowercase character ( 1 ), intent ( inout ) :: char if ( is_upper ( char )) char = achar (( iachar ( char ) + 32 )) end subroutine subroutine to_upper ( char ) !! Convert a single character to uppercase character ( 1 ), intent ( inout ) :: char if ( is_lower ( char )) char = achar (( iachar ( char ) - 32 )) end subroutine elemental function calc_current_flow ( v_D , I_O , T ) result ( i_D ) ! Data Dictionary ! // TODO add proper documentation real ( real64 ) :: i_D !! The current flow through the diode in amperes real ( real64 ), intent ( in ) :: v_D !! The voltage across the diode, in volts real ( real64 ), intent ( in ) :: I_O !! The leakage current of the diode, in amperes real ( real64 ), intent ( in ) :: T !! Temperature, in kelvins (K) real ( real64 ), parameter :: q = 1.602E-19 !! The charge on an electron, 1.602 X 10-19 Coulombs real ( real64 ), parameter :: k = 1.38E-23 !! Boltzmann's constant, 1.38 X 10-23 J/K i_D = I_O * ( exp (( q * v_D ) / ( k * T )) - 1 ) end function elemental real ( real64 ) function to_kelvin ( F ) !! Convert a temperature in Fahrenheit to Kelvin real ( real64 ), intent ( in ) :: F to_kelvin = to_celcius ( F ) + 273 end function elemental real ( real64 ) function to_celcius ( F ) !! Convert a temperature from Fahrenheit to celcius real ( real64 ), intent ( in ) :: F to_celcius = ( F - 32 ) * ( 5. / 9. ) end function end module","tags":"","loc":"sourcefile/chapter_4.f90.html"},{"title":"chapter_7.f90 – Fortran Program","text":"Contents Modules chapter_7 Source Code chapter_7.f90 Source Code module chapter_7 !! All of the programming exercises for Chapter 7: Procedures use iso_fortran_env implicit none contains subroutine p7_1 () !! ** DISCUSSION QUESTION ** <br> !! What is the difference between a subroutine and a function? print * , \"A subroutine can modify arguments that are passed to it, but it will never have\" print * , \"a return value. Functions in Fortran, just like their mathematical definition,\" print * , \"necessarily have a return value. A subroutine and function is similar with\" print * , \"respect to the fact that they both are a tool to repeat and reuse code.\" end subroutine subroutine p7_2 () !! ** DISCUSSION QUESTION ** <br> !! When a subroutine is called, how is data passed from the calling program to the subroutine, !! and how are the results of the subroutine returned to the calling program? print * , \"Parameters are passed around inside subroutines as references, that is to say\" print * , \"that there is not a block of memory that is copied to the subroutine, instead\" print * , \"the argument is passed with a pointer to the block of memory that stores the value.\" end subroutine subroutine p7_3 () !! ** DISCUSSION QUESTION ** <br> !! What are the advantages and disadvantages of the pass-by-reference scheme used in Fortran? print * , \"Advantages: \" print * , \" - Don't have to copy large amounts of data (which can be slow)\" print * , \"Disadvantages: \" print * , \" - Data address might be far away from the caller, leading to slow load times\" print * , \" - Modifiying the data in the subroutine can affect the original parameter\" end subroutine subroutine p7_4 () !! ** DISCUSSION QUESTION ** <br> !! What are the advantages and disadvantages of each procedure array type? print * , \"Explicit shaped dummy arrays:\" print * , \" - Compiler knows exactly the shape and size of an argument, and\" print * , \"can therefore check for out-of-bounds errors during compilation\" print * , \" - We have to pass the size of the array when calling the procedure\" print * print * , \"Assumed-shape dummy arrays:\" print * , \" - Allow the compiler to check SOME indexing errors, and avoids having\" print * , \"to pass a size parameter\" print * , \" - can be used in full-matrix statements (e.g. A + B)\" print * print * , \"Assumed-size dummy arrays:\" print * , \" - Should NEVER be used because the compiler can't check for errors.\" end subroutine subroutine p7_5 () !! ** DISCUSSION QUESTION **<br> !! Suppose a 15-element array is passed to a subroutine. What happens if the subroutine attempts !! to write to element a(16)? print * , \"If the array is explicit-shaped, then there will be an error at compile time.\" print * , \"If the array is assumed-shape, then there will be an error at run time.\" print * , \"An assumed-size error will allow the unsafe access to be performed.\" end subroutine subroutine p7_6 () !! **DISCUSSION QUESTION** <br> !! If a real value is passed to a subroutine in an argument that is declared to be an integer, !! what happens? print * , \"Sometimes the compiler will give a warning, but still allow the real to be passed\" print * , \"In this case, however, my gfortran compiler produced an error so I can't even pass\" print * , \"a real value into a subroutine expecting an integer.\" ! integer, intent(in) :: i ! write(*,*) \" I = \", i end subroutine subroutine p7_7 () !! ** DISCUSSION QUESTION** <br> !! How can p7_6 be modified so that the compiler catches the argument mismatch between !! the actual argument and the dummy argument in the subroutine? print * , \"We can ensure that an int will be passed to the subroutine by wrapping\" print * , \"the parameter with the INT(x) function upon calling\" end subroutine subroutine p7_8 () !! **DISCUSSION QUESTION** <br> !! What is the purpose of the INTENT attribute? Where can it be used? Why should it be used? print * , \"The INTENT attribute signals to the compiler whether or not the variables are\" print * , \"read, write, or read write. This attribute is specified where the variables are\" print * , \"being declared in a procedure. They should be used so that you don't\" print * , \"accidentally alter a variable that you didn't want/expect to.\" end subroutine subroutine p7_9 () !! **NOT APPLICABLE** end subroutine subroutine p7_10 () !! **NOT APPLICABLE** end subroutine end module chapter_7","tags":"","loc":"sourcefile/chapter_7.f90.html"},{"title":"chapter_6.f90 – Fortran Program","text":"Contents Modules chapter_6 Source Code chapter_6.f90 Source Code module chapter_6 !! Arrays use iso_fortran_env implicit none contains subroutine p6_1 () !! ** DISCUSSION QUESTION ** !! How may arrays be declared? integer , dimension ( 1 : 10 ) :: my_array integer , dimension ( - 10 : - 1 ) :: my_neg_array double precision , dimension ( 10 ) :: my_product my_array = 3 my_neg_array = - 2 my_product = real ( my_array ) ** real ( my_neg_array ) print * , my_product end subroutine subroutine p6_3 () !! ** DISCUSSION QUESTION ** !! Execute this subroutine on your computer with both bounds checking turned on and !! bounds checking turned off. What happens? real , dimension ( 5 ) :: test = [ 1. , 2. , 3. , 4. , 5. ] real , dimension ( 5 ) :: test1 integer :: i do i = 1 , 5 test1 ( i ) = sqrt ( test ( i )) write ( * , 100 ) 'SQRT(' , test ( i ), ') = ' , test1 ( i ) 100 format ( A , F6 . 3 , A , F14 . 4 ) end do end subroutine subroutine p6_4 () !! ** DISCUSSION QUESTION ** !! Determine the shape and size of the arrays specified by the following statements: ! (a) ! character(len=80), dimension(60) :: line ! An array that is 1 dimensionsal, has 60 entries, and each entry is a charactar of length 80. ! (b) ! integer, parameter :: ISTART = 32 ! INTEGER, PARAMETER :: ISTOP = 256 ! INTEGER, DIMENSION(ISTART:ISTOP) :: char ! char is an array of size (256-32 + 1) = 225 ! (c) ! INTEGER, PARAMETER :: NUM_CLASS = 3 ! INTEGER, PARAMETER :: NUM_STUDENT = 35 ! LOGICAL, DIMENSION(NUM_STUDENT, NUM_CLASS) :: passfail ! passfail is an array of size 33. end subroutine subroutine p6_5 () !! ** DISCUSSION QUESTION ** !! Determine which of the following Fortran program fragments are valid. For each valid statement, !! specify what will happen in the program. (Assume default typing for any variables that are not !! explicitly typed within the program fragments.) ! (a) ! INTEGER, DIMENSION(100) :: icount, jcount !. . . ! icount = [ (i, i=1, 100)] ! implied do loop ! jcount = icount + 1 ! (a) has valid syntax, this will create two arrays, icount which is a size 100 array that ! contains the sequence of natural numbers from 1 to 100, and jcount contains the sequence of ! natural numbers from 2 to 101. ! print *, icount ! print *, jcount ! (b) ! REAL, DIMENSION(10) :: value ! value(1:10:2) = [5., 4., 3., 2., 1. ] ! value(2:11:2) = [10., 9., 8., 7., 6. ] ! write (*, 100) value ! 100 format ('Value = ',/,(F10.2)) ! (c) ! INTEGER, DIMENSION(6) :: a ! INTEGER, DIMENSION(6) :: b ! a = [1, -3, 0, -5, -9, 3] ! b = [-6, 6, 0, 5, 2, -1] ! WRITE (*, *) a > b ! All the fragments are valid! print * , \"All code fragments are valid\" end subroutine subroutine p6_6 () !! ** DISCUSSION QUESTION ** !! What is meant by each of the following array terms? Size, shape, extent, rank, conformable. integer , parameter :: DEFINITION_LENGTH = 65 character ( DEFINITION_LENGTH ) :: sizeDef , shapeDef , extentDef , rankDef , conformableDef sizeDef = \"Number of elements of A\" shapeDef = \"Return the dimensions of A\" extentDef = \"The number of elements in a single dimension\" rankDef = \"The number of dimensions\" conformableDef = \"Two arrays that have the same shape and extent are conformable\" print 100 , sizeDef , shapeDef , extentDef , rankDef , conformableDef 100 Format ( \"size: \" , T30 , A , / , \"shape: \" , T30 , A , / , \"extent: \" , T30 , A , / , \"rank: \" , T30 , A , / , \"conformable: \" , T30 , A ) end subroutine subroutine p6_7 () !! ** DISCUSSION QUESTION ** !! Given an array my_array defined as shown, determine whether each of the following !! array sections is valid REAL , DIMENSION ( - 2 : 7 ) :: my_array = [ - 3 , - 2 , - 1 , 0 , 1 , 2 , 3 , 4 , 5 , 6 ] INTEGER , DIMENSION ( 5 ) :: list = [ - 2 , 1 , 2 , 4 , 2 ] ! (a) ! print *, my_array(-3, 3) ! (b) print * , my_array ( - 2 : 2 ) ! (c) print * , my_array ( 1 : 5 : 2 ) ! (d) print * , my_array ( list ) end subroutine subroutine p6_8 () !! ** DISCUSSION QUESTION ** !! What will the output from each of the WRITE statements in the following subroutine be? !! Why is the output of the two statements different? INTEGER , DIMENSION ( 0 : 7 ) :: my_data INTEGER :: i , j my_data = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 ] DO i = 0 , 1 WRITE ( * , 100 ) ( my_data ( 4 * i + j ), j = 0 , 3 ) ! Will write two lists of 4 items 100 FORMAT ( 6 ( 1 X , I4 )) END DO WRITE ( * , 100 ) (( my_data ( 4 * i + j ), j = 0 , 3 ), i = 0 , 1 ) ! Will write one line with 6 items and a second line with 2 itmes end subroutine subroutine p6_10 () !! Polar to Rectangular Conversion !! Write a program that reads the polar coordinates of a 2D vector into a rank !! 1 array POLAR. polar(1) will contain the mgnitude and polar(2) will contain the !! angle theta in degrees, and converts the vector from !! polar to rectangular form, storing the result in a rank1 array RECT. !! Rect(1) should be the x component and rect(2) will be the y component. real ( real64 ), parameter :: PI = 3.141592653589793 real ( real64 ), dimension ( 2 ) :: polar , rect real ( real64 ) :: rads integer :: ierr character ( 100 ) :: errmsg print * , \"Please enter the magnitude and angle (degrees) of a point in polar coordinates\" read ( * , * , iostat = ierr , iomsg = errmsg ) polar ( 1 ), polar ( 2 ) if ( ierr == 0 ) then ! No error occurred rads = ( polar ( 2 ) / 180 ) * ( PI ) print * , polar ( 2 ), \" in rads is: \" , rads rect ( 1 ) = polar ( 1 ) * cos ( rads ) rect ( 2 ) = polar ( 1 ) * sin ( rads ) end if print * , \"The polar coordinates \" , polar , \" in rectangular form are:\" print * , rect end subroutine subroutine p6_11 () !! Rectangular to Polar Conversion !! Write a program that reads the rectangular components of a 2D vector into a rank 1 !! array rect. real ( real64 ), parameter :: PI = 3.141592653589793 real ( real64 ), dimension ( 2 ) :: polar , rect real ( real64 ) :: rads , mag integer :: ierr character ( 100 ) :: errmsg print * , \"Please enter the x and y components of a point in rectangular coordinates\" read ( * , * , iostat = ierr , iomsg = errmsg ) rect ( 1 ), rect ( 2 ) if ( ierr == 0 ) then ! No error occurred rads = atan2 ( rect ( 2 ), rect ( 1 )) polar ( 2 ) = rads * ( 180 ) / PI mag = sqrt (( rect ( 1 ) ** 2 + rect ( 2 ) ** 2 )) print * , rads , \" in degrees is \" , polar ( 2 ) polar ( 1 ) = mag end if print * , \"The rect coordinates \" , rect , \" in polar form are:\" print * , polar end subroutine end module","tags":"","loc":"sourcefile/chapter_6.f90.html"},{"title":"chapter_5.f90 – Fortran Program","text":"Contents Modules chapter_5 Source Code chapter_5.f90 Source Code module chapter_5 !! All of the programming exercises for Chapter 5: Basic IO use iso_fortran_env contains subroutine p5_1 () !! ** DISCUSSION QUESTION ** !! What is the purpose of a format? What are the three ways to define a format? print * , \"The purpose of a format is to have complete control of the output/input of a program.\" print * , \"We can, for example, style the output into a table using formats. \" print * , \"We can define a format three different ways.\" print 99 , 1 , \"Using a raw format string in the call: \" print 111 , \"write(*, '(F5.3, A)') my_float, my_character\" print 99 , 2 , \"Using a label combined with a format call:\" print 111 , \"100 FORMAT(F5.3, A) ... write(*,100) my_float, my_character\" print 99 , 3 , \"Storing the format with a variable:\" print 111 , \"FMT = '(F5.3,A)' ... write(*, FMT) my_float, my_character\" 111 format ( T15 , a ) 99 format ( I0 , \"). \" , a ) end subroutine subroutine p5_2 () !! ** DISCUSSION QUESTION ** !! What is printed out by the following Fortran statements? print * , \"(a)\" print * , \"integer :: i\" print * , \"character(len=20) :: fmt\" print * , \"fmt = '('i = ', I8.5)'\" print * , \"i = -123\" print * , \"write(*,fmt) i\" print * , \"write(*, '(I0)') i\" ! (b) ! real :: a, b, sum, difference ! a = 1.0020E6 ! b = 1.0001E6 ! sum = a + b ! difference = a - b ! write (*, 101) a, b, sum, difference ! 101 FORMAT('A = ', ES14.6, ' B = ', E14.6, & ! ' Sum = ', E14.6, ' Diff = ', F14.6) ! (c) ! integer :: i1, i2 ! i1 = 10 ! i2 = 4**2 ! write (*, 300) i1 > i2 ! 300 FORMAT ('Result = ', L6) end subroutine subroutine p5_3 () !! ** DISCUSSION QUESTION ** !! What is printed out by the following Fortran statements? real :: a = 1.602E-19 , b = 5 7.2957795 , c = - 1 print * , \"File:\" print * , \"----\" print * , \"real :: a = 1.602E-19, b = 57.2957795, c = -1\" print * , \"write (*, '(ES14.7, 2(1X, E13.7))') a, b, c\" print * print * , \"Output:\" print * , \"-------\" write ( * , '(ES14.7, 2(1X, E13.7))' ) a , b , c end subroutine subroutine p5_4 ( file_name ) !! ** DISCUSSION QUESTION ** !! Read in 5_4.dat and find out what the output will be for the following statements: character ( * ), intent ( in ) :: file_name Character ( 5 ) :: a Character ( 10 ) :: b character ( 15 ) :: c character ( 100 ) :: errmsg integer :: ierr open ( unit = 10 , file = file_name , iostat = ierr , iomsg = errmsg , status = \"old\" ) if ( ierr /= 0 ) then print * , \"ERR: \" , errmsg else READ ( unit = 10 , fmt = '(3A10)' ) a , b , c close ( unit = 10 ) print * , \"a: \" , a , \" b: \" , b , \" c: \" , c end if end subroutine subroutine p5_5 ( file_name ) !! ** DISCUSSION QUESTION ** !! Read in 5_5.dat and find out what the value of each variable will be when the !! READ statements have been completed character ( * ), intent ( in ) :: file_name integer :: item1 , item2 , item3 , item4 , item5 integer :: item6 , item7 , item8 , item9 , item10 integer :: ierr character ( 100 ) :: errmsg open ( unit = 10 , file = file_name , status = 'old' , action = 'read' , iostat = ierr , iomsg = errmsg ) if ( ierr /= 0 ) then print * , \"ERR: \" , errmsg else ! (a) read ( 10 , * ) item1 , item2 , item3 , item4 , item5 , item6 read ( 10 , * ) item7 , item8 , item9 , item10 ! (b) ! read (10, 8) item1, item2, item3, item4, item5, item6 ! read (10, 8) item7, item8, item9, item10 ! 8 FORMAT(4I10) print * , item1 , item2 , item3 , item4 , item5 , item6 , item7 , item8 , item9 , item10 close ( unit = 10 ) end if end subroutine subroutine p5_6 () !! Generate a table of the base 10 logarithms between 1 and 10 in steps of 0.1 integer :: ipower , jpower , i real , dimension ( 10 , 0 : 9 ) :: result ones_place : do ipower = 1 , 10 tenths_place : do jpower = 0 , 9 result ( ipower , jpower ) = log10 ( ipower + 0.1 * jpower ) end do tenths_place end do ones_place write ( * , 200 ) ( i , i = 0 , 9 ) write ( * , 300 ) write ( * , 100 ) ( i , result ( i ,:), i = 1 , 10 ) 100 format ( I3 , \".0  | \" , 10 F7 . 4 ) 200 format ( 7 ( \" \" ), \"|\" , 10 ( 4 X , \"X.\" , I0 )) 300 format ( 80 ( \"-\" )) end subroutine end module chapter_5","tags":"","loc":"sourcefile/chapter_5.f90.html"},{"title":"foreng.f90 – Fortran Program","text":"Contents Modules foreng Source Code foreng.f90 Source Code module foreng use foreng_math use foreng_numeric use foreng_io use foreng_science implicit none end module","tags":"","loc":"sourcefile/foreng.f90.html"},{"title":"foreng_env.f90 – Fortran Program","text":"Contents Modules foreng_env Source Code foreng_env.f90 Source Code module foreng_env !! Top level module for all of the useful functions written for Fortran for Scientists and Engineers use iso_fortran_env , only : real64 , real32 , int64 , int32 , int16 , real128 implicit none ! public :: sgl, dbl, short, long, pi, pi_s public int128 !     integer, parameter :: SGL = real32 !     integer, parameter :: DBL = real64 !     integer, parameter :: SHORT = int16 !     integer, parameter :: LONG = int64 real ( real64 ), parameter :: PI_64 = 3.141592653589793 real ( real64 ), parameter :: PI = PI_64 real ( real32 ), parameter :: PI_32 = 3.14159265 integer , parameter :: int128 = selected_int_kind ( 38 ) !=============================================================================! !=                      List of incorporated modules                         =! !=============================================================================! ! Math !   _trig !   _sets end module","tags":"","loc":"sourcefile/foreng_env.f90.html"},{"title":"io_char.f90 – Fortran Program","text":"Contents Modules foreng_io_char Source Code io_char.f90 Source Code module foreng_io_char !! A module to deal with the manipulation of characters based on their ASCII collating sequence. !! !! This module provides public parameters that are common ASCII cutoff values when dealing with alphanumeric characters. implicit none integer , parameter :: ZERO_ASCII = 48 !! ASCII value of the digit '0' integer , parameter :: NINE_ASCII = 57 !! ASCII value of the digit '9' integer , parameter :: UPPER_A_ASCII = 65 !! ASCII VALUE of the character 'A' integer , parameter :: UPPER_Z_ASCII = 90 !! ASCII VALUE of the character 'Z' integer , parameter :: LOWER_A_ASCII = 97 !! ASCII VALUE of the character 'a' integer , parameter :: LOWER_Z_ASCII = 122 !! ASCII VALUE of the character 'z' integer , parameter :: UPPER_LOWER_OFFSET = 32 !! The difference between UPPER_A_ASCII and LOWER_A_ASCII contains logical elemental function is_alphnum ( char ) !! Check if a character is alphanumeric !! This function checks the ASCII collating sequence of the passed character and returns true if the character is alpha (A-Z, a-z) or numeric (0-9) character ( 1 ), intent ( in ) :: char if ( is_num ( char ) . or . is_alph ( char )) then is_alphnum = . true . else is_alphnum = . false . end if end function logical elemental function is_alph ( char ) !! Check if a character belongs to the alphabet !! This function checks the ASCII collating sequence of the passed character and returns true if the character belongs to the Roman alphabet. character ( 1 ), intent ( in ) :: char if ( is_upper ( char ) . or . is_lower ( char )) then is_alph = . true . else is_alph = . false . end if end function logical elemental function is_num ( char ) !! Check if a character is a numerical digit. !! Return true if a character is between 0-9 character ( 1 ), intent ( in ) :: char integer :: char_value char_value = iachar ( char ) if ( char_value >= ZERO_ASCII . and . char_value <= NINE_ASCII ) then is_num = . true . else is_num = . false . end if end function logical elemental function is_lower ( char ) !! Check if a character is a lowercase alpha character !! Returns true if the ASCII value of char lies between LOWER_A_ASCII and LOWER_Z_ASCII character ( 1 ), intent ( in ) :: char integer :: char_value char_value = iachar ( char ) if ( char_value >= LOWER_A_ASCII . and . char_value <= LOWER_Z_ASCII ) then is_lower = . true . else is_lower = . false . end if end function logical elemental function is_upper ( char ) !! Check if a character is a uppercase alpha character !! Returns true if the ASCII value of char lies between UPPER_A_ASCII and UPPER_Z_ASCII character ( 1 ), intent ( in ) :: char integer :: char_value char_value = iachar ( char ) if ( char_value >= UPPER_A_ASCII . and . char_value <= UPPER_Z_ASCII ) then is_upper = . true . else is_upper = . false . end if end function character ( 1 ) elemental function to_lower ( char ) result ( char_upper ) !! Convert an uppercase alpha character to its lowercase counterpart. If the passed character is not uppercase, return the same character. character ( 1 ), intent ( in ) :: char if ( is_upper ( char )) then char_upper = achar (( iachar ( char ) + UPPER_LOWER_OFFSET )) else char_upper = char end if end function character ( 1 ) elemental function to_upper ( char ) result ( char_lower ) !! Convert a lowercase alpha character to its uppercase counterpart. If the passed character is not lowercase, return the same character. character ( 1 ), intent ( in ) :: char if ( is_lower ( char )) then char_lower = achar (( iachar ( char ) - UPPER_LOWER_OFFSET )) else char_lower = char end if end function end module","tags":"","loc":"sourcefile/io_char.f90.html"},{"title":"io.f90 – Fortran Program","text":"Contents Modules foreng_io Source Code io.f90 Source Code module foreng_io !! Top-level Foreng module grouping modules that manipulate strings, characters, and input/output. use foreng_io_char end module","tags":"","loc":"sourcefile/io.f90.html"},{"title":"numeric_matrices_inverse.f90 – Fortran Program","text":"Contents Submodules foreng_numeric_matrices_inverse Source Code numeric_matrices_inverse.f90 Source Code SUBMODULE ( foreng_numeric_matrices ) foreng_numeric_matrices_inverse IMPLICIT NONE CONTAINS MODULE PROCEDURE gauss_elim_inverse_32 REAL ( real32 ), DIMENSION ( SIZE ( A , DIM = 1 ), SIZE ( A , DIM = 1 )) :: Identity INTEGER :: i , j , nrow , ncol nrow = SIZE ( A , DIM = 1 ) ncol = SIZE ( A , DIM = 2 ) IF ( nrow /= ncol ) THEN ERROR STOP \"A is not a square matrix\" END IF Identity = 0 FORALL ( i = 1 : nrow , j = 1 : ncol , i == j ) Identity ( i , j ) = 1 END FORALL A_inv = gauss_elim ( A , Identity ) END PROCEDURE MODULE PROCEDURE gauss_elim_inverse_64 REAL ( real64 ), DIMENSION ( SIZE ( A , DIM = 1 ), SIZE ( A , DIM = 1 )) :: Identity INTEGER :: i , j , nrow , ncol nrow = SIZE ( A , DIM = 1 ) ncol = SIZE ( A , DIM = 2 ) IF ( nrow /= ncol ) THEN ERROR STOP \"A is not a square matrix\" END IF Identity = 0 FORALL ( i = 1 : nrow , j = 1 : ncol , i == j ) Identity ( i , j ) = 1 END FORALL A_inv = gauss_elim ( A , Identity ) END PROCEDURE MODULE PROCEDURE gauss_elim_inverse_128 REAL ( real128 ), DIMENSION ( SIZE ( A , DIM = 1 ), SIZE ( A , DIM = 1 )) :: Identity INTEGER :: i , j , nrow , ncol nrow = SIZE ( A , DIM = 1 ) ncol = SIZE ( A , DIM = 2 ) IF ( nrow /= ncol ) THEN ERROR STOP \"A is not a square matrix\" END IF Identity = 0 FORALL ( i = 1 : nrow , j = 1 : ncol , i == j ) Identity ( i , j ) = 1 END FORALL A_inv = gauss_elim ( A , Identity ) END PROCEDURE END SUBMODULE","tags":"","loc":"sourcefile/numeric_matrices_inverse.f90.html"},{"title":"numeric.f90 – Fortran Program","text":"Contents Modules foreng_numeric Source Code numeric.f90 Source Code module foreng_numeric !! Top level module used to store all the functionality relating to numerical analysis use foreng_numeric_matrices use foreng_numeric_regression use foreng_numeric_calculus end module","tags":"","loc":"sourcefile/numeric.f90.html"},{"title":"numeric_matrices.f90 – Fortran Program","text":"Contents Modules foreng_numeric_matrices Source Code numeric_matrices.f90 Source Code module foreng_numeric_matrices use foreng_env ! This module provides an interface for a variety of different elimination methods ! to solve systems of linear equations. INTERFACE gauss_elim MODULE PROCEDURE gauss_elim_sing_32 MODULE PROCEDURE gauss_elim_sing_64 MODULE PROCEDURE gauss_elim_sing_128 MODULE PROCEDURE gauss_elim_mult_32 MODULE PROCEDURE gauss_elim_mult_64 MODULE PROCEDURE gauss_elim_mult_128 ! ERROR RETURNS: !---------------- ! 111 - Error allocating memory for augmented matrix ! 999 - Nonsingular matrix END INTERFACE INTERFACE inverse MODULE PROCEDURE gauss_elim_inverse_32 MODULE PROCEDURE gauss_elim_inverse_64 MODULE PROCEDURE gauss_elim_inverse_128 END INTERFACE INTERFACE lu MODULE PROCEDURE lu_decomp_32 MODULE PROCEDURE lu_decomp_64 MODULE PROCEDURE lu_decomp_128 END INTERFACE INTERFACE eliminate_column MODULE PROCEDURE eliminate_column_32 MODULE PROCEDURE eliminate_column_64 MODULE PROCEDURE eliminate_column_128 END INTERFACE INTERFACE ! Explicit declaration of gauss elimination functions MODULE FUNCTION gauss_elim_sing_32 ( A , b ) RESULT ( x ) REAL ( real32 ), DIMENSION (:,:), INTENT ( IN ) :: A ! System of linear equations REAL ( real32 ), DIMENSION ( size ( A , DIM = 1 )), INTENT ( IN ) :: b ! RHS of the equation Ax = b REAL ( real32 ), DIMENSION ( size ( A , DIM = 1 )) :: x ! Solution to the system of equations END FUNCTION MODULE FUNCTION gauss_elim_sing_64 ( A , b ) RESULT ( x ) REAL ( real64 ), DIMENSION (:,:), INTENT ( IN ) :: A ! System of linear equations REAL ( real64 ), DIMENSION ( size ( A , DIM = 1 )), INTENT ( IN ) :: b ! RHS of the equation Ax = b REAL ( real64 ), DIMENSION ( size ( A , DIM = 1 )) :: x ! Solution to the system of equations END FUNCTION MODULE FUNCTION gauss_elim_sing_128 ( A , b ) RESULT ( x ) REAL ( real128 ), DIMENSION (:,:), INTENT ( IN ) :: A ! System of linear equations REAL ( real128 ), DIMENSION ( size ( A , DIM = 1 )), INTENT ( IN ) :: b ! RHS of the equation Ax = b REAL ( real128 ), DIMENSION ( size ( A , DIM = 1 )) :: x ! Solution to the system of equations END FUNCTION MODULE FUNCTION gauss_elim_mult_32 ( A , b ) RESULT ( x ) REAL ( real32 ), DIMENSION (:,:), INTENT ( IN ) :: A ! System of linear equations REAL ( real32 ), DIMENSION (:,:), INTENT ( IN ) :: b ! RHS of the equation Ax = b REAL ( real32 ), DIMENSION ( size ( A , DIM = 1 ), size ( b , DIM = 2 )) :: x ! Solution to the system of equations END FUNCTION MODULE FUNCTION gauss_elim_mult_64 ( A , b ) RESULT ( x ) REAL ( real64 ), DIMENSION (:,:), INTENT ( IN ) :: A ! System of linear equations REAL ( real64 ), DIMENSION (:,:), INTENT ( IN ) :: b ! RHS of the equation Ax = b REAL ( real64 ), DIMENSION ( size ( A , DIM = 1 ), size ( b , DIM = 2 )) :: x ! Solution to the system of equations END FUNCTION MODULE FUNCTION gauss_elim_mult_128 ( A , b ) RESULT ( x ) REAL ( real128 ), DIMENSION (:,:), INTENT ( IN ) :: A ! System of linear equations REAL ( real128 ), DIMENSION (:,:), INTENT ( IN ) :: b ! RHS of the equation Ax = b REAL ( real128 ), DIMENSION ( size ( A , DIM = 1 ), size ( b , DIM = 2 )) :: x ! Solution to the system of equations END FUNCTION MODULE FUNCTION gauss_elim_inverse_32 ( A ) RESULT ( A_inv ) REAL ( real32 ), DIMENSION (:,:), INTENT ( IN ) :: A REAL ( real32 ), DIMENSION ( size ( A , DIM = 1 ), size ( A , DIM = 1 )) :: A_inv END FUNCTION MODULE FUNCTION gauss_elim_inverse_64 ( A ) RESULT ( A_inv ) REAL ( real64 ), DIMENSION (:,:), INTENT ( IN ) :: A REAL ( real64 ), DIMENSION ( size ( A , DIM = 1 ), size ( A , DIM = 1 )) :: A_inv END FUNCTION MODULE FUNCTION gauss_elim_inverse_128 ( A ) RESULT ( A_inv ) REAL ( real128 ), DIMENSION (:,:), INTENT ( IN ) :: A REAL ( real128 ), DIMENSION ( size ( A , DIM = 1 ), size ( A , DIM = 1 )) :: A_inv END FUNCTION MODULE SUBROUTINE eliminate_column_32 ( A , icol , order ) REAL ( real32 ), DIMENSION (:,:), INTENT ( INOUT ) :: A INTEGER , INTENT ( IN ) :: icol INTEGER , DIMENSION (:), INTENT ( INOUT ) :: order END SUBROUTINE MODULE SUBROUTINE eliminate_column_64 ( A , icol , order ) REAL ( real64 ), DIMENSION (:,:), INTENT ( INOUT ) :: A INTEGER , INTENT ( IN ) :: icol INTEGER , DIMENSION (:), INTENT ( INOUT ) :: order END SUBROUTINE MODULE SUBROUTINE eliminate_column_128 ( A , icol , order ) REAL ( real128 ), DIMENSION (:,:), INTENT ( INOUT ) :: A INTEGER , INTENT ( IN ) :: icol INTEGER , DIMENSION (:), INTENT ( INOUT ) :: order END SUBROUTINE MODULE SUBROUTINE lu_decomp_32 ( A , L , U ) REAL ( real32 ), DIMENSION (:,:), INTENT ( IN ) :: A REAL ( real32 ), DIMENSION (:,:), ALLOCATABLE , INTENT ( OUT ) :: L , U END SUBROUTINE MODULE SUBROUTINE lu_decomp_64 ( A , L , U ) REAL ( real64 ), DIMENSION (:,:), INTENT ( IN ) :: A REAL ( real64 ), DIMENSION (:,:), ALLOCATABLE , INTENT ( OUT ) :: L , U END SUBROUTINE MODULE SUBROUTINE lu_decomp_128 ( A , L , U ) REAL ( real128 ), DIMENSION (:,:), INTENT ( IN ) :: A REAL ( real128 ), DIMENSION (:,:), ALLOCATABLE , INTENT ( OUT ) :: L , U END SUBROUTINE END INTERFACE end module","tags":"","loc":"sourcefile/numeric_matrices.f90.html"},{"title":"numeric_regression.f90 – Fortran Program","text":"Contents Modules foreng_numeric_regression Source Code numeric_regression.f90 Source Code module foreng_numeric_regression use foreng_env use foreng_math implicit none contains subroutine lls_fit ( X , Y , m , b , stat ) !! Linear Least Squares Fit real ( real32 ), dimension (:), intent ( in ) :: X , Y real ( real32 ), intent ( out ) :: m , b integer , optional :: stat if ( size ( X ) /= size ( Y )) then if ( present ( stat )) then stat = - 1 return else error stop \"X and Y are not the same size\" end if end if m = calc_m_lls ( X , Y ) b = calc_b_lls ( mean ( X ), mean ( Y ), m ) end subroutine subroutine lls_coefficient_fit ( X , Y , m , b , r , stat ) !! Linear Least Squares Fit with correlation coefficient real ( real32 ), dimension (:), intent ( in ) :: X , Y real ( real32 ), intent ( out ) :: m , b , r integer , optional :: stat if ( present ( stat )) then call lls_fit ( X , Y , m , b , stat ) else call lls_fit ( X , Y , m , b ) end if r = calc_correlation_coefficient_lls ( X , Y ) end subroutine subroutine generate_sys_eqns ( X , Y , order , A , u ) ! Data dictionary real ( real64 ), dimension (:), intent ( in ) :: X , Y ! The x and y coordinates to be fit integer , intent ( in ) :: order ! The order of the polynomial to fit real ( real64 ), dimension (:,:), allocatable , intent ( out ) :: A ! The system of equations we will solve real ( real64 ), dimension (:), allocatable , intent ( out ) :: u ! The right hand side of Ac = u integer :: i , j , ndim ndim = order + 1 allocate ( A ( ndim , ndim ), u ( ndim )) do i = 1 , ndim do j = 1 , ndim A ( i , j ) = sum ( X ** ( i + j - 2 )) end do end do A ( 1 , 1 ) = size ( X ) do i = 1 , ndim u ( i ) = sum ( Y * ( X ** ( i - 1 ))) end do end subroutine !====================================================================! !=                   Utility Functions                              =! !====================================================================! real ( real32 ) function calc_m_lls ( X , Y ) result ( m ) real ( real32 ), dimension (:), intent ( in ) :: X , Y real ( real32 ) :: x_bar real ( real32 ) :: y_bar real ( real32 ), dimension ( size ( X )) :: x_squared x_squared = X * X x_bar = mean ( X ) y_bar = mean ( Y ) m = ( sum ( X * Y ) - sum ( X ) * y_bar ) / ( sum ( x_squared ) - sum ( x ) * x_bar ) end function real ( real32 ) function calc_b_lls ( y_bar , x_bar , m ) result ( b ) real ( real32 ), intent ( in ) :: y_bar , x_bar , m b = y_bar - m * x_bar end function real function calc_correlation_coefficient_lls ( X , Y ) result ( r ) real ( real32 ), dimension (:), intent ( in ) :: X , Y real ( real32 ) :: denom , num !! Numerator and denominator integer :: n n = size ( X ) num = n * sum ( X * Y ) - sum ( X ) * sum ( Y ) denom = sqrt ( ( n * sum ( X * X ) - sum ( X ) ** 2 ) * ( n * sum ( Y * Y ) - sum ( Y ) ** 2 ) ) r = num / denom end function end module","tags":"","loc":"sourcefile/numeric_regression.f90.html"},{"title":"numeric_conversion.f90 – Fortran Program","text":"Contents Modules foreng_numeric_conversion Source Code numeric_conversion.f90 Source Code module foreng_numeric_conversion use foreng_env implicit none contains ! // TODO INCLUDE 4_21 end module","tags":"","loc":"sourcefile/numeric_conversion.f90.html"},{"title":"numeric_calculus.f90 – Fortran Program","text":"Contents Modules foreng_numeric_calculus Source Code numeric_calculus.f90 Source Code module foreng_numeric_calculus use foreng_env contains function calc_derivative ( func , x_0 , dx ) result ( dydx ) real ( real64 ), external :: func !! Ptr to an external function real ( real64 ), intent ( in ) :: x_0 !! Value at which to calculate the derivative real ( real64 ), optional :: dx !! Optional step size. If not present, defaults to 10&#94;{-100} real ( real64 ) :: dydx !! \\frac{dy}{dx} at x = x_0 real ( real64 ) :: f_x0 , f_x1 real ( real64 ) :: dx_ if (. not . present ( dx )) then dx_ = 1 D - 100 else dx_ = dx end if f_x0 = func ( x_0 ) f_x1 = func ( x_0 + dx_ ) dydx = ( f_x1 - f_x0 ) / dx_ end function end module","tags":"","loc":"sourcefile/numeric_calculus.f90.html"},{"title":"numeric_matrices_gauss.f90 – Fortran Program","text":"Contents Submodules foreng_numeric_matrices_gauss Source Code numeric_matrices_gauss.f90 Source Code SUBMODULE ( foreng_numeric_matrices ) foreng_numeric_matrices_gauss IMPLICIT NONE CONTAINS MODULE PROCEDURE gauss_elim_sing_32 ! Data Dictionary : declare local types & definitions INTEGER , DIMENSION ( size ( A , DIM = 1 )) :: order ! The order to process backwards substitution INTEGER :: neqs ! Number of equations in linear system of equations INTEGER :: icol , i , j , index ! Various indexing variables REAL ( real32 ), PARAMETER :: eps = 1E-13 ! Cutoff for 0 REAL ( real32 ), DIMENSION (:,:), ALLOCATABLE :: A_aug ! Augmented matrix ! Initiate order matrix order = [ ( i , i = 1 , size ( A , DIM = 1 )) ] neqs = size ( A , DIM = 1 ) allocate ( A_aug ( neqs , neqs + 1 )) ! Instantiate Augmented matrix [A | b] if ( allocated ( A_aug )) then A_aug (:, 1 : neqs ) = A A_aug (:, neqs + 1 ) = b else error stop \"Error allocating A_aug\" end if do icol = 1 , neqs - 1 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !       ELIMINATE ONE COLUMN        ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! call eliminate_column ( A_aug , icol , order ) end do !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!       Back Substitution       !!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! do i = neqs , 1 , - 1 index = order ( i ) x ( i ) = A_aug ( index , neqs + 1 ) do j = neqs , i + 1 , - 1 x ( i ) = x ( i ) - A_aug ( index , j ) * x ( j ) end do x ( i ) = x ( i ) / A_aug ( index , i ) end do END PROCEDURE MODULE PROCEDURE gauss_elim_sing_64 ! Data Dictionary : declare local types & definitions INTEGER , DIMENSION ( size ( A , DIM = 1 )) :: order ! The order to process backwards substitution INTEGER :: neqs ! Number of equations in linear system of equations INTEGER :: icol , i , j , index ! Various indexing variables REAL ( real64 ), PARAMETER :: eps = 1E-13 ! Cutoff for 0 REAL ( real64 ), DIMENSION (:,:), ALLOCATABLE :: A_aug ! Augmented matrix ! Initiate order matrix order = [ ( i , i = 1 , size ( A , DIM = 1 )) ] neqs = size ( A , DIM = 1 ) allocate ( A_aug ( neqs , neqs + 1 )) ! Instantiate Augmented matrix [A | b] if ( allocated ( A_aug )) then A_aug (:, 1 : neqs ) = A A_aug (:, neqs + 1 ) = b else error stop \"Error allocating A_aug\" end if do icol = 1 , neqs - 1 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !       ELIMINATE ONE COLUMN        ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! call eliminate_column ( A_aug , icol , order ) end do !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!       Back Substitution       !!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! do i = neqs , 1 , - 1 index = order ( i ) x ( i ) = A_aug ( index , neqs + 1 ) do j = neqs , i + 1 , - 1 x ( i ) = x ( i ) - A_aug ( index , j ) * x ( j ) end do x ( i ) = x ( i ) / A_aug ( index , i ) end do END PROCEDURE MODULE PROCEDURE gauss_elim_sing_128 ! Data Dictionary : declare local types & definitions INTEGER , DIMENSION ( size ( A , DIM = 1 )) :: order ! The order to process backwards substitution INTEGER :: neqs ! Number of equations in linear system of equations INTEGER :: icol , i , j , index ! Various indexing variables REAL ( real128 ), PARAMETER :: eps = 1E-13 ! Cutoff for 0 REAL ( real128 ), DIMENSION (:,:), ALLOCATABLE :: A_aug ! Augmented matrix ! Initiate order matrix order = [ ( i , i = 1 , size ( A , DIM = 1 )) ] neqs = size ( A , DIM = 1 ) allocate ( A_aug ( neqs , neqs + 1 )) ! Instantiate Augmented matrix [A | b] if ( allocated ( A_aug )) then A_aug (:, 1 : neqs ) = A A_aug (:, neqs + 1 ) = b else error stop \"Error allocating A_aug\" end if do icol = 1 , neqs - 1 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !       ELIMINATE ONE COLUMN        ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! call eliminate_column ( A_aug , icol , order ) end do !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!       Back Substitution       !!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! do i = neqs , 1 , - 1 index = order ( i ) x ( i ) = A_aug ( index , neqs + 1 ) do j = neqs , i + 1 , - 1 x ( i ) = x ( i ) - A_aug ( index , j ) * x ( j ) end do x ( i ) = x ( i ) / A_aug ( index , i ) end do END PROCEDURE MODULE PROCEDURE gauss_elim_mult_32 ! Data Dictionary : declare local types & definitions INTEGER , DIMENSION ( size ( A , DIM = 1 )) :: order ! The order to process backwards substitution INTEGER :: neqs ! Number of equations in linear system of equations INTEGER :: nsols ! Number of columns of b, the solution vector we are solving for INTEGER :: icol , i , j , k , index ! Various indexing variables REAL ( real32 ), PARAMETER :: eps = 1E-13 ! Cutoff for 0 REAL ( real32 ), DIMENSION (:,:), ALLOCATABLE :: A_aug ! Augmented matrix ! Assert that matrix dimensions agree nsols = size ( b , DIM = 2 ) neqs = size ( A , DIM = 1 ) if ( neqs /= size ( b , DIM = 1 )) then error stop \"Number of rows of A and b do not match\" end if ! Initiate order matrix order = [ ( i , i = 1 , size ( A , DIM = 1 )) ] allocate ( A_aug ( neqs , neqs + nsols )) ! Instantiate Augmented matrix [A | b] if ( allocated ( A_aug )) then A_aug (:, 1 : neqs ) = A A_aug (:, neqs + 1 :) = b else error stop \"Error allocating A_aug\" end if do icol = 1 , neqs - 1 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !       ELIMINATE ONE COLUMN        ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! call eliminate_column ( A_aug , icol , order ) end do !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!       Back Substitution       !!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! do k = 1 , nsols do i = neqs , 1 , - 1 index = order ( i ) x ( i , k ) = A_aug ( index , neqs + k ) do j = neqs , i + 1 , - 1 x ( i , k ) = x ( i , k ) - A_aug ( index , j ) * x ( j , k ) end do x ( i , k ) = x ( i , k ) / A_aug ( index , i ) end do end do end procedure MODULE PROCEDURE gauss_elim_mult_64 ! Data Dictionary : declare local types & definitions INTEGER , DIMENSION ( size ( A , DIM = 1 )) :: order ! The order to process backwards substitution INTEGER :: neqs ! Number of equations in linear system of equations INTEGER :: nsols ! Number of columns of b, the solution vector we are solving for INTEGER :: icol , i , j , k , index ! Various indexing variables REAL ( real64 ), PARAMETER :: eps = 1E-13 ! Cutoff for 0 REAL ( real64 ), DIMENSION (:,:), ALLOCATABLE :: A_aug ! Augmented matrix ! Assert that matrix dimensions agree nsols = size ( b , DIM = 2 ) neqs = size ( A , DIM = 1 ) if ( neqs /= size ( b , DIM = 1 )) then error stop \"Number of rows of A and b do not match\" end if ! Initiate order matrix order = [ ( i , i = 1 , size ( A , DIM = 1 )) ] allocate ( A_aug ( neqs , neqs + nsols )) ! Instantiate Augmented matrix [A | b] if ( allocated ( A_aug )) then A_aug (:, 1 : neqs ) = A A_aug (:, neqs + 1 :) = b else error stop \"Error allocating A_aug\" end if do icol = 1 , neqs - 1 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !       ELIMINATE ONE COLUMN        ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! call eliminate_column ( A_aug , icol , order ) end do !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!       Back Substitution       !!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! do k = 1 , nsols do i = neqs , 1 , - 1 index = order ( i ) x ( i , k ) = A_aug ( index , neqs + k ) do j = neqs , i + 1 , - 1 x ( i , k ) = x ( i , k ) - A_aug ( index , j ) * x ( j , k ) end do x ( i , k ) = x ( i , k ) / A_aug ( index , i ) end do end do end procedure MODULE PROCEDURE gauss_elim_mult_128 ! Data Dictionary : declare local types & definitions INTEGER , DIMENSION ( size ( A , DIM = 1 )) :: order ! The order to process backwards substitution INTEGER :: neqs ! Number of equations in linear system of equations INTEGER :: nsols ! Number of columns of b, the solution vector we are solving for INTEGER :: icol , i , j , k , index ! Various indexing variables REAL ( real128 ), PARAMETER :: eps = 1E-13 ! Cutoff for 0 REAL ( real128 ), DIMENSION (:,:), ALLOCATABLE :: A_aug ! Augmented matrix ! Assert that matrix dimensions agree nsols = size ( b , DIM = 2 ) neqs = size ( A , DIM = 1 ) if ( neqs /= size ( b , DIM = 1 )) then error stop \"Number of rows of A and b do not match\" end if ! Initiate order matrix order = [ ( i , i = 1 , size ( A , DIM = 1 )) ] allocate ( A_aug ( neqs , neqs + nsols )) ! Instantiate Augmented matrix [A | b] if ( allocated ( A_aug )) then A_aug (:, 1 : neqs ) = A A_aug (:, neqs + 1 :) = b else error stop \"Error allocating A_aug\" end if do icol = 1 , neqs - 1 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !       ELIMINATE ONE COLUMN        ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! call eliminate_column ( A_aug , icol , order ) end do !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!       Back Substitution       !!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! do k = 1 , nsols do i = neqs , 1 , - 1 index = order ( i ) x ( i , k ) = A_aug ( index , neqs + k ) do j = neqs , i + 1 , - 1 x ( i , k ) = x ( i , k ) - A_aug ( index , j ) * x ( j , k ) end do x ( i , k ) = x ( i , k ) / A_aug ( index , i ) end do end do end procedure MODULE PROCEDURE eliminate_column_32 INTEGER :: nrow INTEGER :: ncol INTEGER :: nnz , max_scaled_pivot_index INTEGER :: irow , i , temp_row , temp_index REAL ( real32 ) :: eps = 1E-13 REAL ( real32 ) :: scaled_pivot , max_scaled_pivot , scalar nrow = size ( A , dim = 1 ) ncol = size ( A , dim = 2 ) nnz = count ( abs ( A ( icol : nrow , icol )) > eps ) if ( nnz == 0 ) then error stop \"Matrix is singular, stopping elimination\" end if ! Instantiate pivot variables to find max_scaled_pivot max_scaled_pivot = 0 max_scaled_pivot_index = 0 ! Find max_scaled_pivot and its index do irow = icol , nrow i = order ( irow ) if ( abs ( A ( i , icol )) > eps ) then scaled_pivot = abs ( A ( i , icol ) / maxval ( A ( i , icol : nrow ))) if ( scaled_pivot > max_scaled_pivot ) then max_scaled_pivot = scaled_pivot max_scaled_pivot_index = i end if end if end do if ( max_scaled_pivot_index /= order ( icol )) then temp_row = order ( icol ) temp_index = find_index ( max_scaled_pivot_index , order , icol ) ! print *, \"temp_row:   \", temp_row ! print *, \"temp_index: \", temp_index order ( icol ) = max_scaled_pivot_index order ( temp_index ) = temp_row end if ! print *, \"order after swap: \", order ! Eliminate values under pivot column do irow = icol + 1 , nrow scalar = A ( order ( irow ), icol ) / A ( max_scaled_pivot_index , icol ) ! Set the column we are eliminating to 0 A ( order ( irow ), icol ) = 0.0 ! Perform row - scalar * pivot row A ( order ( irow ), icol + 1 :) = A ( order ( irow ), icol + 1 :) - scalar * A ( max_scaled_pivot_index , icol + 1 :) end do END PROCEDURE MODULE PROCEDURE eliminate_column_64 INTEGER :: nrow INTEGER :: ncol INTEGER :: nnz , max_scaled_pivot_index INTEGER :: irow , i , temp_row , temp_index REAL ( real64 ) :: eps = 1E-13 REAL ( real64 ) :: scaled_pivot , max_scaled_pivot , scalar nrow = size ( A , dim = 1 ) ncol = size ( A , dim = 2 ) nnz = count ( abs ( A ( icol : nrow , icol )) > eps ) if ( nnz == 0 ) then error stop \"Matrix is singular, stopping elimination\" end if ! Instantiate pivot variables to find max_scaled_pivot max_scaled_pivot = 0 max_scaled_pivot_index = 0 ! Find max_scaled_pivot and its index do irow = icol , nrow i = order ( irow ) if ( abs ( A ( i , icol )) > eps ) then scaled_pivot = abs ( A ( i , icol ) / maxval ( A ( i , icol : nrow ))) if ( scaled_pivot > max_scaled_pivot ) then max_scaled_pivot = scaled_pivot max_scaled_pivot_index = i end if end if end do if ( max_scaled_pivot_index /= order ( icol )) then temp_row = order ( icol ) temp_index = find_index ( max_scaled_pivot_index , order , icol ) ! print *, \"temp_row:   \", temp_row ! print *, \"temp_index: \", temp_index order ( icol ) = max_scaled_pivot_index order ( temp_index ) = temp_row end if ! print *, \"order after swap: \", order ! Eliminate values under pivot column do irow = icol + 1 , nrow scalar = A ( order ( irow ), icol ) / A ( max_scaled_pivot_index , icol ) ! Set the column we are eliminating to 0 A ( order ( irow ), icol ) = 0.0 ! Perform row - scalar * pivot row A ( order ( irow ), icol + 1 :) = A ( order ( irow ), icol + 1 :) - scalar * A ( max_scaled_pivot_index , icol + 1 :) end do END PROCEDURE MODULE PROCEDURE eliminate_column_128 INTEGER :: nrow INTEGER :: ncol INTEGER :: nnz , max_scaled_pivot_index INTEGER :: irow , i , temp_row , temp_index REAL ( real128 ) :: eps = 1E-13 REAL ( real128 ) :: scaled_pivot , max_scaled_pivot , scalar nrow = size ( A , dim = 1 ) ncol = size ( A , dim = 2 ) nnz = count ( abs ( A ( icol : nrow , icol )) > eps ) if ( nnz == 0 ) then error stop \"Matrix is singular, stopping elimination\" end if ! Instantiate pivot variables to find max_scaled_pivot max_scaled_pivot = 0 max_scaled_pivot_index = 0 ! Find max_scaled_pivot and its index do irow = icol , nrow i = order ( irow ) if ( abs ( A ( i , icol )) > eps ) then scaled_pivot = abs ( A ( i , icol ) / maxval ( A ( i , icol : nrow ))) if ( scaled_pivot > max_scaled_pivot ) then max_scaled_pivot = scaled_pivot max_scaled_pivot_index = i end if end if end do if ( max_scaled_pivot_index /= order ( icol )) then temp_row = order ( icol ) temp_index = find_index ( max_scaled_pivot_index , order , icol ) ! print *, \"temp_row:   \", temp_row ! print *, \"temp_index: \", temp_index order ( icol ) = max_scaled_pivot_index order ( temp_index ) = temp_row end if ! print *, \"order after swap: \", order ! Eliminate values under pivot column do irow = icol + 1 , nrow scalar = A ( order ( irow ), icol ) / A ( max_scaled_pivot_index , icol ) ! Set the column we are eliminating to 0 A ( order ( irow ), icol ) = 0.0 ! Perform row - scalar * pivot row A ( order ( irow ), icol + 1 :) = A ( order ( irow ), icol + 1 :) - scalar * A ( max_scaled_pivot_index , icol + 1 :) end do END PROCEDURE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! FIND_INDEX ! --------- ! !   Find the index of an integer value in an integer array. If the value !   is not in the array, return -1 ! INTEGER PURE FUNCTION find_index ( value , int_array , start_index ) RESULT ( index ) INTEGER , INTENT ( IN ) :: value INTEGER , DIMENSION (:), INTENT ( IN ) :: int_array INTEGER , OPTIONAL , INTENT ( IN ) :: start_index INTEGER :: array_size , i index = - 1 array_size = SIZE ( int_array ) do i = start_index , array_size if ( int_array ( i ) == value ) then index = i return end if end do END FUNCTION end submodule","tags":"","loc":"sourcefile/numeric_matrices_gauss.f90.html"},{"title":"science_phys.f90 – Fortran Program","text":"Contents Modules foreng_science_phys Source Code science_phys.f90 Source Code module foreng_science_phys use foreng_env use foreng_science_const implicit none contains function calc_tension ( W_ , lc_ , lp_ , d_ ) result ( T_ ) real , intent ( in ) :: W_ !! Weight of the object (kg) real , intent ( in ) :: lc_ !! length of the cable (m) real , intent ( in ) :: lp_ !! Length of the pole (m) real , intent ( in ) :: d_ !! Distance to attach the weight (m) real :: T_ !! Tension in N T_ = ( W_ * lc_ * lp_ ) / ( d_ * sqrt ( lp_ ** 2 - d_ ** 2 )) end function function calc_decibels ( P1_ , P2_ ) result ( dB_ ) real , intent ( in ) :: P1_ , P2_ real :: dB_ dB_ = log10 ( P2_ / P1_ ) end function function calc_gravity ( m1 , m2 , r ) result ( F ) real ( real64 ), intent ( in ) :: m1 !! mass of body 1 in kg real ( real64 ), intent ( in ) :: m2 !! mass of body 2 in kg real ( real64 ), intent ( in ) :: r !! distance between bodies in meters real ( real64 ) :: F !! Gravitational force F = ( GRAVITATIONAL_CONSTANT * m1 * m2 ) / ( r * r ) end function end module","tags":"","loc":"sourcefile/science_phys.f90.html"},{"title":"science_temp.f90 – Fortran Program","text":"Contents Modules foreng_science_temp Source Code science_temp.f90 Source Code module foreng_science_temp use foreng_env implicit none interface fahrenheit_to_celcius module procedure fahrenheit_to_celcius_r32 module procedure fahrenheit_to_celcius_r64 end interface interface celcius_to_fahrenheit module procedure celcius_to_fahrenheit_r32 module procedure celcius_to_fahrenheit_r64 end interface interface celcius_to_kelvin module procedure celcius_to_kelvin_r32 module procedure celcius_to_kelvin_r64 end interface interface kelvin_to_celcius module procedure kelvin_to_celcius_r32 module procedure kelvin_to_celcius_r64 end interface interface kelvin_to_fahrenheit module procedure kelvin_to_fahrenheit_r32 module procedure kelvin_to_fahrenheit_r64 end interface interface fahrenheit_to_kelvin module procedure fahrenheit_to_kelvin_r32 module procedure fahrenheit_to_kelvin_r64 end interface contains elemental function fahrenheit_to_celcius_r32 ( F ) result ( C ) real ( real32 ), intent ( in ) :: F real ( real32 ) :: C C = ( F - 3 2._real32 ) * ( 5._real32 / 9._real32 ) end function elemental function fahrenheit_to_celcius_r64 ( F ) result ( C ) real ( real64 ), intent ( in ) :: F real ( real64 ) :: C C = ( F - 3 2._real64 ) * ( 5._real64 / 9._real64 ) end function elemental function celcius_to_fahrenheit_r32 ( C ) result ( F ) real ( real32 ), intent ( in ) :: C real ( real32 ) :: F F = C * ( 9._real32 / 5._real32 ) + 3 2._real32 end function elemental function celcius_to_fahrenheit_r64 ( C ) result ( F ) real ( real64 ), intent ( in ) :: C real ( real64 ) :: F F = C * ( 9._real64 / 5._real64 ) + 3 2._real64 end function elemental function celcius_to_kelvin_r32 ( C ) result ( K ) real ( real32 ), intent ( in ) :: C real ( real32 ) :: K K = C + 27 3._real32 end function elemental function celcius_to_kelvin_r64 ( C ) result ( K ) real ( real64 ), intent ( in ) :: C real ( real64 ) :: K K = C + 27 3._real64 end function elemental function kelvin_to_celcius_r32 ( K ) result ( C ) real ( real32 ), intent ( in ) :: K real ( real32 ) :: C C = K - 27 3._real32 end function elemental function kelvin_to_celcius_r64 ( K ) result ( C ) real ( real64 ), intent ( in ) :: K real ( real64 ) :: C C = K - 27 3._real32 end function elemental function kelvin_to_fahrenheit_r32 ( K ) result ( F ) real ( real32 ), intent ( in ) :: K real ( real32 ) :: F F = celcius_to_fahrenheit ( kelvin_to_celcius ( K )) end function elemental function kelvin_to_fahrenheit_r64 ( K ) result ( F ) real ( real64 ), intent ( in ) :: K real ( real64 ) :: F F = celcius_to_fahrenheit ( kelvin_to_celcius ( K )) end function elemental function fahrenheit_to_kelvin_r32 ( F ) result ( K ) real ( real32 ), intent ( in ) :: F real ( real32 ) :: K K = celcius_to_kelvin ( fahrenheit_to_celcius ( F )) end function elemental function fahrenheit_to_kelvin_r64 ( F ) result ( K ) real ( real64 ), intent ( in ) :: F real ( real64 ) :: K K = celcius_to_fahrenheit ( kelvin_to_celcius ( K )) end function end module","tags":"","loc":"sourcefile/science_temp.f90.html"},{"title":"science_elec.f90 – Fortran Program","text":"Contents Modules foreng_science_elec Source Code science_elec.f90 Source Code module foreng_science_elec use foreng_env contains elemental function calc_current_flow ( v_D , I_O , T ) result ( i_D_ ) ! Data Dictionary real ( 16 ) :: i_D !! Current flow through the diode in amperes real ( 16 ), intent ( in ) :: v_D !! Voltage across the diode, in volts real ( 16 ), intent ( in ) :: I_O !! Leakage current of the diode, in amperes real ( 16 ), intent ( in ) :: T !! Temperature, in kelvins (K) real ( 16 ), parameter :: q = 1.602E-19 !! The charge on an electron, 1.602 X 10-19 Coulombs real ( 16 ), parameter :: k = 1.38E-23 ! Boltzmann's constant, 1.38 X 10-23 J/K i_D_ = I_O_ * ( exp (( q_ * v_D_ ) / ( k_ * T_ )) - 1 ) end function end module","tags":"","loc":"sourcefile/science_elec.f90.html"},{"title":"science_const.f90 – Fortran Program","text":"Contents Modules foreng_science_const Source Code science_const.f90 Source Code module foreng_science_const !! A series of scientific constants used in the science module use foreng_env implicit none real ( real64 ), parameter :: BOLTZMANN_CONSTANT = 1.38E-23 !! Joules/Kelvin (J/K) real ( real64 ), parameter :: ELECTRON_CHARGE = 1.602E-19 !! Coulombs (C) real ( real64 ), parameter :: GRAVITATIONAL_CONSTANT = 6.672E-11 !! N m2/kg2 real ( real64 ), parameter :: AVOGADRO_NUMBER = 6.023E23 !! Number of molecules in a mol real ( real64 ), parameter :: UNIVERSAL_GAS_CONSTANT = 8.314 !! L * kPa/mol * K real ( real64 ), parameter :: EARTH_MASS = 5.98E24 !! kg ! real(real64), parameter :: ! real(real64), parameter :: end module","tags":"","loc":"sourcefile/science_const.f90.html"},{"title":"science.f90 – Fortran Program","text":"Contents Modules foreng_science Source Code science.f90 Source Code module foreng_science use foreng_science_temp use foreng_science_elec use foreng_science_const use foreng_science_phys end module","tags":"","loc":"sourcefile/science.f90.html"},{"title":"math_trig.f90 – Fortran Program","text":"Contents Modules foreng_math_trig Source Code math_trig.f90 Source Code module foreng_math_trig !! Trigonometric functions defined for inputs whose units are degrees instead of radians. use foreng_env implicit none !=============================================================================! !=                         Trigonometry Interface                            =! !=============================================================================! interface sind !! Calculate \\sin(\\theta) where \\theta is in degrees !!```fortran !! !!real(real32) :: theta_r32 = 90 !!real(real64) :: theta_r64 = 30 !! !!print *, sind(theta_r32) ! = 1.000 !!print *, sind(theta_r64) ! = 0.500 !!``` module procedure sind_r32 module procedure sind_r64 end interface interface cosd !! Calculate \\cos(\\theta) where \\theta is in degrees !!```fortran !! !!real(real32) :: theta_r32 = 90 !!real(real64) :: theta_r64 = 60 !! !!print *, cosd(theta_r32) ! = 0.000 !!print *, cosd(theta_r64) ! = 0.500 !!``` module procedure cosd_r32 module procedure cosd_r64 end interface interface tand !! Calculate \\tan(\\theta) where \\theta is in degrees !!```fortran !! !!real(real32) :: theta_r32 = 45 !!real(real64) :: theta_r64 = -45 !! !!print *, tand(theta_r32) ! = 1.000 !!print *, tand(theta_r64) ! = -1.000 !!``` module procedure tand_r32 module procedure tand_r64 end interface interface asind !! Calculate \\textrm{asin}(x) and return \\theta in degrees !!```fortran !! !!real(real32) :: x_r32 = 1 !!real(real64) :: x_r64 = 0 !! !!print *, asind(x_r32) ! = 90.000 !!print *, asind(x_r64) ! = 0.000 !!``` module procedure asind_r32 module procedure asind_r64 end interface interface acosd !! Calculate \\textrm{acos}(x) and return \\theta in degrees !!```fortran !! !!real(real32) :: x_r32 = 1 !!real(real64) :: x_r64 = 0 !! !!print *, acosd(x_r32) ! = 0.000 !!print *, acosd(x_r64) ! = 90.000 !!``` module procedure acosd_r32 module procedure acosd_r64 end interface interface atand !! Calculate \\textrm{atan}(x) and return \\theta in degrees !!```fortran !! !!real(real32) :: x_r32 = 1 !!real(real64) :: x_r64 = -1 !! !!print *, acosd(x_r32) ! = 45.000 !!print *, acosd(x_r64) ! = -45.000 !!``` module procedure atand_r32 module procedure atand_r64 end interface interface sinhd module procedure sinhd_r32 module procedure sinhd_r64 end interface interface coshd module procedure coshd_r32 module procedure coshd_r64 end interface interface tanhd module procedure tanhd_r32 module procedure tanhd_r64 end interface interface deg_to_rad !! Convert \\theta from degrees to radians module procedure deg_to_rad_r32 module procedure deg_to_rad_r64 end interface interface rad_to_deg !! Conver \\theta from radians to degrees module procedure rad_to_deg_r32 module procedure rad_to_deg_r64 end interface !=============================================================================! !=                         Trigonometry Functions                            =! !=============================================================================! contains elemental real ( real32 ) function sind_r32 ( theta ) result ( sind ) !! Single precision real ( real32 ), intent ( in ) :: theta !! \\theta in degrees sind = sin ( deg_to_rad ( theta )) end function elemental real ( real64 ) function sind_r64 ( theta ) result ( sind ) !! Double precision real ( real64 ), intent ( in ) :: theta !! \\theta in degrees sind = sin ( deg_to_rad ( theta )) end function elemental real ( real32 ) function cosd_r32 ( theta ) result ( cosd ) !! Single precision real ( real32 ), intent ( in ) :: theta !! \\theta in degrees cosd = cos ( deg_to_rad ( theta )) end function elemental real ( real64 ) function cosd_r64 ( theta ) result ( cosd ) !! Double precision real ( real64 ), intent ( in ) :: theta !! \\theta in degrees cosd = cos ( deg_to_rad ( theta )) end function elemental real ( real32 ) function tand_r32 ( theta ) result ( tand ) !! Single precision real ( real32 ), intent ( in ) :: theta !! \\theta in degrees tand = tan ( deg_to_rad ( theta )) end function elemental real ( real64 ) function tand_r64 ( theta ) result ( tand ) !! Double precision real ( real64 ), intent ( in ) :: theta !! \\theta in degrees tand = tan ( deg_to_rad ( theta )) end function elemental function asind_r32 ( x ) result ( theta ) !! Single precision real ( real32 ), intent ( in ) :: x real ( real32 ) :: theta !! \\theta in degrees theta = rad_to_deg ( asin ( x )) end function elemental function asind_r64 ( x ) result ( theta ) !! Double precision real ( real64 ), intent ( in ) :: x real ( real64 ) :: theta !! \\theta in degrees theta = rad_to_deg ( asin ( x )) end function elemental function acosd_r32 ( x ) result ( theta ) !! Single precision real ( real32 ), intent ( in ) :: x real ( real32 ) :: theta !! \\theta in degrees theta = rad_to_deg ( acos ( x )) end function elemental function acosd_r64 ( x ) result ( theta ) !! Double precision real ( real64 ), intent ( in ) :: x real ( real64 ) :: theta !! \\theta in degrees theta = rad_to_deg ( acos ( x )) end function elemental function atand_r32 ( x ) result ( theta ) !! Single precision real ( real32 ), intent ( in ) :: x real ( real32 ) :: theta !! \\theta in degrees theta = rad_to_deg ( atan ( x )) end function elemental function atand_r64 ( x ) result ( theta ) !! Double precision real ( real64 ), intent ( in ) :: x real ( real64 ) :: theta !! \\theta in degrees theta = rad_to_deg ( atan ( x )) end function elemental real ( real32 ) function sinhd_r32 ( theta ) result ( sinhd ) !! Single precision real ( real32 ), intent ( in ) :: theta !! \\theta in degrees sinhd = sinh ( deg_to_rad ( theta )) end function elemental real ( real64 ) function sinhd_r64 ( theta ) result ( sinhd ) !! Double precision real ( real64 ), intent ( in ) :: theta !! \\theta in degrees sinhd = sinh ( deg_to_rad ( theta )) end function elemental real ( real32 ) function coshd_r32 ( theta ) result ( coshd ) !! Single precision real ( real32 ), intent ( in ) :: theta !! \\theta in degrees coshd = cosh ( deg_to_rad ( theta )) end function elemental real ( real64 ) function coshd_r64 ( theta ) result ( coshd ) !! Double precision real ( real64 ), intent ( in ) :: theta !! \\theta in degrees coshd = cosh ( deg_to_rad ( theta )) end function elemental real ( real32 ) function tanhd_r32 ( theta ) result ( tanhd ) !! Single precision real ( real32 ), intent ( in ) :: theta !! \\theta in degrees tanhd = tanh ( deg_to_rad ( theta )) end function elemental real ( real64 ) function tanhd_r64 ( theta ) result ( tanhd ) !! Double precision real ( real64 ), intent ( in ) :: theta !! \\theta in degrees tanhd = tanh ( deg_to_rad ( theta )) end function elemental real ( real32 ) function deg_to_rad_r32 ( degrees ) result ( radians ) real ( real32 ), intent ( in ) :: degrees radians = degrees / 180_real32 * PI_32 end function elemental real ( real64 ) function deg_to_rad_r64 ( degrees ) result ( radians ) real ( real64 ), intent ( in ) :: degrees radians = degrees / 180_real64 * PI end function elemental real ( real32 ) function rad_to_deg_r32 ( radians ) result ( degrees ) real ( real32 ), intent ( in ) :: radians degrees = radians / PI_32 * 180_real32 end function elemental real ( real64 ) function rad_to_deg_r64 ( radians ) result ( degrees ) real ( real64 ), intent ( in ) :: radians degrees = radians / PI * 180_real64 end function end module","tags":"","loc":"sourcefile/math_trig.f90.html"},{"title":"math_stats.f90 – Fortran Program","text":"Module to contain statistics routines like finding the mean, std dev Contents Modules foreng_math_stats Source Code math_stats.f90 Source Code !! Module to contain statistics routines like finding the mean, std dev module foreng_math_stats use foreng_env use foreng_math_misc implicit none !// TODO add documentation !=============================================================================! !=                          Generic Mean Interface                           =! !=============================================================================! interface mean module procedure rank_1_mean_r32 module procedure rank_1_mean_r64 module procedure rank_1_mean_i32 module procedure rank_1_mean_i64 end interface !=============================================================================! !=                        Arithmetic Mean Interface                          =! !=============================================================================! interface arithmetic_mean module procedure rank1_arithmetic_mean_r32 module procedure rank1_arithmetic_mean_r64 module procedure rank1_arithmetic_mean_i32 module procedure rank1_arithmetic_mean_i64 end interface !=============================================================================! !=                   Root-mean-squared Mean Interface                        =! !=============================================================================! interface rms_mean module procedure rank1_root_mean_squared_mean_r32 module procedure rank1_root_mean_squared_mean_r64 module procedure rank1_root_mean_squared_mean_i32 module procedure rank1_root_mean_squared_mean_i64 end interface !=============================================================================! !=                          Harmonic Mean Interface                          =! !=============================================================================! interface harmonic_mean module procedure rank1_harmonic_mean_r32 module procedure rank1_harmonic_mean_r64 module procedure rank1_harmonic_mean_i32 module procedure rank1_harmonic_mean_i64 end interface !=============================================================================! !=                         Geometric Mean Interface                          =! !=============================================================================! interface geometric_mean module procedure rank1_geometric_mean_r32 module procedure rank1_geometric_mean_r64 module procedure rank1_geometric_mean_i32 module procedure rank1_geometric_mean_i64 end interface !=============================================================================! !=                      Standard Deviation Interface                         =! !=============================================================================! interface std_dev module procedure std_dev_r32 module procedure std_dev_r64 module procedure std_dev_i32 module procedure std_dev_i64 end interface !=============================================================================! !=                          Generic Mean Functions                           =! !=============================================================================! contains function rank_1_mean_r32 ( data_ , type ) result ( mean_ ) !! Calculate the mean of a 1d data set, given the \"type\" character ( LEN =* ), intent ( in ), optional :: type real ( real32 ), intent ( in ), dimension (:) :: data_ real ( real32 ) :: mean_ if ( present ( type )) then !! Check which mean to call select case ( type ) case ( \"arithmetic\" ) mean_ = arithmetic_mean ( data_ ) case ( \"geometric\" ) mean_ = geometric_mean ( data_ ) case ( \"rms\" ) mean_ = rms_mean ( data_ ) case ( \"harmonic\" ) mean_ = harmonic_mean ( data_ ) case default error stop \"No recognized mean type selected\" end select else mean_ = arithmetic_mean ( data_ ) end if end function function rank_1_mean_r64 ( data_ , type ) result ( mean_ ) !! Calculate the mean of a 1d data set, given the \"type\" character ( LEN =* ), intent ( in ), optional :: type real ( real64 ), intent ( in ), dimension (:) :: data_ real ( real64 ) :: mean_ if ( present ( type )) then !! Check which mean to call select case ( type ) case ( \"arithmetic\" ) mean_ = arithmetic_mean ( data_ ) case ( \"geometric\" ) mean_ = geometric_mean ( data_ ) case ( \"rms\" ) mean_ = rms_mean ( data_ ) case ( \"harmonic\" ) mean_ = harmonic_mean ( data_ ) case default error stop \"No recognized mean type selected\" end select else mean_ = arithmetic_mean ( data_ ) end if end function function rank_1_mean_i32 ( data_ , type ) result ( mean_ ) !! Calculate the mean of a 1d data set, given the \"type\" character ( LEN =* ), intent ( in ), optional :: type integer ( int32 ), intent ( in ), dimension (:) :: data_ real ( real32 ) :: mean_ if ( present ( type )) then !! Check which mean to call select case ( type ) case ( \"arithmetic\" ) mean_ = arithmetic_mean ( data_ ) case ( \"geometric\" ) mean_ = geometric_mean ( data_ ) case ( \"rms\" ) mean_ = rms_mean ( data_ ) case ( \"harmonic\" ) mean_ = harmonic_mean ( data_ ) case default error stop \"No recognized mean type selected\" end select else mean_ = arithmetic_mean ( data_ ) end if end function function rank_1_mean_i64 ( data_ , type ) result ( mean_ ) !! Calculate the mean of a 1d data set, given the \"type\" character ( LEN =* ), intent ( in ), optional :: type integer ( int64 ), intent ( in ), dimension (:) :: data_ real ( real64 ) :: mean_ if ( present ( type )) then !! Check which mean to call select case ( type ) case ( \"arithmetic\" ) mean_ = arithmetic_mean ( data_ ) case ( \"geometric\" ) mean_ = geometric_mean ( data_ ) case ( \"rms\" ) mean_ = rms_mean ( data_ ) case ( \"harmonic\" ) mean_ = harmonic_mean ( data_ ) case default error stop \"No recognized mean type selected\" end select else mean_ = arithmetic_mean ( data_ ) end if end function !=============================================================================! !=                        Arithmetic Mean Functions                          =! !=============================================================================! function rank1_arithmetic_mean_r32 ( data_ ) result ( arithmetic_mean_ ) !! Calculate the arithmetic mean of a rank 1 array real ( real32 ), intent ( in ) :: data_ (:) real ( real32 ) :: arithmetic_mean_ !! Rank 1 array containing the elements to calculate the mean for integer :: n_elements n_elements = size ( data_ ) arithmetic_mean_ = sum ( data_ ) / n_elements end function function rank1_arithmetic_mean_r64 ( data_ ) result ( arithmetic_mean_ ) !! Calculate the arithmetic mean of a rank 1 array real ( real64 ), intent ( in ) :: data_ (:) real ( real64 ) :: arithmetic_mean_ !! Rank 1 array containing the elements to calculate the mean for integer :: n_elements n_elements = size ( data_ ) arithmetic_mean_ = sum ( data_ ) / n_elements end function function rank1_arithmetic_mean_i32 ( data_ ) result ( arithmetic_mean_ ) !! Calculate the arithmetic mean of a rank 1 array integer ( int32 ), intent ( in ) :: data_ (:) !! Rank 1 array containing the elements to calculate the mean for real ( real32 ) :: arithmetic_mean_ integer :: n_elements n_elements = size ( data_ ) arithmetic_mean_ = real ( sum ( data_ ), real32 ) / n_elements end function function rank1_arithmetic_mean_i64 ( data_ ) result ( arithmetic_mean_ ) !! Calculate the arithmetic mean of a rank 1 array integer ( int64 ), intent ( in ) :: data_ (:) real ( real64 ) :: arithmetic_mean_ !! Rank 1 array containing the elements to calculate the mean for integer :: n_elements n_elements = size ( data_ ) arithmetic_mean_ = real ( sum ( data_ ), real64 ) / n_elements end function !=============================================================================! !=                   Root-mean-squared Mean Functions                        =! !=============================================================================! function rank1_root_mean_squared_mean_r32 ( data_ ) result ( rms_ ) real ( real32 ), intent ( in ) :: data_ (:) real ( real32 ) :: rms_ !! Rank 1 array containing the elements to calculate the mean for integer :: n_elements n_elements = size ( data_ ) rms_ = sqrt ( sum ( data_ * data_ ) / n_elements ) end function function rank1_root_mean_squared_mean_r64 ( data_ ) result ( rms_ ) real ( real64 ), intent ( in ) :: data_ (:) real ( real64 ) :: rms_ !! Rank 1 array containing the elements to calculate the mean for integer :: n_elements n_elements = size ( data_ ) rms_ = sqrt ( sum ( data_ * data_ ) / n_elements ) end function function rank1_root_mean_squared_mean_i32 ( data_ ) result ( rms_ ) integer ( int32 ), intent ( in ) :: data_ (:) real ( real32 ) :: rms_ !! Rank 1 array containing the elements to calculate the mean for integer :: n_elements n_elements = size ( data_ ) rms_ = sqrt ( sum ( real ( data_ * data_ )) / n_elements ) end function function rank1_root_mean_squared_mean_i64 ( data_ ) result ( rms_ ) integer ( int64 ), intent ( in ) :: data_ (:) real ( real64 ) :: rms_ !! Rank 1 array containing the elements to calculate the mean for integer :: n_elements n_elements = size ( data_ ) rms_ = sqrt ( sum ( real ( data_ * data_ , real64 )) / n_elements ) end function !=============================================================================! !=                          Harmonic Mean Functions                          =! !=============================================================================! function rank1_harmonic_mean_r32 ( data_ ) result ( harmonic_mean_ ) real ( real32 ), intent ( in ) :: data_ (:) real ( real32 ) :: harmonic_mean_ !! Rank 1 array containing the elements to calculate the mean for integer :: n_elements real ( real32 ), allocatable :: inverses (:) n_elements = size ( data_ ) inverses = 1 / data_ harmonic_mean_ = n_elements / sum ( inverses ) end function function rank1_harmonic_mean_r64 ( data_ ) result ( harmonic_mean_ ) real ( real64 ), intent ( in ) :: data_ (:) real ( real64 ) :: harmonic_mean_ !! Rank 1 array containing the elements to calculate the mean for integer :: n_elements real ( real64 ), allocatable :: inverses (:) n_elements = size ( data_ ) inverses = 1_real64 / data_ harmonic_mean_ = n_elements / sum ( inverses ) end function function rank1_harmonic_mean_i32 ( data_ ) result ( harmonic_mean_ ) integer ( int32 ), intent ( in ) :: data_ (:) real ( real32 ) :: harmonic_mean_ !! Rank 1 array containing the elements to calculate the mean for integer :: n_elements real ( real32 ), allocatable :: inverses (:) n_elements = size ( data_ ) inverses = 1.0 / data_ harmonic_mean_ = n_elements / sum ( inverses ) end function function rank1_harmonic_mean_i64 ( data_ ) result ( harmonic_mean_ ) integer ( int64 ), intent ( in ) :: data_ (:) real ( real64 ) :: harmonic_mean_ !! Rank 1 array containing the elements to calculate the mean for integer :: n_elements real ( real64 ), allocatable :: inverses (:) n_elements = size ( data_ ) inverses = 1_real64 / data_ harmonic_mean_ = n_elements / sum ( inverses ) end function !=============================================================================! !=                         Geometric Mean Functions                          =! !=============================================================================! function rank1_geometric_mean_r32 ( data_ ) result ( geometric_mean_ ) real ( real32 ), intent ( in ) :: data_ (:) real ( real32 ) :: geometric_mean_ !! Rank 1 array containing the elements to calculate the mean for integer :: n_elements n_elements = size ( data_ ) geometric_mean_ = nth_root ( product ( data_ ), n_elements ) end function function rank1_geometric_mean_r64 ( data_ ) result ( geometric_mean_ ) real ( real64 ), intent ( in ) :: data_ (:) real ( real64 ) :: geometric_mean_ !! Rank 1 array containing the elements to calculate the mean for integer :: n_elements n_elements = size ( data_ ) geometric_mean_ = nth_root ( product ( data_ ), n_elements ) end function function rank1_geometric_mean_i32 ( data_ ) result ( geometric_mean_ ) integer ( int32 ), intent ( in ) :: data_ (:) real ( real64 ) :: geometric_mean_ !! Rank 1 array containing the elements to calculate the mean for integer :: n_elements n_elements = size ( data_ ) geometric_mean_ = real ( product ( data_ ), real64 ) ** ( 1.0 / n_elements ) end function function rank1_geometric_mean_i64 ( data_ ) result ( geometric_mean_ ) integer ( int64 ), intent ( in ) :: data_ (:) real ( real64 ) :: geometric_mean_ !! Rank 1 array containing the elements to calculate the mean for integer :: n_elements n_elements = size ( data_ ) geometric_mean_ = nth_root ( real ( product ( data_ ), real64 ), n_elements ) end function !=============================================================================! !=                      Standard Deviation Functions                         =! !=============================================================================! function std_dev_r32 ( data ) result ( sigma ) real ( real32 ), dimension (:), intent ( in ) :: data real ( real32 ) :: sigma !! population standard deviation real ( real32 ) :: mu !! Average integer :: n_elements n_elements = size ( data ) mu = mean ( data ) sigma = sqrt ( ( sum ( ( data - mu ) ** 2 ) ) / n_elements ) end function function std_dev_r64 ( data ) result ( sigma ) real ( real64 ), dimension (:), intent ( in ) :: data real ( real64 ) :: sigma !! population standard deviation real ( real64 ) :: mu !! Average integer :: n_elements n_elements = size ( data ) mu = mean ( data ) sigma = sqrt ( ( sum ( ( data - mu ) ** 2 ) ) / n_elements ) end function function std_dev_i32 ( data_ ) result ( sigma ) integer ( int32 ), dimension (:), intent ( in ) :: data_ real ( real32 ) :: sigma !! population standard deviation real ( real32 ) :: mu !! Average integer :: n_elements n_elements = size ( data_ ) mu = mean ( data_ ) sigma = sqrt ( ( sum ( ( data_ - mu ) ** 2 ) ) / n_elements ) end function function std_dev_i64 ( data ) result ( sigma ) integer ( int64 ), dimension (:), intent ( in ) :: data real ( real64 ) :: sigma !! population standard deviation real ( real64 ) :: mu !! Average integer :: n_elements n_elements = size ( data ) mu = mean ( data ) sigma = sqrt ( ( sum ( ( data - mu ) ** 2 ) ) / n_elements ) end function end module","tags":"","loc":"sourcefile/math_stats.f90.html"},{"title":"math.f90 – Fortran Program","text":"Contents Modules foreng_math Source Code math.f90 Source Code module foreng_math !! Top level module containing math functions (sets, factorials, trig) use foreng_math_trig use foreng_math_sets use foreng_math_misc use foreng_math_stats use foreng_math_prob use foreng_math_geom end module","tags":"","loc":"sourcefile/math.f90.html"},{"title":"math_prob.f90 – Fortran Program","text":"Contents Modules foreng_math_prob Source Code math_prob.f90 Source Code module foreng_math_prob !! Contains functions used to compute probability distributions use foreng_env use foreng_math_misc implicit none !=============================================================================! !=                      Random Distribution Interface                        =! !=============================================================================! interface urand !! Return a uniform random variable from min (inclusive) to max (inclusive for integer functions, exclusive for real) module procedure urand_r32 module procedure urand_r64 module procedure urand_i32 module procedure urand_i64 end interface interface fill_urand !! Fill a rank 1, 2, or 3 array with a uniform random variable from min (inclusive) to max (inclusive for integer functions, exclusive for real) !! !! Example usage: !!```fortran !! !!integer, dimension(64) :: x_i32 !!real(real32), dimension(8, 8) :: x_r32 !!real(real64), dimension(4, 4, 4) :: x_64 !! !!call fill_urand(x_i32, 0, 10) ! Fill rank1, integer array !!call fill_urand(x_r32, -1.0, 1.0) ! Fill rank2, real(real32) array !!call fill_urand(x_r64, -10.d0, 10.d0) ! Fill rank3, real(real64) array !!``` module procedure fill_urand_rank1_r32 module procedure fill_urand_rank1_r64 module procedure fill_urand_rank1_i32 module procedure fill_urand_rank1_i64 module procedure fill_urand_rank2_r32 module procedure fill_urand_rank2_r64 module procedure fill_urand_rank2_i32 module procedure fill_urand_rank2_i64 module procedure fill_urand_rank3_r32 module procedure fill_urand_rank3_r64 module procedure fill_urand_rank3_i32 module procedure fill_urand_rank3_i64 end interface ! // TODO Add Normal distribution functions ! // TODO add documentation !=============================================================================! !=                      Random Distribution Functions                        =! !=============================================================================! contains function urand_r32 ( min , max ) result ( x ) !! Return a uniform random variable [min, max) real ( real32 ), intent ( in ) :: min !! a, inclusive real ( real32 ), intent ( in ) :: max !! b, exclusive real ( real32 ) :: x !! x \\sim \\mathcal{U}[a, b) real ( real32 ) :: temp_rand ! A value between 0 and 1 real ( real32 ), parameter :: rand_mid = 0.5 real ( real32 ) :: scale ! What we should multiply the range by real ( real32 ) :: shift ! What we should shift the dist by ! mid_point = (min + max) / 2 shift = min scale = max - min call random_number ( temp_rand ) ! print *, temp_rand ! Shift the midpoint to the midpoint of the new range x = temp_rand * scale + shift end function function urand_r64 ( min , max ) result ( x ) !! Return a uniform random variable [min, max) real ( real64 ), intent ( in ) :: min !! a, inclusive real ( real64 ), intent ( in ) :: max !! b, exclusive real ( real64 ) :: x !! x \\sim \\mathcal{U}[a, b) real ( real64 ) :: temp_rand ! A value between 0 and 1 real ( real64 ), parameter :: rand_mid = 0.5 real ( real64 ) :: scale ! What we should multiply the range by real ( real64 ) :: shift ! What we should shift the dist by ! mid_point = (min + max) / 2 shift = min scale = max - min call random_number ( temp_rand ) ! print *, temp_rand ! Shift the midpoint to the midpoint of the new range x = temp_rand * scale + shift end function function urand_i32 ( min , max ) result ( x ) !! Return a uniform random variable [min, max] integer ( int32 ), intent ( in ) :: min !! a, inclusive integer ( int32 ), intent ( in ) :: max !! b, inclusive integer ( int32 ) :: x !! x \\sim \\mathcal{U}[a, b] real ( real32 ) :: temp_rand ! A value between 0 and 1 real ( real32 ), parameter :: rand_mid = 0.5 integer ( int32 ) :: scale ! What we should multiply the range by integer ( int32 ) :: shift ! What we should shift the dist by ! mid_point = (min + max) / 2 shift = min scale = max - ( min - 1 ) call random_number ( temp_rand ) ! print *, temp_rand ! Shift the midpoint to the midpoint of the new range x = int ( temp_rand * scale + shift , int32 ) end function function urand_i64 ( min , max ) result ( x ) !! Return a uniform random variable [min, max] integer ( int64 ), intent ( in ) :: min !! a, inclusive integer ( int64 ), intent ( in ) :: max !! b, inclusive integer ( int64 ) :: x !! x \\sim \\mathcal{U}[a, b] real ( real64 ) :: temp_rand ! A value between 0 and 1 real ( real64 ), parameter :: rand_mid = 0.5 integer ( int64 ) :: scale ! What we should multiply the range by integer ( int64 ) :: shift ! What we should shift the dist by ! mid_point = (min + max) / 2 shift = min scale = max - min call random_number ( temp_rand ) ! print *, temp_rand ! Shift the midpoint to the midpoint of the new range x = int ( temp_rand * scale + shift , int64 ) end function !=============================================================================! !=                            Rank1 Fill Functions                           =! !=============================================================================! subroutine fill_urand_rank1_r32 ( A , min , max ) real ( real32 ), dimension (:), intent ( inout ) :: A real ( real32 ), intent ( in ) :: min , max integer :: i integer :: ni ni = size ( A ) do i = 1 , ni A ( i ) = urand ( min , max ) end do end subroutine subroutine fill_urand_rank1_r64 ( A , min , max ) real ( real64 ), dimension (:), intent ( inout ) :: A real ( real64 ), intent ( in ) :: min , max integer :: i integer :: ni ni = size ( A ) do i = 1 , ni A ( i ) = urand ( min , max ) end do end subroutine subroutine fill_urand_rank1_i32 ( A , min , max ) integer ( int32 ), dimension (:), intent ( inout ) :: A integer ( int32 ), intent ( in ) :: min , max integer :: i integer :: ni ni = size ( A ) do i = 1 , ni A ( i ) = urand ( min , max ) end do end subroutine subroutine fill_urand_rank1_i64 ( A , min , max ) integer ( int64 ), dimension (:), intent ( inout ) :: A integer ( int64 ), intent ( in ) :: min , max integer :: i integer :: ni ni = size ( A ) do i = 1 , ni A ( i ) = urand ( min , max ) end do end subroutine !=============================================================================! !=                            Rank2 Fill Functions                           =! !=============================================================================! subroutine fill_urand_rank2_r32 ( A , min , max ) real ( real32 ), dimension (:,:), intent ( inout ) :: A real ( real32 ), intent ( in ) :: min , max integer :: i , j integer :: ni , nj ni = size ( A , DIM = 1 ) nj = size ( A , DIM = 2 ) do i = 1 , ni do j = 1 , nj A ( i , j ) = urand ( min , max ) end do end do end subroutine subroutine fill_urand_rank2_r64 ( A , min , max ) real ( real64 ), dimension (:,:), intent ( inout ) :: A real ( real64 ), intent ( in ) :: min , max integer :: i , j integer :: ni , nj ni = size ( A , DIM = 1 ) nj = size ( A , DIM = 2 ) do i = 1 , ni do j = 1 , nj A ( i , j ) = urand ( min , max ) end do end do end subroutine subroutine fill_urand_rank2_i32 ( A , min , max ) integer ( int32 ), dimension (:,:), intent ( inout ) :: A integer ( int32 ), intent ( in ) :: min , max integer :: i , j integer :: ni , nj ni = size ( A , DIM = 1 ) nj = size ( A , DIM = 2 ) do i = 1 , ni do j = 1 , nj A ( i , j ) = urand ( min , max ) end do end do end subroutine subroutine fill_urand_rank2_i64 ( A , min , max ) integer ( int64 ), dimension (:,:), intent ( inout ) :: A integer ( int64 ), intent ( in ) :: min , max integer :: i , j integer :: ni , nj ni = size ( A , DIM = 1 ) nj = size ( A , DIM = 2 ) do i = 1 , ni do j = 1 , nj A ( i , j ) = urand ( min , max ) end do end do end subroutine !=============================================================================! !=                            Rank3 Fill Functions                           =! !=============================================================================! subroutine fill_urand_rank3_r32 ( A , min , max ) real ( real32 ), dimension (:,:,:), intent ( inout ) :: A real ( real32 ), intent ( in ) :: min , max integer :: i , j , k integer :: ni , nj , nk ni = size ( A , DIM = 1 ) nj = size ( A , DIM = 2 ) nk = size ( A , DIM = 3 ) do i = 1 , ni do j = 1 , nj do k = 1 , nk A ( i , j , k ) = urand ( min , max ) end do end do end do end subroutine subroutine fill_urand_rank3_r64 ( A , min , max ) real ( real64 ), dimension (:,:,:), intent ( inout ) :: A real ( real64 ), intent ( in ) :: min , max integer :: i , j , k integer :: ni , nj , nk ni = size ( A , DIM = 1 ) nj = size ( A , DIM = 2 ) nk = size ( A , DIM = 3 ) do i = 1 , ni do j = 1 , nj do k = 1 , nk A ( i , j , k ) = urand ( min , max ) end do end do end do end subroutine subroutine fill_urand_rank3_i32 ( A , min , max ) integer ( int32 ), dimension (:,:,:), intent ( inout ) :: A integer ( int32 ), intent ( in ) :: min , max integer :: i , j , k integer :: ni , nj , nk ni = size ( A , DIM = 1 ) nj = size ( A , DIM = 2 ) nk = size ( A , DIM = 3 ) do i = 1 , ni do j = 1 , nj do k = 1 , nk A ( i , j , k ) = urand ( min , max ) end do end do end do end subroutine subroutine fill_urand_rank3_i64 ( A , min , max ) integer ( int64 ), dimension (:,:,:), intent ( inout ) :: A integer ( int64 ), intent ( in ) :: min , max integer :: i , j , k integer :: ni , nj , nk ni = size ( A , DIM = 1 ) nj = size ( A , DIM = 2 ) nk = size ( A , DIM = 3 ) do i = 1 , ni do j = 1 , nj do k = 1 , nk A ( i , j , k ) = urand ( min , max ) end do end do end do end subroutine !=============================================================================! !=                     Poisson Distribution Functions                        =! !=============================================================================! function poisson ( k , t , lamda ) result ( P ) ! Purpose: ! !   To return the probability that the number of calls, k, is observed after a given !   time, t. ! ! Data dictionary : Declare values used inside the function integer , intent ( in ) :: k ! The number of observations in a given time real , intent ( in ) :: t ! The amount of time passed real , intent ( in ) :: lamda ! The paramater of a poisson distribution real :: P ! The probability that k observations occured in time t integer :: k_fact k_fact = factorial ( k ) P = exp ( - lamda * t ) * ((( lamda * t ) ** k ) / k_fact ) end function !=============================================================================! !=                     Normal Distribution Functions                         =! !=============================================================================! function standard_normal_rand () result ( x ) real ( real64 ) :: x real ( real64 ) :: x_1 , x_2 , r test_xs : do x_1 = urand_r64 ( - 1._real64 , 1._real64 ) x_2 = urand_r64 ( - 1._real64 , 1._real64 ) r = x_1 * x_1 + x_2 * x_2 if ( r >= 1 ) then cycle test_xs else exit test_xs end if end do test_xs x = sqrt ( ( - 2._real64 * log ( r ) ) / r ) * x_1 end function end module","tags":"","loc":"sourcefile/math_prob.f90.html"},{"title":"math_misc.f90 – Fortran Program","text":"Contents Modules foreng_math_misc Source Code math_misc.f90 Source Code module foreng_math_misc !! Miscellaneous Mathematic functions use foreng_env use foreng_math_trig !=============================================================================! !=                           Factorial Interface                             =! !=============================================================================! interface factorial !! Compute x! module procedure factorial_int16 module procedure factorial_int32 module procedure factorial_int64 module procedure factorial_int128 end interface !=============================================================================! !=                            nth Root Interface                             =! !=============================================================================! interface nth_root !! Compute \\sqrt[n]{x} module procedure nth_root_r32 module procedure nth_root_r64 end interface !=============================================================================! !=                     Infinite Series Interface                             =! !=============================================================================! interface exp_series !! Compute e&#94;x using a truncated taylor series module procedure exp_series_r32 module procedure exp_series_r64 end interface ! //TODO Add sin series functions ! // TODO add comments !=============================================================================! !=                           Factorial Functions                             =! !=============================================================================! contains recursive function factorial_int16 ( x ) result ( x_fact ) !! Recursively compute the factorial of a 16-bit integer. The max value that can be passed is 7 !! If x is less than 0 or greater 7, the function will return 0 integer ( int16 ), intent ( in ) :: x !!  0 \\leq x \\leq 7 integer ( int16 ) :: x_fact !! x! if ( x >= 8 ) then x_fact = 0 return else if ( x < 0 ) then x_fact = 0 return end if if ( x == 0 ) then x_fact = 1_int16 return end if x_fact = x * factorial ( x - 1_int16 ) end function recursive function factorial_int32 ( x ) result ( x_fact ) !! Recursively compute the factorial of a 32-bit integer. The max value that can be passed is 16 !! If x is less than 0 or greater 16, the function will return 0 integer ( int32 ), intent ( in ) :: x !!  0 \\leq x \\leq 16  integer ( int32 ) :: x_fact !! x! if ( x >= 17 ) then x_fact = 0 return else if ( x < 0 ) then x_fact = 0 return end if if ( x == 0 ) then x_fact = 1_int32 return end if x_fact = x * factorial ( x - 1_int32 ) end function recursive function factorial_int64 ( x ) result ( x_fact ) !! Recursively compute the factorial of a 64-bit integer. The max value that can be passed is 20 !! If x is less than 0 or greater 20, the function will return 0 integer ( int64 ), intent ( in ) :: x !!  0 \\leq x \\leq 20  integer ( int64 ) :: x_fact !! x! if ( x >= 21 ) then x_fact = 0 return else if ( x < 0 ) then x_fact = 0 return end if if ( x == 0 ) then x_fact = 1_int64 return end if x_fact = x * factorial ( x - 1_int64 ) end function recursive function factorial_int128 ( x ) result ( x_fact ) !! Recursively compute the factorial of a 128-bit integer [supported on gfortran]. The max value that can be passed is 33 !! If x is less than 0 or greater 33, the function will return 0 integer ( int128 ), intent ( in ) :: x !!  0 \\leq x \\leq 33  integer ( int128 ) :: x_fact !! x! if ( x >= 34 ) then x_fact = 0 return else if ( x < 0 ) then x_fact = 0 return end if if ( x == 0 ) then x_fact = 1_int128 return end if x_fact = x * factorial ( x - 1_int128 ) end function !=============================================================================! !=                     Infinite Series Functions                             =! !=============================================================================! real function exp_series_r32 ( x ) result ( exp ) !! Compute e&#94;x using a taylor series with 12 terms real ( real32 ), intent ( in ) :: x integer , parameter :: n_terms = 12 integer :: i exp = 0 do i = 0 , n_terms - 1 exp = exp + ( x ** i / factorial ( i )) end do end function real ( real64 ) function exp_series_r64 ( x ) result ( exp ) !! Calculate e&#94;x using a taylor series with 20 terms real ( real64 ), intent ( in ) :: x integer ( int64 ), parameter :: n_terms = 19 integer ( int64 ) :: i exp = 0 do i = 0 , n_terms - 1 exp = exp + ( x ** i / factorial ( i )) end do end function real function sind_series ( x_ , n_ ) result ( sin_x ) !! Compute sine using a truncated taylor series real , intent ( in ) :: x_ !! Angle in degrees integer , intent ( in ) :: n_ !! Number of terms to use integer :: i_ real :: x_rad x_rad = deg_to_rad ( x_ ) sin_x = 0 do i_ = 1 , n_ sin_x = sin_x + ( ( - 1 ) ** ( i_ - 1 ) ) * ( ( x_rad ** ( 2 * i_ - 1 )) / ( factorial (( 2 * i_ ) - 1 ))) end do end function !=============================================================================! !=                            nth Root Functions                             =! !=============================================================================! function nth_root_r32 ( x_ , n_ ) result ( root_ ) real ( real32 ), intent ( in ) :: x_ real ( real32 ) :: root_ integer , intent ( in ) :: n_ real ( real32 ), parameter :: BASE = 10 root_ = BASE ** (( 1.0 / n_ ) * log10 ( x_ )) end function function nth_root_r64 ( x_ , n_ ) result ( root_ ) real ( real64 ), intent ( in ) :: x_ real ( real64 ) :: root_ integer , intent ( in ) :: n_ real ( real64 ), parameter :: BASE = 10 root_ = BASE ** (( 1.0 / n_ ) * log10 ( x_ )) end function !=============================================================================! !=                           Fibonacci Functions                             =! !=============================================================================! integer ( int64 ) function fibonacci_loop ( n ) result ( f_n ) integer ( int64 ), intent ( in ) :: n !! Nth fibonacci to compute integer ( int64 ) :: f_n_1 , f_n_2 !! Previous two fibonacci numbers integer ( int64 ) :: i !! Looping index if ( n == 1 . or . n == 2 ) then f_n = 1 return else if ( n > 2 ) then f_n_1 = 1 f_n_2 = 1 do i = 3 , n f_n = f_n_1 + f_n_2 !! Update current F number f_n_2 = f_n_1 f_n_1 = f_n !! Update previous two numbers end do else print * , \"N must be a natural number\" end if end function end module","tags":"","loc":"sourcefile/math_misc.f90.html"},{"title":"math_geom.f90 – Fortran Program","text":"Module for use with geometry (points, vectors, lines) Contents Modules foreng_math_geom Source Code math_geom.f90 Source Code !! Module for use with geometry (points, vectors, lines) module foreng_math_geom use foreng_env use foreng_math_trig implicit none ! // TODO DOCUMENT !=============================================================================! !=                          Cross Product Interface                          =! !=============================================================================! interface cross_product module procedure cross_product_r32 module procedure cross_product_r64 end interface !=============================================================================! !=                             Point2 Interface                              =! !=============================================================================! type :: point2 !! A point object with coordinates stored in cartesian coordinates real ( real64 ) :: x real ( real64 ) :: y contains ! procedure, nopass :: from_pol => point2_from_polar_r32, point2_from_polar_r64, point2_from_polar_int procedure :: print => point2_print_cartesian procedure :: print_pol => point2_print_polar procedure :: rho => point2_rho procedure :: theta => point2_theta procedure :: to_array => point2_to_array procedure :: dist => point2_distance_between_point2 generic :: from_pol => from_pol_r32 , from_pol_r64 , from_pol_int !! This is the comment for a generic function generic :: assignment ( = ) => from_array_r32 , from_array_r64 , from_array_int generic :: operator ( + ) => add generic :: operator ( - ) => subtract_point2 , unary_minus procedure :: add => point2_plus_point2 procedure :: subtract_point2 => point2_minus_point2 procedure :: unary_minus => point2_unary_minus procedure , nopass :: from_pol_r32 => point2_from_polar_r32 procedure , nopass :: from_pol_r64 => point2_from_polar_r64 procedure , nopass :: from_pol_int => point2_from_polar_int procedure :: from_array_r32 => point2_from_array_r32 procedure :: from_array_r64 => point2_from_array_r64 procedure :: from_array_int => point2_from_array_int end type !=============================================================================! !=                             Point3 Interface                              =! !=============================================================================! type :: point3 real ( real64 ) :: x real ( real64 ) :: y real ( real64 ) :: z contains ! procedure, nopass :: from_pol => point2_from_polar_r32, point2_from_polar_r64, point2_from_polar_int procedure :: print => point3_print_cartesian procedure :: print_sph => point3_print_spherical procedure :: rho => point3_rho procedure :: theta => point3_theta procedure :: phi => point3_phi procedure :: to_array => point3_to_array procedure :: dist => point3_distance_between_point3 generic :: from_sph => from_sph_r32 , from_sph_r64 , from_sph_int !! This is the comment for a generic function ! generic :: from_array => from_array_r32, from_array_r64, from_array_int ! Operators generic :: operator ( + ) => add generic :: assignment ( = ) => from_array_r32 , from_array_r64 , from_array_int generic :: operator ( - ) => subtract ! Boung generics procedure :: add => point3_plus_point3 procedure :: subtract => point3_minus_point3 , point3_unary_minus procedure , nopass :: from_sph_r32 => point3_from_spherical_r32 procedure , nopass :: from_sph_r64 => point3_from_spherical_r64 procedure , nopass :: from_sph_int => point3_from_spherical_int procedure :: from_array_r32 => point3_from_array_r32 procedure :: from_array_r64 => point3_from_array_r64 procedure :: from_array_int => point3_from_array_int end type !=============================================================================! !=                            Vector3 Interface                              =! !=============================================================================! type :: vector3 real ( real64 ) :: x real ( real64 ) :: y real ( real64 ) :: z contains procedure :: print => vector3_print procedure :: length => vector3_magnitude procedure :: to_array => vector3_to_array ! Generics generic :: from_array => from_array_r32 , from_array_r64 , from_array_int ! Operators generic :: operator ( + ) => add_vector3 generic :: operator ( - ) => subtract_vector3 , unary_minus generic :: operator ( * ) => multiply_scalar_r32 , multiply_scalar_r64 , multiply_scalar_int generic :: operator (. dot .) => dot generic :: operator (. cross .) => cross generic :: operator (. angle .) => angle_between generic :: assignment ( = ) => from_array_r32 , from_array_r64 , from_array_int ! Bound generics procedure :: from_array_r32 => vector3_from_array_r32 procedure :: from_array_r64 => vector3_from_array_r64 procedure :: from_array_int => vector3_from_array_int procedure :: add_vector3 => vector3_plus_vector3 procedure :: multiply_scalar_r32 => vector3_times_scalar_r32 procedure :: multiply_scalar_r64 => vector3_times_scalar_r64 procedure :: multiply_scalar_int => vector3_times_scalar_int procedure :: dot => vector3_dot_vector3 procedure :: cross => vector3_cross_vector3 procedure :: angle_between => vector3_angle_between_vector3 procedure :: subtract_vector3 => vector3_minus_vector3 procedure :: unary_minus => vector3_unary_minus end type !=============================================================================! !=                              Line2 Interface                              =! !=============================================================================! type :: line2 real ( real64 ) :: m real ( real64 ) :: b contains procedure :: atx => line2_atx !! Evaluate y = mx + b for a given x procedure :: aty => line2_aty !! Evaluate y = mx + b for a given y procedure :: print => line2_print generic :: assignment ( = ) => from_two_points procedure :: from_two_points => line2_from_two_point2 end type !=============================================================================! !=                         Operator(*) Interface                             =! !=============================================================================! interface operator ( * ) module procedure scalar_times_vector3_r32 module procedure scalar_times_vector3_r64 module procedure scalar_times_vector3_int end interface contains !=============================================================================! !=                             Point2 Functions                              =! !=============================================================================! function point2_to_array ( self ) result ( array ) class ( point2 ), intent ( in ) :: self real ( real64 ), dimension ( 2 ) :: array array = [ self % x , self % y ] end function subroutine point2_from_array_r32 ( point , array ) real ( real32 ), dimension ( 2 ), intent ( in ) :: array class ( point2 ), intent ( out ) :: point point % x = array ( 1 ) point % y = array ( 2 ) end subroutine subroutine point2_from_array_r64 ( point , array ) real ( real64 ), dimension ( 2 ), intent ( in ) :: array class ( point2 ), intent ( out ) :: point point % x = array ( 1 ) point % y = array ( 2 ) end subroutine subroutine point2_from_array_int ( point , array ) integer , dimension ( 2 ), intent ( in ) :: array class ( point2 ), intent ( out ) :: point point % x = array ( 1 ) point % y = array ( 2 ) end subroutine function point2_from_polar_r32 ( rho , theta ) result ( point ) real ( real32 ), intent ( in ) :: rho real ( real32 ), intent ( in ) :: theta type ( point2 ) :: point point % x = rho * cosd ( theta ) point % y = rho * sind ( theta ) end function function point2_from_polar_r64 ( rho , theta ) result ( point ) real ( real64 ), intent ( in ) :: rho real ( real64 ), intent ( in ) :: theta type ( point2 ) :: point point % x = rho * cosd ( theta ) point % y = rho * sind ( theta ) end function function point2_from_polar_int ( rho , theta ) result ( point ) integer , intent ( in ) :: rho integer , intent ( in ) :: theta type ( point2 ) :: point point % x = rho * cosd ( real ( theta , real64 )) point % y = rho * sind ( real ( theta , real64 )) end function subroutine point2_print_cartesian ( self ) class ( point2 ), intent ( in ) :: self print 1 , self % x , self % y 1 format ( \"(\" , G11 . 5 , \",\" G11 . 5 , \")\" ) end subroutine subroutine point2_print_polar ( self ) !! Print the polar coordinates of a point in this form class ( point2 ), intent ( in ) :: self print 1 , self % rho (), self % theta () 1 format ( \"(\" , G11 . 5 , \",\" G11 . 5 , \")\" ) end subroutine function point2_rho ( self ) result ( rho ) !! Calculate the magnitude (distance from the origin) of class ( point2 ), intent ( in ) :: self real ( real64 ) :: rho rho = sqrt ( self % x ** 2 + self % y ** 2 ) end function function point2_theta ( self ) result ( theta ) !! Return the angle (in degrees) of the polar representation of a point class ( point2 ), intent ( in ) :: self real ( real64 ) :: theta theta = rad_to_deg ( atan2 ( self % y , self % x )) end function function point2_plus_point2 ( self , p2 ) result ( p3 ) class ( point2 ), intent ( in ) :: self , p2 type ( point2 ) :: p3 p3 = point2 ( self % x + p2 % x , self % y + p2 % y ) end function point2_minus_point2 ( self , p2 ) result ( p3 ) class ( point2 ), intent ( in ) :: self , p2 type ( point2 ) :: p3 p3 = point2 ( self % x - p2 % x , self % y - p2 % y ) end function point2_unary_minus ( self ) result ( p3 ) class ( point2 ), intent ( in ) :: self type ( point2 ) :: p3 p3 = point2 ( - self % x , - self % y ) end function point2_distance_between_point2 ( self , p2 ) result ( dist ) class ( point2 ), intent ( in ) :: self class ( point2 ), intent ( in ) :: p2 real ( real64 ) :: dist dist = sqrt ( ( self % x - p2 % x ) ** 2 + ( self % y - p2 % y ) ** 2 ) end function !=============================================================================! !=                             Point3 Functions                              =! !=============================================================================! function point3_to_array ( self ) result ( array ) class ( point3 ), intent ( in ) :: self real ( real64 ), dimension ( 3 ) :: array array = [ self % x , self % y , self % z ] end function subroutine point3_from_array_r32 ( point , array ) real ( real32 ), dimension ( 3 ), intent ( in ) :: array class ( point3 ), intent ( out ) :: point point % x = array ( 1 ) point % y = array ( 2 ) point % z = array ( 3 ) end subroutine subroutine point3_from_array_r64 ( point , array ) real ( real64 ), dimension ( 3 ), intent ( in ) :: array class ( point3 ), intent ( out ) :: point point % x = array ( 1 ) point % y = array ( 2 ) point % z = array ( 3 ) end subroutine subroutine point3_from_array_int ( point , array ) integer , dimension ( 3 ), intent ( in ) :: array class ( point3 ), intent ( out ) :: point point % x = array ( 1 ) point % y = array ( 2 ) point % z = array ( 3 ) end subroutine function point3_from_spherical_r32 ( rho , theta , phi ) result ( point ) real ( real32 ), intent ( in ) :: rho real ( real32 ), intent ( in ) :: theta real ( real32 ), intent ( in ) :: phi type ( point3 ) :: point point % x = rho * cosd ( phi ) * sind ( theta ) point % y = rho * sind ( phi ) * sind ( theta ) point % z = rho * cosd ( theta ) end function function point3_from_spherical_r64 ( rho , theta , phi ) result ( point ) real ( real64 ), intent ( in ) :: rho real ( real64 ), intent ( in ) :: theta real ( real64 ), intent ( in ) :: phi type ( point3 ) :: point point % x = rho * cosd ( phi ) * sind ( theta ) point % y = rho * sind ( phi ) * sind ( theta ) point % z = rho * cosd ( theta ) end function function point3_from_spherical_int ( rho , theta , phi ) result ( point ) integer , intent ( in ) :: rho integer , intent ( in ) :: theta integer , intent ( in ) :: phi type ( point3 ) :: point point % x = rho * cosd ( real ( phi , real64 )) * sind ( real ( theta , real64 )) point % y = rho * sind ( real ( phi , real64 )) * sind ( real ( theta , real64 )) point % z = rho * cosd ( real ( theta , real64 )) end function subroutine point3_print_cartesian ( self ) class ( point3 ), intent ( in ) :: self print 1 , self % x , self % y , self % z 1 format ( \"(\" , G11 . 5 , \",\" G11 . 5 , \",\" G11 . 5 , \")\" ) end subroutine subroutine point3_print_spherical ( self ) !! Print the polar coordinates of a point in this form class ( point3 ), intent ( in ) :: self print 1 , self % rho (), self % theta (), self % phi () 1 format ( \"(\" , G11 . 5 , \",\" G11 . 5 , \",\" G11 . 5 , \")\" ) end subroutine function point3_rho ( self ) result ( rho ) !! Calculate the magnitude (distance from the origin) of class ( point3 ), intent ( in ) :: self real ( real64 ) :: rho rho = sqrt ( self % x ** 2 + self % y ** 2 + self % z ** 2 ) end function function point3_theta ( self ) result ( theta ) !! Return the inlination theta class ( point3 ), intent ( in ) :: self real ( real64 ) :: theta theta = rad_to_deg ( acos ( self % z / self % rho () ) ) end function function point3_phi ( self ) result ( phi ) !! return the azimuth phi class ( point3 ), intent ( in ) :: self real ( real64 ) :: phi phi = rad_to_deg ( atan2 ( self % y , self % x )) end function function point3_plus_point3 ( self , p2 ) result ( p3 ) class ( point3 ), intent ( in ) :: self , p2 type ( point3 ) :: p3 p3 = point3 ( self % x + p2 % x , self % y + p2 % y , self % z + p2 % z ) end function function point3_minus_point3 ( self , p2 ) result ( p3 ) class ( point3 ), intent ( in ) :: self , p2 type ( point3 ) :: p3 p3 = point3 ( self % x - p2 % x , self % y - p2 % y , self % z - p2 % z ) end function point3_unary_minus ( self ) result ( p3 ) class ( point3 ), intent ( in ) :: self type ( point3 ) :: p3 p3 = point3 ( - self % x , - self % y , - self % z ) end function point3_dot_point3 ( self , p2 ) result ( dot ) class ( point3 ), intent ( in ) :: self , p2 real ( real64 ) :: dot dot = self % x * p2 % x + self % y * p2 % y + self % z * p2 % z end function function point3_cross_point3 ( self , p2 ) result ( p3 ) class ( point3 ), intent ( in ) :: self , p2 type ( point3 ) :: p3 p3 = cross_product ( self % to_array (), p2 % to_array ()) end function function point3_distance_between_point3 ( self , p2 ) result ( dist ) class ( point3 ), intent ( in ) :: self class ( point3 ), intent ( in ) :: p2 real ( real64 ) :: dist dist = sqrt ( ( self % x - p2 % x ) ** 2 + ( self % y - p2 % y ) ** 2 + ( self % z - p2 % z ) ** 2 ) end function !=============================================================================! !=                             Vector3 Functions                             =! !=============================================================================! subroutine vector3_print ( self ) class ( vector3 ), intent ( in ) :: self print 1 , self % x , self % y , self % z 1 format ( \"(\" , G11 . 5 , \",\" G11 . 5 , \",\" G11 . 5 , \")\" ) end subroutine function vector3_magnitude ( self ) result ( length ) class ( vector3 ), intent ( in ) :: self real ( real64 ) :: length length = sqrt ( self % x ** 2 + self % y ** 2 + self % z ** 2 ) end function function vector3_to_array ( self ) result ( array ) class ( vector3 ), intent ( in ) :: self real ( real64 ), dimension ( 3 ) :: array array = [ self % x , self % y , self % z ] end function subroutine vector3_from_array_r32 ( vector , array ) real ( real32 ), dimension ( 3 ), intent ( in ) :: array class ( vector3 ), intent ( out ) :: vector vector % x = array ( 1 ) vector % y = array ( 2 ) vector % z = array ( 3 ) end subroutine subroutine vector3_from_array_r64 ( vector , array ) real ( real64 ), dimension ( 3 ), intent ( in ) :: array class ( vector3 ), intent ( out ) :: vector vector % x = array ( 1 ) vector % y = array ( 2 ) vector % z = array ( 3 ) end subroutine subroutine vector3_from_array_int ( vector , array ) integer , dimension ( 3 ), intent ( in ) :: array class ( vector3 ), intent ( out ) :: vector vector % x = array ( 1 ) vector % y = array ( 2 ) vector % z = array ( 3 ) end subroutine function vector3_plus_vector3 ( self , v2 ) result ( v3 ) class ( vector3 ), intent ( in ) :: self , v2 type ( vector3 ) :: v3 v3 = vector3 ( self % x + v2 % x , self % y + v2 % y , self % z + v2 % z ) end function function vector3_minus_vector3 ( self , v2 ) result ( v3 ) class ( vector3 ), intent ( in ) :: self , v2 type ( vector3 ) :: v3 v3 = vector3 ( self % x - v2 % x , self % y - v2 % y , self % z - v2 % z ) end function function vector3_unary_minus ( self ) result ( v3 ) class ( vector3 ), intent ( in ) :: self type ( vector3 ) :: v3 v3 = vector3 ( - self % x , - self % y , - self % z ) end function function vector3_times_scalar_r32 ( self , k ) result ( v2 ) class ( vector3 ), intent ( in ) :: self real ( real32 ), intent ( in ) :: k type ( vector3 ) :: v2 v2 = vector3 ( self % x * k , self % y * k , self % z * k ) end function function vector3_times_scalar_r64 ( self , k ) result ( v2 ) class ( vector3 ), intent ( in ) :: self real ( real64 ), intent ( in ) :: k type ( vector3 ) :: v2 v2 = vector3 ( self % x * k , self % y * k , self % z * k ) end function function vector3_times_scalar_int ( self , k ) result ( v2 ) class ( vector3 ), intent ( in ) :: self integer , intent ( in ) :: k type ( vector3 ) :: v2 v2 = vector3 ( self % x * k , self % y * k , self % z * k ) end function function scalar_times_vector3_r32 ( k , v1 ) result ( v2 ) class ( vector3 ), intent ( in ) :: v1 real ( real32 ), intent ( in ) :: k type ( vector3 ) :: v2 v2 = vector3 ( v1 % x * k , v1 % y * k , v1 % z * k ) end function function scalar_times_vector3_r64 ( k , v1 ) result ( v2 ) class ( vector3 ), intent ( in ) :: v1 real ( real64 ), intent ( in ) :: k type ( vector3 ) :: v2 v2 = vector3 ( v1 % x * k , v1 % y * k , v1 % z * k ) end function function scalar_times_vector3_int ( k , v1 ) result ( v2 ) class ( vector3 ), intent ( in ) :: v1 integer , intent ( in ) :: k type ( vector3 ) :: v2 v2 = vector3 ( v1 % x * k , v1 % y * k , v1 % z * k ) end function function vector3_dot_vector3 ( self , v2 ) result ( dot ) class ( vector3 ), intent ( in ) :: self class ( vector3 ), intent ( in ) :: v2 real ( real64 ) :: dot dot = self % x * v2 % x + self % y * v2 % y + self % z * v2 % z end function function vector3_cross_vector3 ( self , v2 ) result ( normal ) class ( vector3 ), intent ( in ) :: self class ( vector3 ), intent ( in ) :: v2 type ( vector3 ) :: normal normal = cross_product ( self % to_array (), v2 % to_array ()) end function function vector3_angle_between_vector3 ( self , v2 ) result ( theta ) !! Return angle between vectors in degrees class ( vector3 ), intent ( in ) :: self class ( vector3 ), intent ( in ) :: v2 real ( real64 ) :: theta theta = deg_to_rad ( acos ( ( self . dot . v2 ) / ( self % length () * v2 % length () ) ) ) end function !=============================================================================! !=                              Other Functions                              =! !=============================================================================! function cross_product_r32 ( v1 , v2 ) result ( normal ) real , dimension ( 3 ), intent ( in ) :: v1 , v2 !! Vectors to cross multiply real , dimension ( 3 ) :: normal !! Normal vector that is the output normal ( 1 ) = v1 ( 2 ) * v2 ( 3 ) - v2 ( 2 ) * v1 ( 3 ) normal ( 2 ) = v1 ( 3 ) * v2 ( 1 ) - v2 ( 3 ) * v1 ( 1 ) normal ( 3 ) = v1 ( 1 ) * v2 ( 2 ) - v2 ( 1 ) * v1 ( 2 ) end function function cross_product_r64 ( v1 , v2 ) result ( normal ) real ( real64 ), dimension ( 3 ), intent ( in ) :: v1 , v2 !! Vectors to cross multiply real ( real64 ), dimension ( 3 ) :: normal !! Normal vector that is the output normal ( 1 ) = v1 ( 2 ) * v2 ( 3 ) - v2 ( 2 ) * v1 ( 3 ) normal ( 2 ) = v1 ( 3 ) * v2 ( 1 ) - v2 ( 3 ) * v1 ( 1 ) normal ( 3 ) = v1 ( 1 ) * v2 ( 2 ) - v2 ( 1 ) * v1 ( 2 ) end function real function distance ( p1 , p2 ) result ( d1 ) real , dimension ( 3 ), intent ( in ) :: p1 , p2 !! Points to calculate distance between d1 = sqrt (( p1 ( 1 ) - p2 ( 1 )) ** 2 + ( p1 ( 2 ) - p2 ( 2 )) ** 2 + ( p1 ( 3 ) - p2 ( 3 )) ** 2 ) end function !=============================================================================! !=                              Line2 Functions                              =! !=============================================================================! function line2_atx ( self , x ) result ( y ) class ( line2 ), intent ( in ) :: self real ( real64 ), intent ( in ) :: x real ( real64 ) :: y y = self % m * x + self % b end function function line2_aty ( self , y ) result ( x ) class ( line2 ), intent ( in ) :: self real ( real64 ), intent ( in ) :: y real ( real64 ) :: x x = ( y - self % b ) / self % m end function subroutine line2_from_two_point2 ( line , two_points ) class ( point2 ), dimension ( 2 ), intent ( in ), target :: two_points type ( point2 ), pointer :: p1 , p2 class ( line2 ), intent ( out ) :: line p1 => two_points ( 1 ) p2 => two_points ( 2 ) print * , \"p1 = \" , p1 print * , \"p2 = \" , p2 line % m = ( p2 % y - p1 % y ) / ( p2 % x - p1 % x ) line % b = p1 % y - ( p1 % x * line % m ) end subroutine subroutine line2_print ( self ) class ( line2 ), intent ( in ) :: self print 1 , self % m , self % b 1 format ( \"y = \" , G11 . 5 , \"x + \" , G11 . 5 ) end subroutine end module","tags":"","loc":"sourcefile/math_geom.f90.html"},{"title":"math_sets.f90 – Fortran Program","text":"Contents Modules foreng_math_sets Source Code math_sets.f90 Source Code module foreng_math_sets !! Contains functions that deal with the mathematical definition of sets. Find the union of two rank 1 arrays with \\verb|union|. Find !! the intersection with \\verb|intersection|. Check if a given x belongs to a set with \\verb|belongs_to| use foreng_env implicit none !=============================================================================! !=                               Set Interface                               =! !=============================================================================! interface intersection !! Compute the intersection of two sets module procedure intersection_int module procedure intersection_r32 module procedure intersection_r64 end interface interface union !! Compute the union of two sets module procedure union_int module procedure union_r32 module procedure union_r64 end interface interface belongs_to !! Check if x \\in \\textrm{A} <br> !! x belongs to A if there is at least one element y in A for which x = y module procedure belongs_to_int module procedure belongs_to_r32 module procedure belongs_to_r64 end interface interface array_epsilon module procedure array_epsilon_r32 module procedure array_epsilon_r64 end interface interface abs_max_val module procedure abs_max_val_r32 module procedure abs_max_val_r64 end interface !=============================================================================! !=                               Set Functions                               =! !=============================================================================! contains function intersection_int ( A , B ) result ( inters ) integer , dimension (:), intent ( in ) :: A !! set A integer , dimension (:), intent ( in ) :: B !! set B integer , dimension (:), allocatable :: inters !!  A \\cap B integer :: A_card integer :: i integer :: zero = 0 A_card = size ( A ) do i = 1 , A_card if ( belongs_to ( A ( i ), B )) then ! If element of set1 is ALSO in set2... if ( allocated ( inters )) then inters = [ inters , A ( i )] else allocate ( inters ( 1 )) inters = A ( i ) end if else cycle end if end do if (. not . allocated ( inters )) then ! If the intersection is the empty set allocate ( inters ( 1 )) inters = zero / zero end if end function function intersection_r32 ( A , B ) result ( inters ) real ( real32 ), dimension (:), intent ( in ) :: A !! set A real ( real32 ), dimension (:), intent ( in ) :: B !! set B real ( real32 ), dimension (:), allocatable :: inters !!  A \\cap B integer :: A_card integer :: i real ( real32 ) :: zero = 0 real ( real32 ) :: eps eps = array_epsilon ([ A , B ]) A_card = size ( A ) do i = 1 , A_card if ( belongs_to ( A ( i ), B , eps )) then ! If element of set1 is ALSO in set2... if ( allocated ( inters )) then inters = [ inters , A ( i )] else allocate ( inters ( 1 )) inters = A ( i ) end if else cycle end if end do if (. not . allocated ( inters )) then ! If the intersection is the empty set allocate ( inters ( 1 )) inters = zero / zero end if end function function intersection_r64 ( A , B ) result ( inters ) real ( real64 ), dimension (:), intent ( in ) :: A !! set A real ( real64 ), dimension (:), intent ( in ) :: B !! set B real ( real64 ), dimension (:), allocatable :: inters !!  A \\cap B integer :: A_card integer :: i real ( real64 ) :: zero = 0 real ( real64 ) :: eps eps = array_epsilon ([ A , B ]) A_card = size ( A ) do i = 1 , A_card if ( belongs_to ( A ( i ), B , eps )) then ! If element of set1 is ALSO in set2... if ( allocated ( inters )) then inters = [ inters , A ( i )] else allocate ( inters ( 1 )) inters = A ( i ) end if else cycle end if end do if (. not . allocated ( inters )) then ! If the intersection is the empty set allocate ( inters ( 1 )) inters = zero / zero end if end function function union_int ( A , B ) result ( union_set ) integer , intent ( in ), dimension (:) :: A !! set A integer , intent ( in ), dimension (:) :: B !! set B integer , dimension (:), allocatable :: union_set !!  A \\cup B integer :: B_cardinality integer :: i B_cardinality = size ( B ) ! Set union right away to A union_set = A do i = 1 , B_cardinality if ( belongs_to ( B ( i ), union_set )) then ! If set2(i) is already a part of the union, then don't add it cycle else union_set = [ union_set , B ( i )] end if end do end function function union_r32 ( A , B ) result ( union_set ) real ( real32 ), intent ( in ), dimension (:) :: A !! set A real ( real32 ), intent ( in ), dimension (:) :: B !! set B real ( real32 ), dimension (:), allocatable :: union_set !!  A \\cup B integer :: B_cardinality integer :: i B_cardinality = size ( B ) ! Set union right away to A union_set = A do i = 1 , B_cardinality if ( belongs_to ( B ( i ), union_set )) then ! If set2(i) is already a part of the union, then don't add it print * , \"MATCH FOUND!!\" cycle else union_set = [ union_set , B ( i )] end if end do end function function union_r64 ( A , B ) result ( union_set ) real ( real64 ), intent ( in ), dimension (:) :: A !! set A real ( real64 ), intent ( in ), dimension (:) :: B !! set B real ( real64 ), dimension (:), allocatable :: union_set !!  A \\cup B integer :: B_cardinality integer :: i B_cardinality = size ( B ) ! Set union right away to A union_set = A do i = 1 , B_cardinality if ( belongs_to ( B ( i ), union_set )) then ! If set2(i) is already a part of the union, then don't add it cycle else union_set = [ union_set , B ( i )] end if end do end function logical function belongs_to_int ( x , A ) result ( bool ) !! Check if a value x belongs to a set \\textrm{A} integer , intent ( in ) :: x integer , dimension (:) :: A ! Check if an element belongs to a set integer :: cardinality ! Cardinality (size) of the set to check integer :: i cardinality = size ( A ) do i = 1 , cardinality bool = . false . if ( A ( i ) == x ) then bool = . true . return else cycle end if end do end function logical function belongs_to_r32 ( x , A , eps ) result ( bool ) !! Check if a value x belongs to a set within a certain tolerance \\epsilon. If \\epsilon is not specified, it will automatically !! calculated using the \\verb|array_epsilon| function real ( real32 ), intent ( in ) :: x real ( real32 ), dimension (:) :: A real ( real32 ), optional :: eps !! x = y \\iff \\textrm{abs}(x - y) < \\epsilon ! Check if an element belongs to a set integer :: cardinality ! Cardinality (size) of the set to check integer :: i real ( real32 ) :: eps_ if (. not . present ( eps )) then eps_ = array_epsilon ( A ) else eps_ = eps end if cardinality = size ([ A , x ]) do i = 1 , cardinality bool = . false . if ( abs ( A ( i ) - x ) <= eps_ ) then bool = . true . return else cycle end if end do end function logical function belongs_to_r64 ( x , A , eps ) result ( bool ) !! Check if a value x belongs to a set within a certain tolerance \\epsilon. If \\epsilon is not specified, it will automatically !! calculated using the \\verb|array_epsilon| function real ( real64 ), intent ( in ) :: x real ( real64 ), dimension (:) :: A real ( real64 ), optional :: eps !! x = y \\iff \\textrm{abs}(x - y) < \\epsilon ! Check if an element belongs to a set integer :: cardinality ! Cardinality (size) of the set to check integer :: i if (. not . present ( eps )) then eps = array_epsilon ([ A , x ]) end if cardinality = size ( A ) do i = 1 , cardinality bool = . false . if ( abs ( A ( i ) - x ) < eps ) then bool = . true . return else cycle end if end do end function real ( real32 ) function array_epsilon_r32 ( array ) result ( eps ) real ( real32 ), dimension (:), intent ( in ) :: array real ( real32 ) :: max_val max_val = abs_max_val ( array ) eps = epsilon ( max_val ) end function real ( real64 ) function array_epsilon_r64 ( array ) result ( eps ) real ( real64 ), dimension (:), intent ( in ) :: array real ( real64 ) :: max_val max_val = abs_max_val ( array ) eps = epsilon ( max_val ) end function real ( real32 ) function abs_max_val_r32 ( array ) result ( abs_max_val ) real ( real32 ), dimension (:), intent ( in ) :: array abs_max_val = maxval ( abs ( array )) end function real ( real64 ) function abs_max_val_r64 ( array ) result ( abs_max_val ) real ( real64 ), dimension (:), intent ( in ) :: array abs_max_val = maxval ( abs ( array )) end function end module","tags":"","loc":"sourcefile/math_sets.f90.html"},{"title":"demo.f90 – Fortran Program","text":"Contents Programs demo Source Code demo.f90 Source Code program demo use chapter_4 use chapter_5 use chapter_6 use chapter_7 integer :: i = 0 , j = 0 , ierr character ( 100 ) :: errmsg real :: p7_6_real = 1.0 print * ! empty line print 123 print 121 , \"| Fortran for Engineers demo suite - Evan Voyles |\" print 123 121 format ( T16 , a ) 123 format ( T16 , 50 ( \"-\" )) mainloop : do call chapter_select () print * , \"[4] Chapter 4: Loops & Character Manipulation\" print * , \"[5] Chapter 5: Basic IO\" print * , \"[6] Chapter 6: Arrays\" print * , \"[7] Chapter 7: Procedures\" print * , \"[8] Chapter 8: Additional Features of Arrays\" print * , \"[9] Chapter 9: Additional Features of Procedures\" print * , \"[10] Chapter 10: Character Variables\" print * print * , \"0 to exit\" read ( unit = 5 , fmt =* , iostat = ierr , iomsg = errmsg ) i if ( ierr /= 0 ) then print * , \"please enter a valid integer from [0:10]\" cycle mainloop end if select case ( i ) case ( 4 ) call chapter_selected ( i ) chapter4 : do print * , \"Problem 1: Legal expressions\" print * , \"Problem 2: Squares of even integers\" print * , \"Problem 3: Function evaluation\" print * , \"Problem 4: Piecewise function evaluation\" print * , \"Problem 5: Factorial\" print * , \"Problem 6: Difference between CYCLE and EXIT\" print * , \"Problem 7: Simple statistics\" print * , \"Problem 8: Loop execution counts\" print * , \"Problem 9: Loop execution values\" print * , \"Problem 10: Loop execution values (pt II)\" print * , \"Problem 11: Flight of ball\" print * , \"Problem 12: Flight of ball (pt II)\" print * , \"Problem 13: Day of the year\" print * , \"Problem 14: Logarithmic function evaluation\" print * , \"Problem 15: Uppercase to lowercase\" print * , \"Problem 16: Calculating orbits\" print * , \"Problem 17: Capitalize first letter\" print * , \"Problem 18: Current through a diode\" print * , \"Problem 19: Binary to decimal\" call problem_select () read ( unit = 5 , fmt =* , iostat = ierr , iomsg = errmsg ) j if ( ierr /= 0 ) then print * , \"please enter a valid integer from [-1:19]\" cycle chapter4 end if call program_start () select case ( j ) case ( 1 ) call p4_1 () case ( 2 ) print * , \"Problem 2 selected\" case ( 3 ) call p4_3 () case ( 4 ) call p4_4 () case ( 5 ) call p4_5 () case ( 6 ) call p4_6 () case ( 7 ) call p4_7 () case ( 8 ) call p4_8 () case ( 9 ) call p4_9 () case ( 10 ) call p4_10 () case ( 11 ) call p4_11 () case ( 12 ) call p4_12 () case ( 13 ) call p4_13 () case ( 14 ) call p4_14 () case ( 15 ) call p4_15 () case ( 16 ) call p4_16 () case ( 17 ) call p4_17 () case ( 18 ) call p4_18 () case ( 19 ) call p4_19 () case ( - 1 ) print * , \"Going to chapter select\" exit chapter4 case ( 0 ) print * , \"Exiting demo\" exit mainloop case default print * , \"Please enter a valid number 1-19, -1 to go back, or 0 to exit\" end select call program_end () end do chapter4 case ( 5 ) call chapter_selected ( i ) chapter5 : do print * , \"Problem 1: What is the purpose of a format?\" print * , \"Problem 2: What is printed?\" print * , \"Problem 3: What is printed? (pt II)\" print * , \"Problem 4: For 5_4.dat, what is read in?\" print * , \"Problem 5: For 5_5.dat, what is read in?\" print * , \"Problem 6: Table of logarithms\" ! print *, \"Problem 7: Simple statistics\" ! print *, \"Problem 8: Loop execution counts\" ! print *, \"Problem 9: Loop execution values\" ! print *, \"Problem 10: Loop execution values (pt II)\" ! print *, \"Problem 11: Flight of ball\" ! print *, \"Problem 12: Flight of ball (pt II)\" ! print *, \"Problem 13: Day of the year\" ! print *, \"Problem 14: Logarithmic function evaluation\" ! print *, \"Problem 15: Uppercase to lowercase\" ! print *, \"Problem 16: Calculating orbits\" ! print *, \"Problem 17: Capitalize first letter\" ! print *, \"Problem 18: Current through a diode\" ! print *, \"Problem 19: Binary to decimal\" call problem_select () read ( unit = 5 , fmt =* , iostat = ierr , iomsg = errmsg ) j if ( ierr /= 0 ) then print * , \"please enter a valid integer from [-1:19]\" cycle chapter5 end if call program_start () select case ( j ) case ( 1 ) call p5_1 () case ( 2 ) call p5_2 () case ( 3 ) call p5_3 () case ( 4 ) call p5_4 ( \"5_4.dat\" ) case ( 5 ) call p5_5 ( \"5_5.dat\" ) case ( 6 ) call p5_6 () ! case(7) !     call p4_7() ! case(8) !     call p4_8() ! case(9) !     call p4_9() ! case(10) !     call p4_10() ! case(11) !     call p4_11() ! case(12) !     call p4_12() ! case(13) !     call p4_13() ! case(14) !     call p4_14() ! case(15) !     call p4_15() ! case(16) !     call p4_16() ! case(17) !     call p4_17() ! case(18) !     call p4_18() ! case(19) !     call p4_19() case ( - 1 ) print * , \"Going to chapter select\" exit chapter5 case ( 0 ) print * , \"Exiting demo\" exit mainloop case default print * , \"Please enter a valid number 1-6, -1 to go back, or 0 to exit\" end select call program_end () end do chapter5 case ( 6 ) call chapter_selected ( i ) chapter6 : do print * , \"Problem 6: Array Terminology\" print * , \"Problem 10: Polar to Rectangular Conversion\" print * , \"Problem 11: Rectangular to Polar Conversion\" ! print *, \"Problem 12: Flight of ball (pt II)\" ! print *, \"Problem 13: Day of the year\" ! print *, \"Problem 14: Logarithmic function evaluation\" ! print *, \"Problem 15: Uppercase to lowercase\" ! print *, \"Problem 16: Calculating orbits\" ! print *, \"Problem 17: Capitalize first letter\" ! print *, \"Problem 18: Current through a diode\" ! print *, \"Problem 19: Binary to decimal\" call problem_select () read ( unit = 5 , fmt =* , iostat = ierr , iomsg = errmsg ) j if ( ierr /= 0 ) then print * , \"please enter a valid integer from [-1:19]\" cycle chapter6 end if call program_start () select case ( j ) ! case(1) !     call p4_1() ! case(2) !     print *, \"Problem 2 selected\" ! case(3) !     call p4_3() ! case(4) !     call p4_4() ! case(5) !     call p4_5() case ( 6 ) call p6_6 () ! case(7) !     call p4_7() ! case(8) !     call p4_8() ! case(9) !     call p4_9() case ( 10 ) call p6_10 () case ( 11 ) call p6_11 () ! case(12) !     call p4_12() ! case(13) !     call p4_13() ! case(14) !     call p4_14() ! case(15) !     call p4_15() ! case(16) !     call p4_16() ! case(17) !     call p4_17() ! case(18) !     call p4_18() ! case(19) !     call p4_19() case ( - 1 ) print * , \"Going to chapter select\" exit chapter6 case ( 0 ) print * , \"Exiting demo\" exit mainloop case default print * , \"Please enter a valid number 6, 10, or 11, -1 to go back, or 0 to exit\" end select call program_end () end do chapter6 ! // TODO ADD ALL OTHER CHAPTERS case ( 7 ) call chapter_selected ( i ) chapter7 : do print * , \"Problem 1: Difference between subroutine and function\" print * , \"Problem 2: How is data passed in Fortran procedures?\" print * , \"Problem 3: Advantages and disadvantages of pass-by-reference?\" print * , \"Problem 4: How can arrays be declared as dummy variables?\" print * , \"Problem 5: Array error-bound subscripting\" print * , \"Problem 6: Pass REAL value to INTEGER subroutine\" print * , \"Problem 7: Check mismateched arguments in Problem 6\" print * , \"Problem 8: Loop execution counts\" print * , \"Problem 9: Loop execution values\" print * , \"Problem 10: Loop execution values (pt II)\" print * , \"Problem 11: Flight of ball\" print * , \"Problem 12: Flight of ball (pt II)\" print * , \"Problem 13: Day of the year\" print * , \"Problem 14: Logarithmic function evaluation\" print * , \"Problem 15: Uppercase to lowercase\" print * , \"Problem 16: Calculating orbits\" print * , \"Problem 17: Capitalize first letter\" print * , \"Problem 18: Current through a diode\" print * , \"Problem 19: Binary to decimal\" print * , \"Problem 20: Loop execution counts\" print * , \"Problem 21: Loop execution values\" print * , \"Problem 22: Loop execution values (pt II)\" print * , \"Problem 23: Flight of ball\" print * , \"Problem 24: Flight of ball (pt II)\" print * , \"Problem 25: Day of the year\" print * , \"Problem 26: Logarithmic function evaluation\" print * , \"Problem 27: Uppercase to lowercase\" call problem_select () read ( unit = 5 , fmt =* , iostat = ierr , iomsg = errmsg ) j if ( ierr /= 0 ) then print * , \"please enter a valid integer from [-1:19]\" cycle chapter7 end if call program_start () select case ( j ) case ( 1 ) call p7_1 () case ( 2 ) call p7_2 () case ( 3 ) call p7_3 () case ( 4 ) call p7_4 () case ( 5 ) call p7_5 () case ( 6 ) call p7_6 () case ( 7 ) call p7_7 () case ( 8 ) call p4_8 () case ( 9 ) call p4_9 () case ( 10 ) call p4_10 () case ( 11 ) call p4_11 () case ( 12 ) call p4_12 () case ( 13 ) call p4_13 () case ( 14 ) call p4_14 () case ( 15 ) call p4_15 () case ( 16 ) call p4_16 () case ( 17 ) call p4_17 () case ( 18 ) call p4_18 () case ( 19 ) call p4_19 () case ( - 1 ) print * , \"Going to chapter select\" exit chapter7 case ( 0 ) print * , \"Exiting demo\" exit mainloop case default print * , \"Please enter a valid number 1-19, -1 to go back, or 0 to exit\" end select call program_end () end do chapter7 case ( 8 ) print * , \"Chapter 8 selected\" case ( 9 ) print * , \"Chapter 9 selected\" case ( 10 ) print * , \"Chapter 10 selected\" case ( 11 ) print * , \"Chapter 11 selected\" case ( 12 ) print * , \"Chapter 12 selected\" case ( 13 ) print * , \"Chapter 13 selected\" case ( 14 ) print * , \"Chapter 14 selected\" case ( 15 ) print * , \"Chapter 15 selected\" case ( 16 ) print * , \"Chapter 16 selected\" case ( 17 ) print * , \"Chapter 17 selected\" case ( 0 ) print * , \"Exiting succesfully\" exit mainloop case default print * , \"Please enter a number 1-17\" end select ! print*, \"Example 1: Demo for xy plot\" ! print*, \"Example 2: Line specification\" ! print*, \"Example 3: Plot several data series at the same time\" ! print*, \"Example 4: Plot four data series at the same time\" ! print*, \"Example 5: Use line style, line colors and more...\" ! print*, \"Example 6: An interesting plot, sin(x) and its zero on the same plot\" ! print*, \"Example 7: Plot a matrix against a vector\" ! print*, \"Example 8: Plot a matrix against a vector and set the linespec and legend\" ! print*, \"Example 9: Use gnuplot for animation\" ! print*, \"Example 10: Use ogpf options\" ! print*, \"Example 11: simple polar plot\" ! print*, \"Example 12: A plot with logarithmic x axis\" ! print*, \"Example 13: A matrix plot with logarithmic y axis\" ! print*, \"Example 14: A loglog plot\" ! print*, \"Example 15: Plotting a function\" ! print*, \"Example 16: Save the gnuplot script into a file for future use\" ! print*, \"Example 17: Multi window plots, using script\" ! print*, \"Example 18: Running an external script file\" ! print*, \"Example 19: Multiple linestyle in matrix plot\" ! print*, \"Example 20: Scatter plot\" ! print*, \"Example 21: Stem plot\" ! print*, \"Example 22: Stem plot animation\" ! print*, \"Example 23: Another animation using matrix plot\" ! print*, \"Example 24: Multiplot layout\" ! print*, \"Example 25: Multiplot layout followed by simple plot\" ! print*, \"Example 26: Plot matrix vs. matrix\" ! print*, \"Example 27: Using secondary y axis\" ! print*, \"Example 28: Using secondary x and y axis\" ! print*, \"Example 29: Using color and size for title and labels\" ! print*, \"Example 30: More on labels color and size with secondary axes\" ! print* ! print*, \"***   Surface and Contour Plots ***\" ! print* ! print*, \"Example 101: Simple 3D plot using surf\" ! print*, \"Example 102: Surface plot and color palette \" ! print*, \"Example 103: Surface plot with hidden details and its contour\" ! print*, \"Example 104: Cylindrical mapping\" ! print*, \"Example 105: More contour plot\" ! print*, \"Example 106: Animation of 3D plots\" ! print*, \"Example 106: Multiplot layout in 3D\" ! print*, \"Example 107: Multiplot layout for 3D data\" ! print*, \"Example 108: Plot a 2D grid\" ! print* ! write (unit=*, fmt='(a)') \"2D plots: select an example: 1 through 30\" ! write (unit=*, fmt='(a)') \"3D plots: select an example: 101 through 108\" ! write (unit=*, fmt='(a)', advance='no') \"enter 0 for exit:  \" ! read*, i ! select case(i) !     case(1) !         call exmp01 !     case(2) !         call exmp02 !     case(3) !         call exmp03 !     case(4) !         call exmp04 !     case(5) !         call exmp05 !     case(6) !         call exmp06 !     case(7) !         call exmp07 !     case(8) !         call exmp08 !     case(9) !         call exmp09 !     case(10) !         call exmp10 !     case(11) !         call exmp11 !     case(12) !         call exmp12 !     case(13) !         call exmp13 !     case(14) !         call exmp14 !     case(15) !         call exmp15 !     case(16) !         call exmp16 !     case(17) !         call exmp17 !     case(18) !         call exmp18 !     case(19) !         call exmp19 !     case(20) !         call exmp20 !     case(21) !         call exmp21 !     case(22) !         call exmp22 !     case(23) !         call exmp23 !     case(24) !         call exmp24 !     case(25) !         call exmp25 !     case(26) !         call exmp26 !     case(27) !         call exmp27 !     case(28) !         call exmp28 !     case(29) !         call exmp29 !    case(30) !         call exmp30 !         ! 3D plots !     case(101) !         call exmp101 !     case(102) !         call exmp102 !     case(103) !         call exmp103 !     case(104) !         call exmp104 !     case(105) !         call exmp105 !     case(106) !         call exmp106 !     case(107) !         call exmp107 !    case(108) !         call exmp108 !     case (0) !         print*, \"Program terminated successfully\" !         exit mainloop !     case default !         print*, \"Try again, use a valid example number\" !         print*, \"Enter 0 to exit\" ! end select ! print* ! print*, \"press any key to continue...\" ! read* end do mainloop contains subroutine chapter_select () 999 format ( 80 ( \"*\" )) 111 format ( \"*\" , T34 , a , T80 , \"*\" ) print * print 999 print 111 , \"Select chapter\" print 999 print * end subroutine subroutine chapter_selected ( chp ) integer , intent ( in ) :: chp 999 format ( 80 ( \"*\" )) 111 format ( \"*\" , T34 , a , I0 , a , T80 , \"*\" ) print * print 999 print 111 , \"Chapter \" , chp , \" selected\" print 999 print * end subroutine subroutine problem_select () 999 format ( 80 ( \"*\" )) 111 format ( \"*\" , T34 , a , T80 , \"*\" ) print * print 999 print 111 , \"Select problem\" print 999 print * print * , \"  0 to exit, -1 to go back\" end subroutine subroutine program_start () 999 format ( 80 ( \"*\" )) 111 format ( \"*\" , T34 , a , T80 , \"*\" ) print * print 999 print 111 , \"Program start\" print 999 print * end subroutine subroutine program_end () 999 format ( 80 ( \"*\" )) 111 format ( \"*\" , T34 , a , T80 , \"*\" ) print * print 999 print 111 , \"Program ended\" print 999 print * call to_continue () end subroutine subroutine to_continue () print * , \"Press return to continue....\" read * end subroutine end program","tags":"","loc":"sourcefile/demo.f90.html"},{"title":"stats_test.f90 – Fortran Program","text":"Contents Programs test_stats Source Code stats_test.f90 Source Code program test_stats use foreng_math implicit none integer ( int32 ), dimension ( 8 ) :: x_i32 = [ 10 , 12 , 23 , 23 , 16 , 23 , 21 , 16 ] integer ( int64 ), dimension ( 8 ) :: x_i64 = [ 10 , 12 , 23 , 23 , 16 , 23 , 21 , 16 ] real ( real32 ), dimension ( 8 ) :: x_r32 = [ 10 , 12 , 23 , 23 , 16 , 23 , 21 , 16 ] real ( real64 ), dimension ( 8 ) :: x_r64 = [ 10 , 12 , 23 , 23 , 16 , 23 , 21 , 16 ] print * , \"std_dev(x_i32) = \" , std_dev ( x_i32 ) print * , \"std_dev(x_i64) = \" , std_dev ( x_i64 ) print * , \"std_dev(x_r32) = \" , std_dev ( x_r32 ) print * , \"std_dev(x_r64) = \" , std_dev ( x_r64 ) end program","tags":"","loc":"sourcefile/stats_test.f90.html"},{"title":"hyper_test.f90 – Fortran Program","text":"Contents Programs test_hyper Source Code hyper_test.f90 Source Code program test_hyper implicit none real :: x = 4 print * , \"sinh(x) = \" , sinh ( x ) end program test_hyper","tags":"","loc":"sourcefile/hyper_test.f90.html"},{"title":"trig_test.f90 – Fortran Program","text":"Contents Programs trig_test Source Code trig_test.f90 Source Code program trig_test use foreng_math implicit none real ( real64 ) :: thetad = 90 real ( real64 ) :: theta real ( real64 ), dimension ( 3 ) :: max_vals = [ - 1 0.d0 , 0 d0 , 5 d0 ] theta = deg_to_rad ( thetad ) print * , \"theta = \" , theta print * , \"thetad = \" , thetad print * , \"sin(theta) = \" , sin ( theta ) print * , \"sind(thetad) = \" , sind ( thetad ) print * , \"sinh(theta) = \" , sinh ( theta ) print * , \"sinhd(theta) = \" , sinhd ( thetad ) print * , \"MAXVAL(max_vals) = \" , maxval ( max_vals ) print * , \"asind(1.0) = \" , asind ( 1.0 ) print * , \"acosd(0.0) = \" , acosd ( 1.0 ) print * , \"sind(30) = \" , sind ( 30 d0 ) print * , \"tand(-45) = \" , tand ( - 45 d0 ) print * , \"atand(-1) = \" , atand ( - 1 d0 ) print * , \"atand(1) = \" , atand ( 1 d0 ) end program","tags":"","loc":"sourcefile/trig_test.f90.html"},{"title":"misc_test.f90 – Fortran Program","text":"Contents Programs misc_test Source Code misc_test.f90 Source Code program misc_test use foreng_math_misc use iso_fortran_env implicit none ! integer(int16) :: x ! integer(int32) :: x ! integer(int64) :: x ! integer(16) :: x print * , \"factorial(7) = \" , factorial ( 7_int16 ) print * , \"factorial(8) = \" , factorial ( 8_int16 ) print * , \"factorial(16) = \" , factorial ( 16_int32 ) print * , \"factorial(17) = \" , factorial ( 17_int32 ) print * , \"factorial(20) = \" , factorial ( 20_int64 ) print * , \"factorial(21) = \" , factorial ( 21_int64 ) print * , \"factorial(33) = \" , factorial ( 33_int128 ) print * , \"factorial(34) = \" , factorial ( 34_int128 ) print * , \"8**-3 = \" , 8.0 ** ( 1.0 / 3 ) print * , \"nth_root(8.0, 3.0) = \" , nth_root ( 8.0 , 3 ) end program","tags":"","loc":"sourcefile/misc_test.f90.html"},{"title":"prob_test.f90 – Fortran Program","text":"Contents Programs prob_test Source Code prob_test.f90 Source Code program prob_test use foreng_math implicit none integer , dimension ( 1000 ) :: x real , dimension ( 100000 ) :: x_2 integer , dimension ( 8 ) :: test = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 ] call fill_urand ( x , 1 , 10 ) call fill_urand ( x_2 , 1. , 1 0. ) print * , \"minval = \" , minval ( x ) print * , \"maxval = \" , maxval ( x ) print * , \"std_dev(x) = \" , std_dev ( x ) print * , \"mean(x) = \" , mean ( x ) print * , \"harmonic_mean(x) = \" , mean ( x , \"harmonic\" ) print * , \"rms_mean(x) = \" , mean ( x , \"rms\" ) print * , \"geometric_mean(x) = \" , mean ( x , \"geometric\" ) print * print * print * , \"minval = \" , minval ( x_2 ) print * , \"maxval = \" , maxval ( x_2 ) print * , \"std_dev(x) = \" , std_dev ( x_2 ) print * , \"mean(x) = \" , mean ( x_2 ) print * , \"harmonic_mean(x) = \" , mean ( x_2 , \"harmonic\" ) print * , \"rms_mean(x) = \" , mean ( x_2 , \"rms\" ) print * , \"geometric_mean(x) = \" , mean ( x_2 , \"geometric\" ) end program","tags":"","loc":"sourcefile/prob_test.f90.html"},{"title":"geom_test.f90 – Fortran Program","text":"Contents Programs geom_test Source Code geom_test.f90 Source Code program geom_test use foreng_math_geom implicit none type ( point2 ) :: p1 , p2 , p3 real ( real64 ) :: dp type ( point3 ) :: p3_1 type ( vector3 ) :: v1 , v2 , v3 type ( line2 ) :: line v1 = [ 1 , 2 , 3 ] v2 = vector3 ( 4 , 8 , 1 ) p3_1 = [ 1 , 2 , 3 ] p1 = point2 ( 10 , 9 ) p2 = p2 % from_pol ( 10 , 90 ) line = [ p1 , p2 ] call line % print () print * , \"line.atx(10) = \" , line % atx ( 1 0.d0 ) call p1 % print () call p1 % print_pol () call p2 % print () call p2 % print_pol () p3 = p1 + p2 ! dp = p1 .dot. p2 call p3 % print () call v1 % print () v1 = v1 + v1 call v1 % print () v1 = 5 * v1 call v1 % print () v3 = v1 . cross . v2 dp = v1 . dot . v2 print * , \"dp of v1: \" , v1 , \" and v2: \" , v2 , \" = \" , dp print * , \"v1 x v2 = \" , v3 v1 = scalar_times_vector3_int ( 5 , v1 ) p2 = [ 3 , 2 ] call p2 % print () call v1 % print () v1 = 0.02 * v1 call v1 % print () call p3_1 % print_sph () ! print *, \"dot product = \", dp end program","tags":"","loc":"sourcefile/geom_test.f90.html"},{"title":"sets_test.f90 – Fortran Program","text":"Contents Programs sets_test Source Code sets_test.f90 Source Code program sets_test use foreng_math implicit none ! integer, dimension(10) :: setA = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] ! integer, dimension(10) :: setB = [1, -10, 3, 5, -13, 6, -2, 8, 13, 10] real ( real32 ), dimension ( 10 ) :: setA = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] real ( real32 ), dimension ( 10 ) :: setB = [ 1 , - 10 , 3 , 5 , - 13 , 6 , - 2 , 8 , 13 , 10 ] ! real(real64), dimension(10) :: setA = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] ! real(real64), dimension(10) :: setB = [1, -10, 3, 5, -13, 6, -2, 8, 13, 10] ! integer, dimension(:), allocatable :: uni_int, inters_int real ( real32 ), dimension (:), allocatable :: uni , inters ! real(real64), dimension(:), allocatable :: uni, inters uni = union ( setA , setB ) inters = intersection ( setA , setB ) print * , \"For:\" print * , \"setA: \" , setA print * , \"setB: \" , setB print * , \"============================\" print * , \"union:        \" , uni print * , \"intersection: \" , inters end program","tags":"","loc":"sourcefile/sets_test.f90.html"},{"title":"point2 – Fortran Program ","text":"type, public :: point2 A point object with coordinates stored in cartesian coordinates Contents Variables x y Type-Bound Procedures print print_pol rho theta to_array dist from_pol assignment(=) operator(+) operator(-) add subtract_point2 unary_minus from_pol_r32 from_pol_r64 from_pol_int from_array_r32 from_array_r64 from_array_int Components Type Visibility Attributes Name Initial real(kind=real64), public :: x real(kind=real64), public :: y Type-Bound Procedures procedure, public :: print => point2_print_cartesian public subroutine point2_print_cartesian (self) Arguments Type Intent Optional Attributes Name class( point2 ), intent(in) :: self procedure, public :: print_pol => point2_print_polar public subroutine point2_print_polar (self) Print the polar coordinates of a point in this form Arguments Type Intent Optional Attributes Name class( point2 ), intent(in) :: self procedure, public :: rho => point2_rho public function point2_rho (self) result(rho) Calculate the magnitude (distance from the origin) of Arguments Type Intent Optional Attributes Name class( point2 ), intent(in) :: self Return Value real(kind=real64) procedure, public :: theta => point2_theta public function point2_theta (self) result(theta) Return the angle (in degrees) of the polar representation of a point Arguments Type Intent Optional Attributes Name class( point2 ), intent(in) :: self Return Value real(kind=real64) procedure, public :: to_array => point2_to_array public function point2_to_array (self) result(array) Arguments Type Intent Optional Attributes Name class( point2 ), intent(in) :: self Return Value real(kind=real64),\n  dimension(2) procedure, public :: dist => point2_distance_between_point2 public function point2_distance_between_point2 (self, p2) result(dist) Arguments Type Intent Optional Attributes Name class( point2 ), intent(in) :: self class( point2 ), intent(in) :: p2 Return Value real(kind=real64) generic, public :: from_pol => from_pol_r32 , from_pol_r64 , from_pol_int This is the comment for a generic function public function point2_from_polar_r32 (rho, theta) result(point) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: rho real(kind=real32), intent(in) :: theta Return Value type( point2 ) public function point2_from_polar_r64 (rho, theta) result(point) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: rho real(kind=real64), intent(in) :: theta Return Value type( point2 ) public function point2_from_polar_int (rho, theta) result(point) Arguments Type Intent Optional Attributes Name integer, intent(in) :: rho integer, intent(in) :: theta Return Value type( point2 ) generic, public :: assignment(=) => from_array_r32 , from_array_r64 , from_array_int public subroutine point2_from_array_r32 (point, array) Arguments Type Intent Optional Attributes Name class( point2 ), intent(out) :: point real(kind=real32), intent(in), dimension(2) :: array public subroutine point2_from_array_r64 (point, array) Arguments Type Intent Optional Attributes Name class( point2 ), intent(out) :: point real(kind=real64), intent(in), dimension(2) :: array public subroutine point2_from_array_int (point, array) Arguments Type Intent Optional Attributes Name class( point2 ), intent(out) :: point integer, intent(in), dimension(2) :: array generic, public :: operator(+) => add public function point2_plus_point2 (self, p2) result(p3) Arguments Type Intent Optional Attributes Name class( point2 ), intent(in) :: self class( point2 ), intent(in) :: p2 Return Value type( point2 ) generic, public :: operator(-) => subtract_point2 , unary_minus public function point2_minus_point2 (self, p2) result(p3) Arguments Type Intent Optional Attributes Name class( point2 ), intent(in) :: self class( point2 ), intent(in) :: p2 Return Value type( point2 ) public function point2_unary_minus (self) result(p3) Arguments Type Intent Optional Attributes Name class( point2 ), intent(in) :: self Return Value type( point2 ) procedure, public :: add => point2_plus_point2 public function point2_plus_point2 (self, p2) result(p3) Arguments Type Intent Optional Attributes Name class( point2 ), intent(in) :: self class( point2 ), intent(in) :: p2 Return Value type( point2 ) procedure, public :: subtract_point2 => point2_minus_point2 public function point2_minus_point2 (self, p2) result(p3) Arguments Type Intent Optional Attributes Name class( point2 ), intent(in) :: self class( point2 ), intent(in) :: p2 Return Value type( point2 ) procedure, public :: unary_minus => point2_unary_minus public function point2_unary_minus (self) result(p3) Arguments Type Intent Optional Attributes Name class( point2 ), intent(in) :: self Return Value type( point2 ) procedure, public, nopass :: from_pol_r32 => point2_from_polar_r32 public function point2_from_polar_r32 (rho, theta) result(point) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: rho real(kind=real32), intent(in) :: theta Return Value type( point2 ) procedure, public, nopass :: from_pol_r64 => point2_from_polar_r64 public function point2_from_polar_r64 (rho, theta) result(point) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: rho real(kind=real64), intent(in) :: theta Return Value type( point2 ) procedure, public, nopass :: from_pol_int => point2_from_polar_int public function point2_from_polar_int (rho, theta) result(point) Arguments Type Intent Optional Attributes Name integer, intent(in) :: rho integer, intent(in) :: theta Return Value type( point2 ) procedure, public :: from_array_r32 => point2_from_array_r32 public subroutine point2_from_array_r32 (point, array) Arguments Type Intent Optional Attributes Name class( point2 ), intent(out) :: point real(kind=real32), intent(in), dimension(2) :: array procedure, public :: from_array_r64 => point2_from_array_r64 public subroutine point2_from_array_r64 (point, array) Arguments Type Intent Optional Attributes Name class( point2 ), intent(out) :: point real(kind=real64), intent(in), dimension(2) :: array procedure, public :: from_array_int => point2_from_array_int public subroutine point2_from_array_int (point, array) Arguments Type Intent Optional Attributes Name class( point2 ), intent(out) :: point integer, intent(in), dimension(2) :: array","tags":"","loc":"type/point2.html"},{"title":"point3 – Fortran Program ","text":"type, public :: point3 Contents Variables x y z Type-Bound Procedures print print_sph rho theta phi to_array dist from_sph operator(+) assignment(=) operator(-) add point3_unary_minus subtract from_sph_r32 from_sph_r64 from_sph_int from_array_r32 from_array_r64 from_array_int Components Type Visibility Attributes Name Initial real(kind=real64), public :: x real(kind=real64), public :: y real(kind=real64), public :: z Type-Bound Procedures procedure, public :: print => point3_print_cartesian public subroutine point3_print_cartesian (self) Arguments Type Intent Optional Attributes Name class( point3 ), intent(in) :: self procedure, public :: print_sph => point3_print_spherical public subroutine point3_print_spherical (self) Print the polar coordinates of a point in this form Arguments Type Intent Optional Attributes Name class( point3 ), intent(in) :: self procedure, public :: rho => point3_rho public function point3_rho (self) result(rho) Calculate the magnitude (distance from the origin) of Arguments Type Intent Optional Attributes Name class( point3 ), intent(in) :: self Return Value real(kind=real64) procedure, public :: theta => point3_theta public function point3_theta (self) result(theta) Return the inlination theta Arguments Type Intent Optional Attributes Name class( point3 ), intent(in) :: self Return Value real(kind=real64) procedure, public :: phi => point3_phi public function point3_phi (self) result(phi) return the azimuth phi Arguments Type Intent Optional Attributes Name class( point3 ), intent(in) :: self Return Value real(kind=real64) procedure, public :: to_array => point3_to_array public function point3_to_array (self) result(array) Arguments Type Intent Optional Attributes Name class( point3 ), intent(in) :: self Return Value real(kind=real64),\n  dimension(3) procedure, public :: dist => point3_distance_between_point3 public function point3_distance_between_point3 (self, p2) result(dist) Arguments Type Intent Optional Attributes Name class( point3 ), intent(in) :: self class( point3 ), intent(in) :: p2 Return Value real(kind=real64) generic, public :: from_sph => from_sph_r32 , from_sph_r64 , from_sph_int This is the comment for a generic function public function point3_from_spherical_r32 (rho, theta, phi) result(point) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: rho real(kind=real32), intent(in) :: theta real(kind=real32), intent(in) :: phi Return Value type( point3 ) public function point3_from_spherical_r64 (rho, theta, phi) result(point) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: rho real(kind=real64), intent(in) :: theta real(kind=real64), intent(in) :: phi Return Value type( point3 ) public function point3_from_spherical_int (rho, theta, phi) result(point) Arguments Type Intent Optional Attributes Name integer, intent(in) :: rho integer, intent(in) :: theta integer, intent(in) :: phi Return Value type( point3 ) generic, public :: operator(+) => add public function point3_plus_point3 (self, p2) result(p3) Arguments Type Intent Optional Attributes Name class( point3 ), intent(in) :: self class( point3 ), intent(in) :: p2 Return Value type( point3 ) generic, public :: assignment(=) => from_array_r32 , from_array_r64 , from_array_int public subroutine point3_from_array_r32 (point, array) Arguments Type Intent Optional Attributes Name class( point3 ), intent(out) :: point real(kind=real32), intent(in), dimension(3) :: array public subroutine point3_from_array_r64 (point, array) Arguments Type Intent Optional Attributes Name class( point3 ), intent(out) :: point real(kind=real64), intent(in), dimension(3) :: array public subroutine point3_from_array_int (point, array) Arguments Type Intent Optional Attributes Name class( point3 ), intent(out) :: point integer, intent(in), dimension(3) :: array generic, public :: operator(-) => subtract public function point3_minus_point3 (self, p2) result(p3) Arguments Type Intent Optional Attributes Name class( point3 ), intent(in) :: self class( point3 ), intent(in) :: p2 Return Value type( point3 ) procedure, public :: add => point3_plus_point3 public function point3_plus_point3 (self, p2) result(p3) Arguments Type Intent Optional Attributes Name class( point3 ), intent(in) :: self class( point3 ), intent(in) :: p2 Return Value type( point3 ) procedure, public :: point3_unary_minus public function point3_unary_minus (self) result(p3) Arguments Type Intent Optional Attributes Name class( point3 ), intent(in) :: self Return Value type( point3 ) procedure, public :: subtract => point3_minus_point3 public function point3_minus_point3 (self, p2) result(p3) Arguments Type Intent Optional Attributes Name class( point3 ), intent(in) :: self class( point3 ), intent(in) :: p2 Return Value type( point3 ) procedure, public, nopass :: from_sph_r32 => point3_from_spherical_r32 public function point3_from_spherical_r32 (rho, theta, phi) result(point) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: rho real(kind=real32), intent(in) :: theta real(kind=real32), intent(in) :: phi Return Value type( point3 ) procedure, public, nopass :: from_sph_r64 => point3_from_spherical_r64 public function point3_from_spherical_r64 (rho, theta, phi) result(point) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: rho real(kind=real64), intent(in) :: theta real(kind=real64), intent(in) :: phi Return Value type( point3 ) procedure, public, nopass :: from_sph_int => point3_from_spherical_int public function point3_from_spherical_int (rho, theta, phi) result(point) Arguments Type Intent Optional Attributes Name integer, intent(in) :: rho integer, intent(in) :: theta integer, intent(in) :: phi Return Value type( point3 ) procedure, public :: from_array_r32 => point3_from_array_r32 public subroutine point3_from_array_r32 (point, array) Arguments Type Intent Optional Attributes Name class( point3 ), intent(out) :: point real(kind=real32), intent(in), dimension(3) :: array procedure, public :: from_array_r64 => point3_from_array_r64 public subroutine point3_from_array_r64 (point, array) Arguments Type Intent Optional Attributes Name class( point3 ), intent(out) :: point real(kind=real64), intent(in), dimension(3) :: array procedure, public :: from_array_int => point3_from_array_int public subroutine point3_from_array_int (point, array) Arguments Type Intent Optional Attributes Name class( point3 ), intent(out) :: point integer, intent(in), dimension(3) :: array","tags":"","loc":"type/point3.html"},{"title":"vector3 – Fortran Program ","text":"type, public :: vector3 Contents Variables x y z Type-Bound Procedures print length to_array from_array operator(+) operator(-) operator(*) operator(.dot.) operator(.cross.) operator(.angle.) assignment(=) from_array_r32 from_array_r64 from_array_int add_vector3 multiply_scalar_r32 multiply_scalar_r64 multiply_scalar_int dot cross angle_between subtract_vector3 unary_minus Components Type Visibility Attributes Name Initial real(kind=real64), public :: x real(kind=real64), public :: y real(kind=real64), public :: z Type-Bound Procedures procedure, public :: print => vector3_print public subroutine vector3_print (self) Arguments Type Intent Optional Attributes Name class( vector3 ), intent(in) :: self procedure, public :: length => vector3_magnitude public function vector3_magnitude (self) result(length) Arguments Type Intent Optional Attributes Name class( vector3 ), intent(in) :: self Return Value real(kind=real64) procedure, public :: to_array => vector3_to_array public function vector3_to_array (self) result(array) Arguments Type Intent Optional Attributes Name class( vector3 ), intent(in) :: self Return Value real(kind=real64),\n  dimension(3) generic, public :: from_array => from_array_r32 , from_array_r64 , from_array_int public subroutine vector3_from_array_r32 (vector, array) Arguments Type Intent Optional Attributes Name class( vector3 ), intent(out) :: vector real(kind=real32), intent(in), dimension(3) :: array public subroutine vector3_from_array_r64 (vector, array) Arguments Type Intent Optional Attributes Name class( vector3 ), intent(out) :: vector real(kind=real64), intent(in), dimension(3) :: array public subroutine vector3_from_array_int (vector, array) Arguments Type Intent Optional Attributes Name class( vector3 ), intent(out) :: vector integer, intent(in), dimension(3) :: array generic, public :: operator(+) => add_vector3 public function vector3_plus_vector3 (self, v2) result(v3) Arguments Type Intent Optional Attributes Name class( vector3 ), intent(in) :: self class( vector3 ), intent(in) :: v2 Return Value type( vector3 ) generic, public :: operator(-) => subtract_vector3 , unary_minus public function vector3_minus_vector3 (self, v2) result(v3) Arguments Type Intent Optional Attributes Name class( vector3 ), intent(in) :: self class( vector3 ), intent(in) :: v2 Return Value type( vector3 ) public function vector3_unary_minus (self) result(v3) Arguments Type Intent Optional Attributes Name class( vector3 ), intent(in) :: self Return Value type( vector3 ) generic, public :: operator(*) => multiply_scalar_r32 , multiply_scalar_r64 , multiply_scalar_int public function vector3_times_scalar_r32 (self, k) result(v2) Arguments Type Intent Optional Attributes Name class( vector3 ), intent(in) :: self real(kind=real32), intent(in) :: k Return Value type( vector3 ) public function vector3_times_scalar_r64 (self, k) result(v2) Arguments Type Intent Optional Attributes Name class( vector3 ), intent(in) :: self real(kind=real64), intent(in) :: k Return Value type( vector3 ) public function vector3_times_scalar_int (self, k) result(v2) Arguments Type Intent Optional Attributes Name class( vector3 ), intent(in) :: self integer, intent(in) :: k Return Value type( vector3 ) generic, public :: operator(.dot.) => dot public function vector3_dot_vector3 (self, v2) result(dot) Arguments Type Intent Optional Attributes Name class( vector3 ), intent(in) :: self class( vector3 ), intent(in) :: v2 Return Value real(kind=real64) generic, public :: operator(.cross.) => cross public function vector3_cross_vector3 (self, v2) result(normal) Arguments Type Intent Optional Attributes Name class( vector3 ), intent(in) :: self class( vector3 ), intent(in) :: v2 Return Value type( vector3 ) generic, public :: operator(.angle.) => angle_between public function vector3_angle_between_vector3 (self, v2) result(theta) Return angle between vectors in degrees Arguments Type Intent Optional Attributes Name class( vector3 ), intent(in) :: self class( vector3 ), intent(in) :: v2 Return Value real(kind=real64) generic, public :: assignment(=) => from_array_r32 , from_array_r64 , from_array_int public subroutine vector3_from_array_r32 (vector, array) Arguments Type Intent Optional Attributes Name class( vector3 ), intent(out) :: vector real(kind=real32), intent(in), dimension(3) :: array public subroutine vector3_from_array_r64 (vector, array) Arguments Type Intent Optional Attributes Name class( vector3 ), intent(out) :: vector real(kind=real64), intent(in), dimension(3) :: array public subroutine vector3_from_array_int (vector, array) Arguments Type Intent Optional Attributes Name class( vector3 ), intent(out) :: vector integer, intent(in), dimension(3) :: array procedure, public :: from_array_r32 => vector3_from_array_r32 public subroutine vector3_from_array_r32 (vector, array) Arguments Type Intent Optional Attributes Name class( vector3 ), intent(out) :: vector real(kind=real32), intent(in), dimension(3) :: array procedure, public :: from_array_r64 => vector3_from_array_r64 public subroutine vector3_from_array_r64 (vector, array) Arguments Type Intent Optional Attributes Name class( vector3 ), intent(out) :: vector real(kind=real64), intent(in), dimension(3) :: array procedure, public :: from_array_int => vector3_from_array_int public subroutine vector3_from_array_int (vector, array) Arguments Type Intent Optional Attributes Name class( vector3 ), intent(out) :: vector integer, intent(in), dimension(3) :: array procedure, public :: add_vector3 => vector3_plus_vector3 public function vector3_plus_vector3 (self, v2) result(v3) Arguments Type Intent Optional Attributes Name class( vector3 ), intent(in) :: self class( vector3 ), intent(in) :: v2 Return Value type( vector3 ) procedure, public :: multiply_scalar_r32 => vector3_times_scalar_r32 public function vector3_times_scalar_r32 (self, k) result(v2) Arguments Type Intent Optional Attributes Name class( vector3 ), intent(in) :: self real(kind=real32), intent(in) :: k Return Value type( vector3 ) procedure, public :: multiply_scalar_r64 => vector3_times_scalar_r64 public function vector3_times_scalar_r64 (self, k) result(v2) Arguments Type Intent Optional Attributes Name class( vector3 ), intent(in) :: self real(kind=real64), intent(in) :: k Return Value type( vector3 ) procedure, public :: multiply_scalar_int => vector3_times_scalar_int public function vector3_times_scalar_int (self, k) result(v2) Arguments Type Intent Optional Attributes Name class( vector3 ), intent(in) :: self integer, intent(in) :: k Return Value type( vector3 ) procedure, public :: dot => vector3_dot_vector3 public function vector3_dot_vector3 (self, v2) result(dot) Arguments Type Intent Optional Attributes Name class( vector3 ), intent(in) :: self class( vector3 ), intent(in) :: v2 Return Value real(kind=real64) procedure, public :: cross => vector3_cross_vector3 public function vector3_cross_vector3 (self, v2) result(normal) Arguments Type Intent Optional Attributes Name class( vector3 ), intent(in) :: self class( vector3 ), intent(in) :: v2 Return Value type( vector3 ) procedure, public :: angle_between => vector3_angle_between_vector3 public function vector3_angle_between_vector3 (self, v2) result(theta) Return angle between vectors in degrees Arguments Type Intent Optional Attributes Name class( vector3 ), intent(in) :: self class( vector3 ), intent(in) :: v2 Return Value real(kind=real64) procedure, public :: subtract_vector3 => vector3_minus_vector3 public function vector3_minus_vector3 (self, v2) result(v3) Arguments Type Intent Optional Attributes Name class( vector3 ), intent(in) :: self class( vector3 ), intent(in) :: v2 Return Value type( vector3 ) procedure, public :: unary_minus => vector3_unary_minus public function vector3_unary_minus (self) result(v3) Arguments Type Intent Optional Attributes Name class( vector3 ), intent(in) :: self Return Value type( vector3 )","tags":"","loc":"type/vector3.html"},{"title":"line2 – Fortran Program ","text":"type, public :: line2 Contents Variables m b Type-Bound Procedures atx aty print assignment(=) from_two_points Components Type Visibility Attributes Name Initial real(kind=real64), public :: m real(kind=real64), public :: b Type-Bound Procedures procedure, public :: atx => line2_atx Evaluate y = mx + b for a given x public function line2_atx (self, x) result(y) Arguments Type Intent Optional Attributes Name class( line2 ), intent(in) :: self real(kind=real64), intent(in) :: x Return Value real(kind=real64) procedure, public :: aty => line2_aty Evaluate y = mx + b for a given y public function line2_aty (self, y) result(x) Arguments Type Intent Optional Attributes Name class( line2 ), intent(in) :: self real(kind=real64), intent(in) :: y Return Value real(kind=real64) procedure, public :: print => line2_print public subroutine line2_print (self) Arguments Type Intent Optional Attributes Name class( line2 ), intent(in) :: self generic, public :: assignment(=) => from_two_points public subroutine line2_from_two_point2 (line, two_points) Arguments Type Intent Optional Attributes Name class( line2 ), intent(out) :: line class( point2 ), intent(in), dimension(2), target :: two_points procedure, public :: from_two_points => line2_from_two_point2 public subroutine line2_from_two_point2 (line, two_points) Arguments Type Intent Optional Attributes Name class( line2 ), intent(out) :: line class( point2 ), intent(in), dimension(2), target :: two_points","tags":"","loc":"type/line2.html"},{"title":"is_alphnum – Fortran Program","text":"public function is_alphnum(char) Test whether an ASCII character is alpha-numeric Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: char Return Value logical Contents None","tags":"","loc":"proc/is_alphnum.html"},{"title":"is_alph – Fortran Program","text":"public function is_alph(char) Test whether an ASCII character is a letter Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: char Return Value logical Contents None","tags":"","loc":"proc/is_alph.html"},{"title":"is_num – Fortran Program","text":"public function is_num(char) Test whether an ASCII character is numeric Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: char Return Value logical Contents None","tags":"","loc":"proc/is_num.html"},{"title":"is_lower – Fortran Program","text":"public function is_lower(char) Test whether an ASCII character is a lowercase letter Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: char Return Value logical Contents None","tags":"","loc":"proc/is_lower.html"},{"title":"is_upper – Fortran Program","text":"public function is_upper(char) Test whether an ASCII character is an uppercase letter Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: char Return Value logical Contents None","tags":"","loc":"proc/is_upper.html"},{"title":"calc_current_flow – Fortran Program","text":"public elemental function calc_current_flow(v_D, I_O, T) result(i_D) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: v_D The voltage across the diode, in volts real(kind=real64), intent(in) :: I_O The leakage current of the diode, in amperes real(kind=real64), intent(in) :: T Temperature, in kelvins (K) Return Value real(kind=real64) The current flow through the diode in amperes Contents None","tags":"","loc":"proc/calc_current_flow.html"},{"title":"to_kelvin – Fortran Program","text":"public elemental function to_kelvin(F) Convert a temperature in Fahrenheit to Kelvin Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: F Return Value real(kind=real64) Contents None","tags":"","loc":"proc/to_kelvin.html"},{"title":"to_celcius – Fortran Program","text":"public elemental function to_celcius(F) Convert a temperature from Fahrenheit to celcius Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: F Return Value real(kind=real64) Contents None","tags":"","loc":"proc/to_celcius.html"},{"title":"p4_1 – Fortran Program","text":"public subroutine p4_1() Test if the following equalities are valid statements, and if they are,\n evaluate them Arguments None Contents None","tags":"","loc":"proc/p4_1.html"},{"title":"p4_3 – Fortran Program","text":"public subroutine p4_3() Write a Fortran program to evaluate the equation y(x) = x&#94;2 - 3x + 2 for all values between -1 and 3,\n in steps of 0.1. Arguments None Contents None","tags":"","loc":"proc/p4_3.html"},{"title":"p4_4 – Fortran Program","text":"public subroutine p4_4() Write the Fortran statements required to calculate y(t) from the equation: y(t) = ------ -3t&#94;2 + 5    t >= 0\n           ---   3t&#94;2 + 5    t < 0 Arguments None Contents None","tags":"","loc":"proc/p4_4.html"},{"title":"p4_5 – Fortran Program","text":"public subroutine p4_5() Write a Fortran program to calculate the factorial function. Be sure to handle the special \n cases of 0! and of illegal input values. Arguments None Contents None","tags":"","loc":"proc/p4_5.html"},{"title":"p4_6 – Fortran Program","text":"public subroutine p4_6() What is the difference in behavior between a cycle statement and an exit statement? Arguments None Contents None","tags":"","loc":"proc/p4_6.html"},{"title":"p4_7 – Fortran Program","text":"public subroutine p4_7() Modify program stats_2 to use the DO WHILE construct instaed of the while construct currently in the program A modified statistical analysis program that avoids the divide-by-zero problems inherent in program stats_1. Purpose: To calculate mean and the standard deviation of an input data set containing an arbitrary number of input values. Record of revisions: Date      Programmer     Description of change\n  ====      ==========     =====================\n 11/10/15  S. J. Chapman   Original code\n 11/12/15  S. J. Chapman   Correct divide-by-0 error if\n                           0 or 1 input values given.\n 02/16/21  E. J. Voyles    Add do-while construct Arguments None Contents None","tags":"","loc":"proc/p4_7.html"},{"title":"p4_8 – Fortran Program","text":"public subroutine p4_8() Examine the following DO statements and determine how many times each loop will\n be exectued. !!! This for loop shows an error, since the increment is 0 !!!!!!!!!! Arguments None Contents None","tags":"","loc":"proc/p4_8.html"},{"title":"p4_9 – Fortran Program","text":"public subroutine p4_9() Examine the following loops, determine the value of ires and the number of times\n each loop executes Arguments None Contents None","tags":"","loc":"proc/p4_9.html"},{"title":"p4_10 – Fortran Program","text":"public subroutine p4_10() Examine the followin while loops and determine the value of ires at the end of each of \n the loops. Arguments None Contents None","tags":"","loc":"proc/p4_10.html"},{"title":"p4_11 – Fortran Program","text":"public subroutine p4_11() Modify program ball from example 4-7 to read in the acceleration due to gravity\n at a particular location, and to calculate the maximum range of the ball for that acceleration.\n After modifying the program, run it with accelerations of -9.8, -9.7, and -9.6m/s2. What effect does the reduction in gravitational attraction have on the range ofthe ball?\n What effect does the reduction in gravitational attraction have on the best angle theta at which to throw the ball? Arguments None Contents None","tags":"","loc":"proc/p4_11.html"},{"title":"p4_12 – Fortran Program","text":"public subroutine p4_12() Modify program ball from Example 4-7 to read in the initial velocity with which the ball\n is thrown. After modifying the program, run it with initial velocities of 10, 20, and 20 \n m/sec. What effect does changin the initial velocity have on the range of the ball? What\n effect does it have on the best angle theta at which to throw the ball? Arguments None Contents None","tags":"","loc":"proc/p4_12.html"},{"title":"p4_13 – Fortran Program","text":"public subroutine p4_13() Arguments None Contents None","tags":"","loc":"proc/p4_13.html"},{"title":"p4_14 – Fortran Program","text":"public subroutine p4_14() Write a Fortran program to evaluate the function \n y(x) = ln(1/1-x)\n for any user-specified value of x, where ln is the natural logarithm.\n Write the program with a while loop, so that the program repeats the calculation \n for each legal value of x entered into the program. When an illegal value of x is entered,\n terminate the program. Arguments None Contents None","tags":"","loc":"proc/p4_14.html"},{"title":"p4_15 – Fortran Program","text":"public subroutine p4_15() Write a Fortran program to convert all uppercase characters in a user-supplied character\n string to lowercase, without changing the uppercase and nonalphabetic characters in the string.\n Assume that your computer uses the ASCII collating sequence. Arguments None Contents None","tags":"","loc":"proc/p4_15.html"},{"title":"p4_16 – Fortran Program","text":"public subroutine p4_16() Calculating Orbits. When a satellinte orbits the Eath, the satellite's orbit will form an ellipse with the \n Earth located at one of the focal points of the ellipse. The satellite's orbit can be \n expressed in polar coordintaes as r = p/(1 - \\epsilon * cos( \\theta )) Where r and theta are the distance and angle of the satellite from the center of the earth,\n p is a parameter specifying the size of the orbit, and \\epsilon is a parameter representing the\n eccentricity of the orbit. A circular orbit has an eccentricity of zero. An elliptical orbit has \n an eccentricity of 0 <= e <= 1. If \\epsilon > 1, the satellite follows a hyperbolic path and escapes\n from Earth's gravitational field. Consider a satellite with a size parameter p = 1200 km. Write a program to calculate the \n distance of the satellite from the center of the Earth as a function of theta if the satellite has \n an eccentricity of (a) e = 0; (b) e = 0.25; (c) e = 0.5. Write a single program in which\n r and e are both input values. How close does each orbit come to the earth? How far away does each orbit get from the earth? Arguments None Contents None","tags":"","loc":"proc/p4_16.html"},{"title":"p4_17 – Fortran Program","text":"public subroutine p4_17() Write a program caps that reads in a character string, searches for all of the words \n within the string, and capitalizes the first letter of each word, while shifting the \n remainder of the word to lowercase. Assume that all nonalphabetic and nonumeric characters\n can mark the boundaries of a word within the character variable (periods, commas,etc.). \n Nonalphabetic characters should be left unchanged. Arguments None Contents None","tags":"","loc":"proc/p4_17.html"},{"title":"p4_18 – Fortran Program","text":"public subroutine p4_18() Write a computer program to calculate the current flowing through this diode\n for all voltages from -1.0V to +0.6 V, in 0.1 V steps. Repeat this process for the \n following temperatures: 75F, 100F, and 125F Arguments None Contents None","tags":"","loc":"proc/p4_18.html"},{"title":"p4_19 – Fortran Program","text":"public subroutine p4_19() Write a program that promps a user for a binary number, which will be entered as a string\n of 0s and 1s in a character variable. This program should be able to handle numbers whos\n binary representation is up to 10 bits, corresponding to values from 0 to 1023. Arguments None Contents None","tags":"","loc":"proc/p4_19.html"},{"title":"to_lower – Fortran Program","text":"public subroutine to_lower(char) Convert a single character to lowercase Arguments Type Intent Optional Attributes Name character(len=1), intent(inout) :: char Contents None","tags":"","loc":"proc/to_lower.html"},{"title":"to_upper – Fortran Program","text":"public subroutine to_upper(char) Convert a single character to uppercase Arguments Type Intent Optional Attributes Name character(len=1), intent(inout) :: char Contents None","tags":"","loc":"proc/to_upper.html"},{"title":"p7_1 – Fortran Program","text":"public subroutine p7_1() DISCUSSION QUESTION What is the difference between a subroutine and a function? Arguments None Contents None","tags":"","loc":"proc/p7_1.html"},{"title":"p7_2 – Fortran Program","text":"public subroutine p7_2() DISCUSSION QUESTION When a subroutine is called, how is data passed from the calling program to the subroutine,\n and how are the results of the subroutine returned to the calling program? Arguments None Contents None","tags":"","loc":"proc/p7_2.html"},{"title":"p7_3 – Fortran Program","text":"public subroutine p7_3() DISCUSSION QUESTION What are the advantages and disadvantages of the pass-by-reference scheme used in Fortran? Arguments None Contents None","tags":"","loc":"proc/p7_3.html"},{"title":"p7_4 – Fortran Program","text":"public subroutine p7_4() DISCUSSION QUESTION What are the advantages and disadvantages of each procedure array type? Arguments None Contents None","tags":"","loc":"proc/p7_4.html"},{"title":"p7_5 – Fortran Program","text":"public subroutine p7_5() DISCUSSION QUESTION Suppose a 15-element array is passed to a subroutine. What happens if the subroutine attempts\n to write to element a(16)? Arguments None Contents None","tags":"","loc":"proc/p7_5.html"},{"title":"p7_6 – Fortran Program","text":"public subroutine p7_6() DISCUSSION QUESTION If a real value is passed to a subroutine in an argument that is declared to be an integer,\n what happens? Arguments None Contents None","tags":"","loc":"proc/p7_6.html"},{"title":"p7_7 – Fortran Program","text":"public subroutine p7_7() DISCUSSION QUESTION How can p7_6 be modified so that the compiler catches the argument mismatch between\n the actual argument and the dummy argument in the subroutine? Arguments None Contents None","tags":"","loc":"proc/p7_7.html"},{"title":"p7_8 – Fortran Program","text":"public subroutine p7_8() DISCUSSION QUESTION What is the purpose of the INTENT attribute? Where can it be used? Why should it be used? Arguments None Contents None","tags":"","loc":"proc/p7_8.html"},{"title":"p7_9 – Fortran Program","text":"public subroutine p7_9() NOT APPLICABLE Arguments None Contents None","tags":"","loc":"proc/p7_9.html"},{"title":"p7_10 – Fortran Program","text":"public subroutine p7_10() NOT APPLICABLE Arguments None Contents None","tags":"","loc":"proc/p7_10.html"},{"title":"p6_1 – Fortran Program","text":"public subroutine p6_1() DISCUSSION QUESTION How may arrays be declared? Arguments None Contents None","tags":"","loc":"proc/p6_1.html"},{"title":"p6_3 – Fortran Program","text":"public subroutine p6_3() DISCUSSION QUESTION Execute this subroutine on your computer with both bounds checking turned on and \n bounds checking turned off. What happens? Arguments None Contents None","tags":"","loc":"proc/p6_3.html"},{"title":"p6_4 – Fortran Program","text":"public subroutine p6_4() DISCUSSION QUESTION Determine the shape and size of the arrays specified by the following statements: Arguments None Contents None","tags":"","loc":"proc/p6_4.html"},{"title":"p6_5 – Fortran Program","text":"public subroutine p6_5() DISCUSSION QUESTION Determine which of the following Fortran program fragments are valid. For each valid statement,\n specify what will happen in the program. (Assume default typing for any variables that are not \n explicitly typed within the program fragments.) Arguments None Contents None","tags":"","loc":"proc/p6_5.html"},{"title":"p6_6 – Fortran Program","text":"public subroutine p6_6() DISCUSSION QUESTION What is meant by each of the following array terms? Size, shape, extent, rank, conformable. Arguments None Contents None","tags":"","loc":"proc/p6_6.html"},{"title":"p6_7 – Fortran Program","text":"public subroutine p6_7() DISCUSSION QUESTION Given an array my_array defined as shown, determine whether each of the following\n array sections is valid Arguments None Contents None","tags":"","loc":"proc/p6_7.html"},{"title":"p6_8 – Fortran Program","text":"public subroutine p6_8() DISCUSSION QUESTION What will the output from each of the WRITE statements in the following subroutine be?\n Why is the output of the two statements different? Arguments None Contents None","tags":"","loc":"proc/p6_8.html"},{"title":"p6_10 – Fortran Program","text":"public subroutine p6_10() Polar to Rectangular Conversion Write a program that reads the polar coordinates of a 2D vector into a rank\n 1 array POLAR. polar(1) will contain the mgnitude and polar(2) will contain the \n angle theta in degrees, and converts the vector from\n polar to rectangular form, storing the result in a rank1 array RECT.\n Rect(1) should be the x component and rect(2) will be the y component. Arguments None Contents None","tags":"","loc":"proc/p6_10.html"},{"title":"p6_11 – Fortran Program","text":"public subroutine p6_11() Rectangular to Polar Conversion Write a program that reads the rectangular components of a 2D vector into a rank 1\n array rect. Arguments None Contents None","tags":"","loc":"proc/p6_11.html"},{"title":"p5_1 – Fortran Program","text":"public subroutine p5_1() DISCUSSION QUESTION What is the purpose of a format? What are the three ways to define a format? Arguments None Contents None","tags":"","loc":"proc/p5_1.html"},{"title":"p5_2 – Fortran Program","text":"public subroutine p5_2() DISCUSSION QUESTION What is printed out by the following Fortran statements? Arguments None Contents None","tags":"","loc":"proc/p5_2.html"},{"title":"p5_3 – Fortran Program","text":"public subroutine p5_3() DISCUSSION QUESTION What is printed out by the following Fortran statements? Arguments None Contents None","tags":"","loc":"proc/p5_3.html"},{"title":"p5_4 – Fortran Program","text":"public subroutine p5_4(file_name) DISCUSSION QUESTION Read in 5_4.dat and find out what the output will be for the following statements: Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name Contents None","tags":"","loc":"proc/p5_4.html"},{"title":"p5_5 – Fortran Program","text":"public subroutine p5_5(file_name) DISCUSSION QUESTION Read in 5_5.dat and find out what the value of each variable will be when the \n READ statements have been completed Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name Contents None","tags":"","loc":"proc/p5_5.html"},{"title":"p5_6 – Fortran Program","text":"public subroutine p5_6() Generate a table of the base 10 logarithms between 1 and 10 in steps of 0.1 Arguments None Contents None","tags":"","loc":"proc/p5_6.html"},{"title":"is_alphnum – Fortran Program","text":"public elemental function is_alphnum(char) Check if a character is alphanumeric\n This function checks the ASCII collating sequence of the passed character and returns true if the character is alpha (A-Z, a-z) or numeric (0-9) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: char Return Value logical Contents None","tags":"","loc":"proc/is_alphnum~2.html"},{"title":"is_alph – Fortran Program","text":"public elemental function is_alph(char) Check if a character belongs to the alphabet\n This function checks the ASCII collating sequence of the passed character and returns true if the character belongs to the Roman alphabet. Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: char Return Value logical Contents None","tags":"","loc":"proc/is_alph~2.html"},{"title":"is_num – Fortran Program","text":"public elemental function is_num(char) Check if a character is a numerical digit.\n Return true if a character is between 0-9 Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: char Return Value logical Contents None","tags":"","loc":"proc/is_num~2.html"},{"title":"is_lower – Fortran Program","text":"public elemental function is_lower(char) Check if a character is a lowercase alpha character\n Returns true if the ASCII value of char lies between LOWER_A_ASCII and LOWER_Z_ASCII Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: char Return Value logical Contents None","tags":"","loc":"proc/is_lower~2.html"},{"title":"is_upper – Fortran Program","text":"public elemental function is_upper(char) Check if a character is a uppercase alpha character\n Returns true if the ASCII value of char lies between UPPER_A_ASCII and UPPER_Z_ASCII Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: char Return Value logical Contents None","tags":"","loc":"proc/is_upper~2.html"},{"title":"to_lower – Fortran Program","text":"public elemental function to_lower(char) result(char_upper) Convert an uppercase alpha character to its lowercase counterpart. If the passed character is not uppercase, return the same character. Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: char Return Value character(len=1) Contents None","tags":"","loc":"proc/to_lower~2.html"},{"title":"to_upper – Fortran Program","text":"public elemental function to_upper(char) result(char_lower) Convert a lowercase alpha character to its uppercase counterpart. If the passed character is not lowercase, return the same character. Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: char Return Value character(len=1) Contents None","tags":"","loc":"proc/to_upper~2.html"},{"title":"gauss_elim – Fortran Program","text":"public interface gauss_elim Contents Module Procedures gauss_elim_sing_32 gauss_elim_sing_64 gauss_elim_sing_128 gauss_elim_mult_32 gauss_elim_mult_64 gauss_elim_mult_128 Module Procedures public interface gauss_elim_sing_32 () Arguments None public interface gauss_elim_sing_64 () Arguments None public interface gauss_elim_sing_128 () Arguments None public interface gauss_elim_mult_32 () Arguments None public interface gauss_elim_mult_64 () Arguments None public interface gauss_elim_mult_128 () Arguments None","tags":"","loc":"interface/gauss_elim.html"},{"title":"inverse – Fortran Program","text":"public interface inverse Contents Module Procedures gauss_elim_inverse_32 gauss_elim_inverse_64 gauss_elim_inverse_128 Module Procedures public interface gauss_elim_inverse_32 () Arguments None public interface gauss_elim_inverse_64 () Arguments None public interface gauss_elim_inverse_128 () Arguments None","tags":"","loc":"interface/inverse.html"},{"title":"lu – Fortran Program","text":"public interface lu Contents Module Procedures lu_decomp_32 lu_decomp_64 lu_decomp_128 Module Procedures public interface lu_decomp_32 () Arguments None public interface lu_decomp_64 () Arguments None public interface lu_decomp_128 () Arguments None","tags":"","loc":"interface/lu.html"},{"title":"eliminate_column – Fortran Program","text":"public interface eliminate_column Contents Module Procedures eliminate_column_32 eliminate_column_64 eliminate_column_128 Module Procedures public interface eliminate_column_32 () Arguments None public interface eliminate_column_64 () Arguments None public interface eliminate_column_128 () Arguments None","tags":"","loc":"interface/eliminate_column.html"},{"title":"gauss_elim_sing_32 – Fortran Program","text":"interface public module function gauss_elim_sing_32(A, b) result(x) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), DIMENSION(:,:) :: A real(kind=real32), intent(in), DIMENSION(size(A,DIM=1)) :: b Return Value real(kind=real32),\n  DIMENSION(size(A,DIM=1))","tags":"","loc":"interface/gauss_elim_sing_32.html"},{"title":"gauss_elim_sing_64 – Fortran Program","text":"interface public module function gauss_elim_sing_64(A, b) result(x) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), DIMENSION(:,:) :: A real(kind=real64), intent(in), DIMENSION(size(A,DIM=1)) :: b Return Value real(kind=real64),\n  DIMENSION(size(A,DIM=1))","tags":"","loc":"interface/gauss_elim_sing_64.html"},{"title":"gauss_elim_sing_128 – Fortran Program","text":"interface public module function gauss_elim_sing_128(A, b) result(x) Arguments Type Intent Optional Attributes Name real(kind=real128), intent(in), DIMENSION(:,:) :: A real(kind=real128), intent(in), DIMENSION(size(A,DIM=1)) :: b Return Value real(kind=real128),\n  DIMENSION(size(A,DIM=1))","tags":"","loc":"interface/gauss_elim_sing_128.html"},{"title":"gauss_elim_mult_32 – Fortran Program","text":"interface public module function gauss_elim_mult_32(A, b) result(x) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), DIMENSION(:,:) :: A real(kind=real32), intent(in), DIMENSION(:,:) :: b Return Value real(kind=real32),\n  DIMENSION(size(A,DIM=1), size(b,DIM=2))","tags":"","loc":"interface/gauss_elim_mult_32.html"},{"title":"gauss_elim_mult_64 – Fortran Program","text":"interface public module function gauss_elim_mult_64(A, b) result(x) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), DIMENSION(:,:) :: A real(kind=real64), intent(in), DIMENSION(:,:) :: b Return Value real(kind=real64),\n  DIMENSION(size(A,DIM=1), size(b,DIM=2))","tags":"","loc":"interface/gauss_elim_mult_64.html"},{"title":"gauss_elim_mult_128 – Fortran Program","text":"interface public module function gauss_elim_mult_128(A, b) result(x) Arguments Type Intent Optional Attributes Name real(kind=real128), intent(in), DIMENSION(:,:) :: A real(kind=real128), intent(in), DIMENSION(:,:) :: b Return Value real(kind=real128),\n  DIMENSION(size(A,DIM=1), size(b,DIM=2))","tags":"","loc":"interface/gauss_elim_mult_128.html"},{"title":"gauss_elim_inverse_32 – Fortran Program","text":"interface public module function gauss_elim_inverse_32(A) result(A_inv) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), DIMENSION(:,:) :: A Return Value real(kind=real32),\n  DIMENSION(size(A, DIM=1), size(A,DIM=1))","tags":"","loc":"interface/gauss_elim_inverse_32.html"},{"title":"gauss_elim_inverse_64 – Fortran Program","text":"interface public module function gauss_elim_inverse_64(A) result(A_inv) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), DIMENSION(:,:) :: A Return Value real(kind=real64),\n  DIMENSION(size(A, DIM=1), size(A,DIM=1))","tags":"","loc":"interface/gauss_elim_inverse_64.html"},{"title":"gauss_elim_inverse_128 – Fortran Program","text":"interface public module function gauss_elim_inverse_128(A) result(A_inv) Arguments Type Intent Optional Attributes Name real(kind=real128), intent(in), DIMENSION(:,:) :: A Return Value real(kind=real128),\n  DIMENSION(size(A, DIM=1), size(A,DIM=1))","tags":"","loc":"interface/gauss_elim_inverse_128.html"},{"title":"eliminate_column_32 – Fortran Program","text":"interface public subroutine eliminate_column_32(A, icol, order) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(inout), DIMENSION(:,:) :: A integer, intent(in) :: icol integer, intent(inout), DIMENSION(:) :: order","tags":"","loc":"interface/eliminate_column_32.html"},{"title":"eliminate_column_64 – Fortran Program","text":"interface public subroutine eliminate_column_64(A, icol, order) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), DIMENSION(:,:) :: A integer, intent(in) :: icol integer, intent(inout), DIMENSION(:) :: order","tags":"","loc":"interface/eliminate_column_64.html"},{"title":"eliminate_column_128 – Fortran Program","text":"interface public subroutine eliminate_column_128(A, icol, order) Arguments Type Intent Optional Attributes Name real(kind=real128), intent(inout), DIMENSION(:,:) :: A integer, intent(in) :: icol integer, intent(inout), DIMENSION(:) :: order","tags":"","loc":"interface/eliminate_column_128.html"},{"title":"lu_decomp_32 – Fortran Program","text":"interface public subroutine lu_decomp_32(A, L, U) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), DIMENSION(:,:) :: A real(kind=real32), intent(out), DIMENSION(:,:), ALLOCATABLE :: L real(kind=real32), intent(out), DIMENSION(:,:), ALLOCATABLE :: U","tags":"","loc":"interface/lu_decomp_32.html"},{"title":"lu_decomp_64 – Fortran Program","text":"interface public subroutine lu_decomp_64(A, L, U) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), DIMENSION(:,:) :: A real(kind=real64), intent(out), DIMENSION(:,:), ALLOCATABLE :: L real(kind=real64), intent(out), DIMENSION(:,:), ALLOCATABLE :: U","tags":"","loc":"interface/lu_decomp_64.html"},{"title":"lu_decomp_128 – Fortran Program","text":"interface public subroutine lu_decomp_128(A, L, U) Arguments Type Intent Optional Attributes Name real(kind=real128), intent(in), DIMENSION(:,:) :: A real(kind=real128), intent(out), DIMENSION(:,:), ALLOCATABLE :: L real(kind=real128), intent(out), DIMENSION(:,:), ALLOCATABLE :: U","tags":"","loc":"interface/lu_decomp_128.html"},{"title":"calc_m_lls – Fortran Program","text":"public function calc_m_lls(X, Y) result(m) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), dimension(:) :: X real(kind=real32), intent(in), dimension(:) :: Y Return Value real(kind=real32) Contents None","tags":"","loc":"proc/calc_m_lls.html"},{"title":"calc_b_lls – Fortran Program","text":"public function calc_b_lls(y_bar, x_bar, m) result(b) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: y_bar real(kind=real32), intent(in) :: x_bar real(kind=real32), intent(in) :: m Return Value real(kind=real32) Contents None","tags":"","loc":"proc/calc_b_lls.html"},{"title":"calc_correlation_coefficient_lls – Fortran Program","text":"public function calc_correlation_coefficient_lls(X, Y) result(r) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), dimension(:) :: X real(kind=real32), intent(in), dimension(:) :: Y Return Value real Contents None","tags":"","loc":"proc/calc_correlation_coefficient_lls.html"},{"title":"lls_fit – Fortran Program","text":"public subroutine lls_fit(X, Y, m, b, stat) Linear Least Squares Fit Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), dimension(:) :: X real(kind=real32), intent(in), dimension(:) :: Y real(kind=real32), intent(out) :: m real(kind=real32), intent(out) :: b integer, optional :: stat Contents None","tags":"","loc":"proc/lls_fit.html"},{"title":"lls_coefficient_fit – Fortran Program","text":"public subroutine lls_coefficient_fit(X, Y, m, b, r, stat) Linear Least Squares Fit with correlation coefficient Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), dimension(:) :: X real(kind=real32), intent(in), dimension(:) :: Y real(kind=real32), intent(out) :: m real(kind=real32), intent(out) :: b real(kind=real32), intent(out) :: r integer, optional :: stat Contents None","tags":"","loc":"proc/lls_coefficient_fit.html"},{"title":"generate_sys_eqns – Fortran Program","text":"public subroutine generate_sys_eqns(X, Y, order, A, u) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:) :: X real(kind=real64), intent(in), dimension(:) :: Y integer, intent(in) :: order real(kind=real64), intent(out), dimension(:,:), allocatable :: A real(kind=real64), intent(out), dimension(:), allocatable :: u Contents None","tags":"","loc":"proc/generate_sys_eqns.html"},{"title":"calc_derivative – Fortran Program","text":"public function calc_derivative(func, x_0, dx) result(dydx) Arguments Type Intent Optional Attributes Name real(kind=real64), external :: func Ptr to an external function real(kind=real64), intent(in) :: x_0 Value at which to calculate the derivative real(kind=real64), optional :: dx Optional step size. If not present, defaults to 10&#94;{-100} Return Value real(kind=real64) \\frac{dy}{dx} at x = x_0 Contents None","tags":"","loc":"proc/calc_derivative.html"},{"title":"calc_tension – Fortran Program","text":"public function calc_tension(W_, lc_, lp_, d_) result(T_) Arguments Type Intent Optional Attributes Name real, intent(in) :: W_ Weight of the object (kg) real, intent(in) :: lc_ length of the cable (m) real, intent(in) :: lp_ Length of the pole (m) real, intent(in) :: d_ Distance to attach the weight (m) Return Value real Tension in N Contents None","tags":"","loc":"proc/calc_tension.html"},{"title":"calc_decibels – Fortran Program","text":"public function calc_decibels(P1_, P2_) result(dB_) Arguments Type Intent Optional Attributes Name real, intent(in) :: P1_ real, intent(in) :: P2_ Return Value real Contents None","tags":"","loc":"proc/calc_decibels.html"},{"title":"calc_gravity – Fortran Program","text":"public function calc_gravity(m1, m2, r) result(F) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: m1 mass of body 1 in kg real(kind=real64), intent(in) :: m2 mass of body 2 in kg real(kind=real64), intent(in) :: r distance between bodies in meters Return Value real(kind=real64) Gravitational force Contents None","tags":"","loc":"proc/calc_gravity.html"},{"title":"fahrenheit_to_celcius_r32 – Fortran Program","text":"public elemental function fahrenheit_to_celcius_r32(F) result(C) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: F Return Value real(kind=real32) Contents None","tags":"","loc":"proc/fahrenheit_to_celcius_r32.html"},{"title":"fahrenheit_to_celcius_r64 – Fortran Program","text":"public elemental function fahrenheit_to_celcius_r64(F) result(C) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: F Return Value real(kind=real64) Contents None","tags":"","loc":"proc/fahrenheit_to_celcius_r64.html"},{"title":"celcius_to_fahrenheit_r32 – Fortran Program","text":"public elemental function celcius_to_fahrenheit_r32(C) result(F) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: C Return Value real(kind=real32) Contents None","tags":"","loc":"proc/celcius_to_fahrenheit_r32.html"},{"title":"celcius_to_fahrenheit_r64 – Fortran Program","text":"public elemental function celcius_to_fahrenheit_r64(C) result(F) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: C Return Value real(kind=real64) Contents None","tags":"","loc":"proc/celcius_to_fahrenheit_r64.html"},{"title":"celcius_to_kelvin_r32 – Fortran Program","text":"public elemental function celcius_to_kelvin_r32(C) result(K) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: C Return Value real(kind=real32) Contents None","tags":"","loc":"proc/celcius_to_kelvin_r32.html"},{"title":"celcius_to_kelvin_r64 – Fortran Program","text":"public elemental function celcius_to_kelvin_r64(C) result(K) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: C Return Value real(kind=real64) Contents None","tags":"","loc":"proc/celcius_to_kelvin_r64.html"},{"title":"kelvin_to_celcius_r32 – Fortran Program","text":"public elemental function kelvin_to_celcius_r32(K) result(C) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: K Return Value real(kind=real32) Contents None","tags":"","loc":"proc/kelvin_to_celcius_r32.html"},{"title":"kelvin_to_celcius_r64 – Fortran Program","text":"public elemental function kelvin_to_celcius_r64(K) result(C) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: K Return Value real(kind=real64) Contents None","tags":"","loc":"proc/kelvin_to_celcius_r64.html"},{"title":"kelvin_to_fahrenheit_r32 – Fortran Program","text":"public elemental function kelvin_to_fahrenheit_r32(K) result(F) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: K Return Value real(kind=real32) Contents None","tags":"","loc":"proc/kelvin_to_fahrenheit_r32.html"},{"title":"kelvin_to_fahrenheit_r64 – Fortran Program","text":"public elemental function kelvin_to_fahrenheit_r64(K) result(F) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: K Return Value real(kind=real64) Contents None","tags":"","loc":"proc/kelvin_to_fahrenheit_r64.html"},{"title":"fahrenheit_to_kelvin_r32 – Fortran Program","text":"public elemental function fahrenheit_to_kelvin_r32(F) result(K) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: F Return Value real(kind=real32) Contents None","tags":"","loc":"proc/fahrenheit_to_kelvin_r32.html"},{"title":"fahrenheit_to_kelvin_r64 – Fortran Program","text":"public elemental function fahrenheit_to_kelvin_r64(F) result(K) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: F Return Value real(kind=real64) Contents None","tags":"","loc":"proc/fahrenheit_to_kelvin_r64.html"},{"title":"fahrenheit_to_celcius – Fortran Program","text":"public interface fahrenheit_to_celcius Contents Module Procedures fahrenheit_to_celcius_r32 fahrenheit_to_celcius_r64 Module Procedures public elemental function fahrenheit_to_celcius_r32 (F) result(C) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: F Return Value real(kind=real32) public elemental function fahrenheit_to_celcius_r64 (F) result(C) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: F Return Value real(kind=real64)","tags":"","loc":"interface/fahrenheit_to_celcius.html"},{"title":"celcius_to_fahrenheit – Fortran Program","text":"public interface celcius_to_fahrenheit Contents Module Procedures celcius_to_fahrenheit_r32 celcius_to_fahrenheit_r64 Module Procedures public elemental function celcius_to_fahrenheit_r32 (C) result(F) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: C Return Value real(kind=real32) public elemental function celcius_to_fahrenheit_r64 (C) result(F) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: C Return Value real(kind=real64)","tags":"","loc":"interface/celcius_to_fahrenheit.html"},{"title":"celcius_to_kelvin – Fortran Program","text":"public interface celcius_to_kelvin Contents Module Procedures celcius_to_kelvin_r32 celcius_to_kelvin_r64 Module Procedures public elemental function celcius_to_kelvin_r32 (C) result(K) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: C Return Value real(kind=real32) public elemental function celcius_to_kelvin_r64 (C) result(K) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: C Return Value real(kind=real64)","tags":"","loc":"interface/celcius_to_kelvin.html"},{"title":"kelvin_to_celcius – Fortran Program","text":"public interface kelvin_to_celcius Contents Module Procedures kelvin_to_celcius_r32 kelvin_to_celcius_r64 Module Procedures public elemental function kelvin_to_celcius_r32 (K) result(C) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: K Return Value real(kind=real32) public elemental function kelvin_to_celcius_r64 (K) result(C) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: K Return Value real(kind=real64)","tags":"","loc":"interface/kelvin_to_celcius.html"},{"title":"kelvin_to_fahrenheit – Fortran Program","text":"public interface kelvin_to_fahrenheit Contents Module Procedures kelvin_to_fahrenheit_r32 kelvin_to_fahrenheit_r64 Module Procedures public elemental function kelvin_to_fahrenheit_r32 (K) result(F) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: K Return Value real(kind=real32) public elemental function kelvin_to_fahrenheit_r64 (K) result(F) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: K Return Value real(kind=real64)","tags":"","loc":"interface/kelvin_to_fahrenheit.html"},{"title":"fahrenheit_to_kelvin – Fortran Program","text":"public interface fahrenheit_to_kelvin Contents Module Procedures fahrenheit_to_kelvin_r32 fahrenheit_to_kelvin_r64 Module Procedures public elemental function fahrenheit_to_kelvin_r32 (F) result(K) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: F Return Value real(kind=real32) public elemental function fahrenheit_to_kelvin_r64 (F) result(K) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: F Return Value real(kind=real64)","tags":"","loc":"interface/fahrenheit_to_kelvin.html"},{"title":"calc_current_flow – Fortran Program","text":"public elemental function calc_current_flow(v_D, I_O, T) result(i_D_) Arguments Type Intent Optional Attributes Name real(kind=16), intent(in) :: v_D Voltage across the diode, in volts real(kind=16), intent(in) :: I_O Leakage current of the diode, in amperes real(kind=16), intent(in) :: T Temperature, in kelvins (K) Return Value integer Contents None","tags":"","loc":"proc/calc_current_flow~2.html"},{"title":"sind_r32 – Fortran Program","text":"public elemental function sind_r32(theta) result(sind) Single precision Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: theta \\theta in degrees Return Value real(kind=real32) Contents None","tags":"","loc":"proc/sind_r32.html"},{"title":"sind_r64 – Fortran Program","text":"public elemental function sind_r64(theta) result(sind) Double precision Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: theta \\theta in degrees Return Value real(kind=real64) Contents None","tags":"","loc":"proc/sind_r64.html"},{"title":"cosd_r32 – Fortran Program","text":"public elemental function cosd_r32(theta) result(cosd) Single precision Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: theta \\theta in degrees Return Value real(kind=real32) Contents None","tags":"","loc":"proc/cosd_r32.html"},{"title":"cosd_r64 – Fortran Program","text":"public elemental function cosd_r64(theta) result(cosd) Double precision Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: theta \\theta in degrees Return Value real(kind=real64) Contents None","tags":"","loc":"proc/cosd_r64.html"},{"title":"tand_r32 – Fortran Program","text":"public elemental function tand_r32(theta) result(tand) Single precision Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: theta \\theta in degrees Return Value real(kind=real32) Contents None","tags":"","loc":"proc/tand_r32.html"},{"title":"tand_r64 – Fortran Program","text":"public elemental function tand_r64(theta) result(tand) Double precision Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: theta \\theta in degrees Return Value real(kind=real64) Contents None","tags":"","loc":"proc/tand_r64.html"},{"title":"asind_r32 – Fortran Program","text":"public elemental function asind_r32(x) result(theta) Single precision Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: x Return Value real(kind=real32) \\theta in degrees Contents None","tags":"","loc":"proc/asind_r32.html"},{"title":"asind_r64 – Fortran Program","text":"public elemental function asind_r64(x) result(theta) Double precision Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x Return Value real(kind=real64) \\theta in degrees Contents None","tags":"","loc":"proc/asind_r64.html"},{"title":"acosd_r32 – Fortran Program","text":"public elemental function acosd_r32(x) result(theta) Single precision Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: x Return Value real(kind=real32) \\theta in degrees Contents None","tags":"","loc":"proc/acosd_r32.html"},{"title":"acosd_r64 – Fortran Program","text":"public elemental function acosd_r64(x) result(theta) Double precision Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x Return Value real(kind=real64) \\theta in degrees Contents None","tags":"","loc":"proc/acosd_r64.html"},{"title":"atand_r32 – Fortran Program","text":"public elemental function atand_r32(x) result(theta) Single precision Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: x Return Value real(kind=real32) \\theta in degrees Contents None","tags":"","loc":"proc/atand_r32.html"},{"title":"atand_r64 – Fortran Program","text":"public elemental function atand_r64(x) result(theta) Double precision Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x Return Value real(kind=real64) \\theta in degrees Contents None","tags":"","loc":"proc/atand_r64.html"},{"title":"sinhd_r32 – Fortran Program","text":"public elemental function sinhd_r32(theta) result(sinhd) Single precision Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: theta \\theta in degrees Return Value real(kind=real32) Contents None","tags":"","loc":"proc/sinhd_r32.html"},{"title":"sinhd_r64 – Fortran Program","text":"public elemental function sinhd_r64(theta) result(sinhd) Double precision Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: theta \\theta in degrees Return Value real(kind=real64) Contents None","tags":"","loc":"proc/sinhd_r64.html"},{"title":"coshd_r32 – Fortran Program","text":"public elemental function coshd_r32(theta) result(coshd) Single precision Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: theta \\theta in degrees Return Value real(kind=real32) Contents None","tags":"","loc":"proc/coshd_r32.html"},{"title":"coshd_r64 – Fortran Program","text":"public elemental function coshd_r64(theta) result(coshd) Double precision Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: theta \\theta in degrees Return Value real(kind=real64) Contents None","tags":"","loc":"proc/coshd_r64.html"},{"title":"tanhd_r32 – Fortran Program","text":"public elemental function tanhd_r32(theta) result(tanhd) Single precision Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: theta \\theta in degrees Return Value real(kind=real32) Contents None","tags":"","loc":"proc/tanhd_r32.html"},{"title":"tanhd_r64 – Fortran Program","text":"public elemental function tanhd_r64(theta) result(tanhd) Double precision Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: theta \\theta in degrees Return Value real(kind=real64) Contents None","tags":"","loc":"proc/tanhd_r64.html"},{"title":"deg_to_rad_r32 – Fortran Program","text":"public elemental function deg_to_rad_r32(degrees) result(radians) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: degrees Return Value real(kind=real32) Contents None","tags":"","loc":"proc/deg_to_rad_r32.html"},{"title":"deg_to_rad_r64 – Fortran Program","text":"public elemental function deg_to_rad_r64(degrees) result(radians) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: degrees Return Value real(kind=real64) Contents None","tags":"","loc":"proc/deg_to_rad_r64.html"},{"title":"rad_to_deg_r32 – Fortran Program","text":"public elemental function rad_to_deg_r32(radians) result(degrees) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: radians Return Value real(kind=real32) Contents None","tags":"","loc":"proc/rad_to_deg_r32.html"},{"title":"rad_to_deg_r64 – Fortran Program","text":"public elemental function rad_to_deg_r64(radians) result(degrees) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: radians Return Value real(kind=real64) Contents None","tags":"","loc":"proc/rad_to_deg_r64.html"},{"title":"sind – Fortran Program","text":"public interface sind Calculate \\sin(\\theta) where \\theta is in degrees real ( real32 ) :: theta_r32 = 90 real ( real64 ) :: theta_r64 = 30 print * , sind ( theta_r32 ) ! = 1.000 print * , sind ( theta_r64 ) ! = 0.500 Contents Module Procedures sind_r32 sind_r64 Module Procedures public elemental function sind_r32 (theta) result(sind) Single precision Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: theta \\theta in degrees Return Value real(kind=real32) public elemental function sind_r64 (theta) result(sind) Double precision Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: theta \\theta in degrees Return Value real(kind=real64)","tags":"","loc":"interface/sind.html"},{"title":"cosd – Fortran Program","text":"public interface cosd Calculate \\cos(\\theta) where \\theta is in degrees real ( real32 ) :: theta_r32 = 90 real ( real64 ) :: theta_r64 = 60 print * , cosd ( theta_r32 ) ! = 0.000 print * , cosd ( theta_r64 ) ! = 0.500 Contents Module Procedures cosd_r32 cosd_r64 Module Procedures public elemental function cosd_r32 (theta) result(cosd) Single precision Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: theta \\theta in degrees Return Value real(kind=real32) public elemental function cosd_r64 (theta) result(cosd) Double precision Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: theta \\theta in degrees Return Value real(kind=real64)","tags":"","loc":"interface/cosd.html"},{"title":"tand – Fortran Program","text":"public interface tand Calculate \\tan(\\theta) where \\theta is in degrees real ( real32 ) :: theta_r32 = 45 real ( real64 ) :: theta_r64 = - 45 print * , tand ( theta_r32 ) ! = 1.000 print * , tand ( theta_r64 ) ! = -1.000 Contents Module Procedures tand_r32 tand_r64 Module Procedures public elemental function tand_r32 (theta) result(tand) Single precision Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: theta \\theta in degrees Return Value real(kind=real32) public elemental function tand_r64 (theta) result(tand) Double precision Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: theta \\theta in degrees Return Value real(kind=real64)","tags":"","loc":"interface/tand.html"},{"title":"asind – Fortran Program","text":"public interface asind Calculate \\textrm{asin}(x) and return \\theta in degrees real ( real32 ) :: x_r32 = 1 real ( real64 ) :: x_r64 = 0 print * , asind ( x_r32 ) ! = 90.000 print * , asind ( x_r64 ) ! = 0.000 Contents Module Procedures asind_r32 asind_r64 Module Procedures public elemental function asind_r32 (x) result(theta) Single precision Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: x Return Value real(kind=real32) \\theta in degrees public elemental function asind_r64 (x) result(theta) Double precision Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x Return Value real(kind=real64) \\theta in degrees","tags":"","loc":"interface/asind.html"},{"title":"acosd – Fortran Program","text":"public interface acosd Calculate \\textrm{acos}(x) and return \\theta in degrees real ( real32 ) :: x_r32 = 1 real ( real64 ) :: x_r64 = 0 print * , acosd ( x_r32 ) ! = 0.000 print * , acosd ( x_r64 ) ! = 90.000 Contents Module Procedures acosd_r32 acosd_r64 Module Procedures public elemental function acosd_r32 (x) result(theta) Single precision Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: x Return Value real(kind=real32) \\theta in degrees public elemental function acosd_r64 (x) result(theta) Double precision Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x Return Value real(kind=real64) \\theta in degrees","tags":"","loc":"interface/acosd.html"},{"title":"atand – Fortran Program","text":"public interface atand Calculate \\textrm{atan}(x) and return \\theta in degrees real ( real32 ) :: x_r32 = 1 real ( real64 ) :: x_r64 = - 1 print * , acosd ( x_r32 ) ! = 45.000 print * , acosd ( x_r64 ) ! = -45.000 Contents Module Procedures atand_r32 atand_r64 Module Procedures public elemental function atand_r32 (x) result(theta) Single precision Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: x Return Value real(kind=real32) \\theta in degrees public elemental function atand_r64 (x) result(theta) Double precision Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x Return Value real(kind=real64) \\theta in degrees","tags":"","loc":"interface/atand.html"},{"title":"sinhd – Fortran Program","text":"public interface sinhd Contents Module Procedures sinhd_r32 sinhd_r64 Module Procedures public elemental function sinhd_r32 (theta) result(sinhd) Single precision Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: theta \\theta in degrees Return Value real(kind=real32) public elemental function sinhd_r64 (theta) result(sinhd) Double precision Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: theta \\theta in degrees Return Value real(kind=real64)","tags":"","loc":"interface/sinhd.html"},{"title":"coshd – Fortran Program","text":"public interface coshd Contents Module Procedures coshd_r32 coshd_r64 Module Procedures public elemental function coshd_r32 (theta) result(coshd) Single precision Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: theta \\theta in degrees Return Value real(kind=real32) public elemental function coshd_r64 (theta) result(coshd) Double precision Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: theta \\theta in degrees Return Value real(kind=real64)","tags":"","loc":"interface/coshd.html"},{"title":"tanhd – Fortran Program","text":"public interface tanhd Contents Module Procedures tanhd_r32 tanhd_r64 Module Procedures public elemental function tanhd_r32 (theta) result(tanhd) Single precision Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: theta \\theta in degrees Return Value real(kind=real32) public elemental function tanhd_r64 (theta) result(tanhd) Double precision Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: theta \\theta in degrees Return Value real(kind=real64)","tags":"","loc":"interface/tanhd.html"},{"title":"deg_to_rad – Fortran Program","text":"public interface deg_to_rad Convert \\theta from degrees to radians Contents Module Procedures deg_to_rad_r32 deg_to_rad_r64 Module Procedures public elemental function deg_to_rad_r32 (degrees) result(radians) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: degrees Return Value real(kind=real32) public elemental function deg_to_rad_r64 (degrees) result(radians) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: degrees Return Value real(kind=real64)","tags":"","loc":"interface/deg_to_rad.html"},{"title":"rad_to_deg – Fortran Program","text":"public interface rad_to_deg Conver \\theta from radians to degrees Contents Module Procedures rad_to_deg_r32 rad_to_deg_r64 Module Procedures public elemental function rad_to_deg_r32 (radians) result(degrees) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: radians Return Value real(kind=real32) public elemental function rad_to_deg_r64 (radians) result(degrees) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: radians Return Value real(kind=real64)","tags":"","loc":"interface/rad_to_deg.html"},{"title":"rank_1_mean_r32 – Fortran Program","text":"public function rank_1_mean_r32(data_, type) result(mean_) Calculate the mean of a 1d data set, given the \"type\" Check which mean to call Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), dimension(:) :: data_ character(len=*), intent(in), optional :: type Return Value real(kind=real32) Contents None","tags":"","loc":"proc/rank_1_mean_r32.html"},{"title":"rank_1_mean_r64 – Fortran Program","text":"public function rank_1_mean_r64(data_, type) result(mean_) Calculate the mean of a 1d data set, given the \"type\" Check which mean to call Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:) :: data_ character(len=*), intent(in), optional :: type Return Value real(kind=real64) Contents None","tags":"","loc":"proc/rank_1_mean_r64.html"},{"title":"rank_1_mean_i32 – Fortran Program","text":"public function rank_1_mean_i32(data_, type) result(mean_) Calculate the mean of a 1d data set, given the \"type\" Check which mean to call Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), dimension(:) :: data_ character(len=*), intent(in), optional :: type Return Value real(kind=real32) Contents None","tags":"","loc":"proc/rank_1_mean_i32.html"},{"title":"rank_1_mean_i64 – Fortran Program","text":"public function rank_1_mean_i64(data_, type) result(mean_) Calculate the mean of a 1d data set, given the \"type\" Check which mean to call Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), dimension(:) :: data_ character(len=*), intent(in), optional :: type Return Value real(kind=real64) Contents None","tags":"","loc":"proc/rank_1_mean_i64.html"},{"title":"rank1_arithmetic_mean_r32 – Fortran Program","text":"public function rank1_arithmetic_mean_r32(data_) result(arithmetic_mean_) Calculate the arithmetic mean of a rank 1 array Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: data_ (:) Return Value real(kind=real32) Rank 1 array containing the elements to calculate the mean for Contents None","tags":"","loc":"proc/rank1_arithmetic_mean_r32.html"},{"title":"rank1_arithmetic_mean_r64 – Fortran Program","text":"public function rank1_arithmetic_mean_r64(data_) result(arithmetic_mean_) Calculate the arithmetic mean of a rank 1 array Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: data_ (:) Return Value real(kind=real64) Rank 1 array containing the elements to calculate the mean for Contents None","tags":"","loc":"proc/rank1_arithmetic_mean_r64.html"},{"title":"rank1_arithmetic_mean_i32 – Fortran Program","text":"public function rank1_arithmetic_mean_i32(data_) result(arithmetic_mean_) Calculate the arithmetic mean of a rank 1 array Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: data_ (:) Rank 1 array containing the elements to calculate the mean for Return Value real(kind=real32) Contents None","tags":"","loc":"proc/rank1_arithmetic_mean_i32.html"},{"title":"rank1_arithmetic_mean_i64 – Fortran Program","text":"public function rank1_arithmetic_mean_i64(data_) result(arithmetic_mean_) Calculate the arithmetic mean of a rank 1 array Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: data_ (:) Return Value real(kind=real64) Rank 1 array containing the elements to calculate the mean for Contents None","tags":"","loc":"proc/rank1_arithmetic_mean_i64.html"},{"title":"rank1_root_mean_squared_mean_r32 – Fortran Program","text":"public function rank1_root_mean_squared_mean_r32(data_) result(rms_) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: data_ (:) Return Value real(kind=real32) Rank 1 array containing the elements to calculate the mean for Contents None","tags":"","loc":"proc/rank1_root_mean_squared_mean_r32.html"},{"title":"rank1_root_mean_squared_mean_r64 – Fortran Program","text":"public function rank1_root_mean_squared_mean_r64(data_) result(rms_) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: data_ (:) Return Value real(kind=real64) Rank 1 array containing the elements to calculate the mean for Contents None","tags":"","loc":"proc/rank1_root_mean_squared_mean_r64.html"},{"title":"rank1_root_mean_squared_mean_i32 – Fortran Program","text":"public function rank1_root_mean_squared_mean_i32(data_) result(rms_) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: data_ (:) Return Value real(kind=real32) Rank 1 array containing the elements to calculate the mean for Contents None","tags":"","loc":"proc/rank1_root_mean_squared_mean_i32.html"},{"title":"rank1_root_mean_squared_mean_i64 – Fortran Program","text":"public function rank1_root_mean_squared_mean_i64(data_) result(rms_) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: data_ (:) Return Value real(kind=real64) Rank 1 array containing the elements to calculate the mean for Contents None","tags":"","loc":"proc/rank1_root_mean_squared_mean_i64.html"},{"title":"rank1_harmonic_mean_r32 – Fortran Program","text":"public function rank1_harmonic_mean_r32(data_) result(harmonic_mean_) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: data_ (:) Return Value real(kind=real32) Rank 1 array containing the elements to calculate the mean for Contents None","tags":"","loc":"proc/rank1_harmonic_mean_r32.html"},{"title":"rank1_harmonic_mean_r64 – Fortran Program","text":"public function rank1_harmonic_mean_r64(data_) result(harmonic_mean_) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: data_ (:) Return Value real(kind=real64) Rank 1 array containing the elements to calculate the mean for Contents None","tags":"","loc":"proc/rank1_harmonic_mean_r64.html"},{"title":"rank1_harmonic_mean_i32 – Fortran Program","text":"public function rank1_harmonic_mean_i32(data_) result(harmonic_mean_) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: data_ (:) Return Value real(kind=real32) Rank 1 array containing the elements to calculate the mean for Contents None","tags":"","loc":"proc/rank1_harmonic_mean_i32.html"},{"title":"rank1_harmonic_mean_i64 – Fortran Program","text":"public function rank1_harmonic_mean_i64(data_) result(harmonic_mean_) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: data_ (:) Return Value real(kind=real64) Rank 1 array containing the elements to calculate the mean for Contents None","tags":"","loc":"proc/rank1_harmonic_mean_i64.html"},{"title":"rank1_geometric_mean_r32 – Fortran Program","text":"public function rank1_geometric_mean_r32(data_) result(geometric_mean_) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: data_ (:) Return Value real(kind=real32) Rank 1 array containing the elements to calculate the mean for Contents None","tags":"","loc":"proc/rank1_geometric_mean_r32.html"},{"title":"rank1_geometric_mean_r64 – Fortran Program","text":"public function rank1_geometric_mean_r64(data_) result(geometric_mean_) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: data_ (:) Return Value real(kind=real64) Rank 1 array containing the elements to calculate the mean for Contents None","tags":"","loc":"proc/rank1_geometric_mean_r64.html"},{"title":"rank1_geometric_mean_i32 – Fortran Program","text":"public function rank1_geometric_mean_i32(data_) result(geometric_mean_) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: data_ (:) Return Value real(kind=real64) Rank 1 array containing the elements to calculate the mean for Contents None","tags":"","loc":"proc/rank1_geometric_mean_i32.html"},{"title":"rank1_geometric_mean_i64 – Fortran Program","text":"public function rank1_geometric_mean_i64(data_) result(geometric_mean_) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: data_ (:) Return Value real(kind=real64) Rank 1 array containing the elements to calculate the mean for Contents None","tags":"","loc":"proc/rank1_geometric_mean_i64.html"},{"title":"std_dev_r32 – Fortran Program","text":"public function std_dev_r32(data) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), dimension(:) :: data Return Value real(kind=real32) population standard deviation Contents None","tags":"","loc":"proc/std_dev_r32.html"},{"title":"std_dev_r64 – Fortran Program","text":"public function std_dev_r64(data) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:) :: data Return Value real(kind=real64) population standard deviation Contents None","tags":"","loc":"proc/std_dev_r64.html"},{"title":"std_dev_i32 – Fortran Program","text":"public function std_dev_i32(data_) result(sigma) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), dimension(:) :: data_ Return Value real(kind=real32) population standard deviation Contents None","tags":"","loc":"proc/std_dev_i32.html"},{"title":"std_dev_i64 – Fortran Program","text":"public function std_dev_i64(data) result(sigma) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), dimension(:) :: data Return Value real(kind=real64) population standard deviation Contents None","tags":"","loc":"proc/std_dev_i64.html"},{"title":"mean – Fortran Program","text":"public interface mean Contents Module Procedures rank_1_mean_r32 rank_1_mean_r64 rank_1_mean_i32 rank_1_mean_i64 Module Procedures public function rank_1_mean_r32 (data_, type) result(mean_) Calculate the mean of a 1d data set, given the \"type\" Read more… Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), dimension(:) :: data_ character(len=*), intent(in), optional :: type Return Value real(kind=real32) public function rank_1_mean_r64 (data_, type) result(mean_) Calculate the mean of a 1d data set, given the \"type\" Read more… Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:) :: data_ character(len=*), intent(in), optional :: type Return Value real(kind=real64) public function rank_1_mean_i32 (data_, type) result(mean_) Calculate the mean of a 1d data set, given the \"type\" Read more… Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), dimension(:) :: data_ character(len=*), intent(in), optional :: type Return Value real(kind=real32) public function rank_1_mean_i64 (data_, type) result(mean_) Calculate the mean of a 1d data set, given the \"type\" Read more… Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), dimension(:) :: data_ character(len=*), intent(in), optional :: type Return Value real(kind=real64)","tags":"","loc":"interface/mean.html"},{"title":"arithmetic_mean – Fortran Program","text":"public interface arithmetic_mean Contents Module Procedures rank1_arithmetic_mean_r32 rank1_arithmetic_mean_r64 rank1_arithmetic_mean_i32 rank1_arithmetic_mean_i64 Module Procedures public function rank1_arithmetic_mean_r32 (data_) result(arithmetic_mean_) Calculate the arithmetic mean of a rank 1 array Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: data_ (:) Return Value real(kind=real32) Rank 1 array containing the elements to calculate the mean for public function rank1_arithmetic_mean_r64 (data_) result(arithmetic_mean_) Calculate the arithmetic mean of a rank 1 array Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: data_ (:) Return Value real(kind=real64) Rank 1 array containing the elements to calculate the mean for public function rank1_arithmetic_mean_i32 (data_) result(arithmetic_mean_) Calculate the arithmetic mean of a rank 1 array Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: data_ (:) Rank 1 array containing the elements to calculate the mean for Return Value real(kind=real32) public function rank1_arithmetic_mean_i64 (data_) result(arithmetic_mean_) Calculate the arithmetic mean of a rank 1 array Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: data_ (:) Return Value real(kind=real64) Rank 1 array containing the elements to calculate the mean for","tags":"","loc":"interface/arithmetic_mean.html"},{"title":"rms_mean – Fortran Program","text":"public interface rms_mean Contents Module Procedures rank1_root_mean_squared_mean_r32 rank1_root_mean_squared_mean_r64 rank1_root_mean_squared_mean_i32 rank1_root_mean_squared_mean_i64 Module Procedures public function rank1_root_mean_squared_mean_r32 (data_) result(rms_) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: data_ (:) Return Value real(kind=real32) Rank 1 array containing the elements to calculate the mean for public function rank1_root_mean_squared_mean_r64 (data_) result(rms_) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: data_ (:) Return Value real(kind=real64) Rank 1 array containing the elements to calculate the mean for public function rank1_root_mean_squared_mean_i32 (data_) result(rms_) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: data_ (:) Return Value real(kind=real32) Rank 1 array containing the elements to calculate the mean for public function rank1_root_mean_squared_mean_i64 (data_) result(rms_) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: data_ (:) Return Value real(kind=real64) Rank 1 array containing the elements to calculate the mean for","tags":"","loc":"interface/rms_mean.html"},{"title":"harmonic_mean – Fortran Program","text":"public interface harmonic_mean Contents Module Procedures rank1_harmonic_mean_r32 rank1_harmonic_mean_r64 rank1_harmonic_mean_i32 rank1_harmonic_mean_i64 Module Procedures public function rank1_harmonic_mean_r32 (data_) result(harmonic_mean_) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: data_ (:) Return Value real(kind=real32) Rank 1 array containing the elements to calculate the mean for public function rank1_harmonic_mean_r64 (data_) result(harmonic_mean_) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: data_ (:) Return Value real(kind=real64) Rank 1 array containing the elements to calculate the mean for public function rank1_harmonic_mean_i32 (data_) result(harmonic_mean_) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: data_ (:) Return Value real(kind=real32) Rank 1 array containing the elements to calculate the mean for public function rank1_harmonic_mean_i64 (data_) result(harmonic_mean_) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: data_ (:) Return Value real(kind=real64) Rank 1 array containing the elements to calculate the mean for","tags":"","loc":"interface/harmonic_mean.html"},{"title":"geometric_mean – Fortran Program","text":"public interface geometric_mean Contents Module Procedures rank1_geometric_mean_r32 rank1_geometric_mean_r64 rank1_geometric_mean_i32 rank1_geometric_mean_i64 Module Procedures public function rank1_geometric_mean_r32 (data_) result(geometric_mean_) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: data_ (:) Return Value real(kind=real32) Rank 1 array containing the elements to calculate the mean for public function rank1_geometric_mean_r64 (data_) result(geometric_mean_) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: data_ (:) Return Value real(kind=real64) Rank 1 array containing the elements to calculate the mean for public function rank1_geometric_mean_i32 (data_) result(geometric_mean_) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: data_ (:) Return Value real(kind=real64) Rank 1 array containing the elements to calculate the mean for public function rank1_geometric_mean_i64 (data_) result(geometric_mean_) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: data_ (:) Return Value real(kind=real64) Rank 1 array containing the elements to calculate the mean for","tags":"","loc":"interface/geometric_mean.html"},{"title":"std_dev – Fortran Program","text":"public interface std_dev Contents Module Procedures std_dev_r32 std_dev_r64 std_dev_i32 std_dev_i64 Module Procedures public function std_dev_r32 (data) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), dimension(:) :: data Return Value real(kind=real32) population standard deviation public function std_dev_r64 (data) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:) :: data Return Value real(kind=real64) population standard deviation public function std_dev_i32 (data_) result(sigma) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), dimension(:) :: data_ Return Value real(kind=real32) population standard deviation public function std_dev_i64 (data) result(sigma) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), dimension(:) :: data Return Value real(kind=real64) population standard deviation","tags":"","loc":"interface/std_dev.html"},{"title":"urand_r32 – Fortran Program","text":"public function urand_r32(min, max) result(x) Return a uniform random variable [min, max) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: min a , inclusive real(kind=real32), intent(in) :: max b , exclusive Return Value real(kind=real32) x \\sim \\mathcal{U}[a, b) Contents None","tags":"","loc":"proc/urand_r32.html"},{"title":"urand_r64 – Fortran Program","text":"public function urand_r64(min, max) result(x) Return a uniform random variable [min, max) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: min a , inclusive real(kind=real64), intent(in) :: max b , exclusive Return Value real(kind=real64) x \\sim \\mathcal{U}[a, b) Contents None","tags":"","loc":"proc/urand_r64.html"},{"title":"urand_i32 – Fortran Program","text":"public function urand_i32(min, max) result(x) Return a uniform random variable [min, max] Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: min a , inclusive integer(kind=int32), intent(in) :: max b , inclusive Return Value integer(kind=int32) x \\sim \\mathcal{U}[a, b] Contents None","tags":"","loc":"proc/urand_i32.html"},{"title":"urand_i64 – Fortran Program","text":"public function urand_i64(min, max) result(x) Return a uniform random variable [min, max] Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: min a , inclusive integer(kind=int64), intent(in) :: max b , inclusive Return Value integer(kind=int64) x \\sim \\mathcal{U}[a, b] Contents None","tags":"","loc":"proc/urand_i64.html"},{"title":"poisson – Fortran Program","text":"public function poisson(k, t, lamda) result(P) Arguments Type Intent Optional Attributes Name integer, intent(in) :: k real, intent(in) :: t real, intent(in) :: lamda Return Value real Contents None","tags":"","loc":"proc/poisson.html"},{"title":"standard_normal_rand – Fortran Program","text":"public function standard_normal_rand() result(x) Arguments None Return Value real(kind=real64) Contents None","tags":"","loc":"proc/standard_normal_rand.html"},{"title":"fill_urand_rank1_r32 – Fortran Program","text":"public subroutine fill_urand_rank1_r32(A, min, max) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(inout), dimension(:) :: A real(kind=real32), intent(in) :: min real(kind=real32), intent(in) :: max Contents None","tags":"","loc":"proc/fill_urand_rank1_r32.html"},{"title":"fill_urand_rank1_r64 – Fortran Program","text":"public subroutine fill_urand_rank1_r64(A, min, max) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:) :: A real(kind=real64), intent(in) :: min real(kind=real64), intent(in) :: max Contents None","tags":"","loc":"proc/fill_urand_rank1_r64.html"},{"title":"fill_urand_rank1_i32 – Fortran Program","text":"public subroutine fill_urand_rank1_i32(A, min, max) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout), dimension(:) :: A integer(kind=int32), intent(in) :: min integer(kind=int32), intent(in) :: max Contents None","tags":"","loc":"proc/fill_urand_rank1_i32.html"},{"title":"fill_urand_rank1_i64 – Fortran Program","text":"public subroutine fill_urand_rank1_i64(A, min, max) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout), dimension(:) :: A integer(kind=int64), intent(in) :: min integer(kind=int64), intent(in) :: max Contents None","tags":"","loc":"proc/fill_urand_rank1_i64.html"},{"title":"fill_urand_rank2_r32 – Fortran Program","text":"public subroutine fill_urand_rank2_r32(A, min, max) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(inout), dimension(:,:) :: A real(kind=real32), intent(in) :: min real(kind=real32), intent(in) :: max Contents None","tags":"","loc":"proc/fill_urand_rank2_r32.html"},{"title":"fill_urand_rank2_r64 – Fortran Program","text":"public subroutine fill_urand_rank2_r64(A, min, max) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:,:) :: A real(kind=real64), intent(in) :: min real(kind=real64), intent(in) :: max Contents None","tags":"","loc":"proc/fill_urand_rank2_r64.html"},{"title":"fill_urand_rank2_i32 – Fortran Program","text":"public subroutine fill_urand_rank2_i32(A, min, max) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout), dimension(:,:) :: A integer(kind=int32), intent(in) :: min integer(kind=int32), intent(in) :: max Contents None","tags":"","loc":"proc/fill_urand_rank2_i32.html"},{"title":"fill_urand_rank2_i64 – Fortran Program","text":"public subroutine fill_urand_rank2_i64(A, min, max) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout), dimension(:,:) :: A integer(kind=int64), intent(in) :: min integer(kind=int64), intent(in) :: max Contents None","tags":"","loc":"proc/fill_urand_rank2_i64.html"},{"title":"fill_urand_rank3_r32 – Fortran Program","text":"public subroutine fill_urand_rank3_r32(A, min, max) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(inout), dimension(:,:,:) :: A real(kind=real32), intent(in) :: min real(kind=real32), intent(in) :: max Contents None","tags":"","loc":"proc/fill_urand_rank3_r32.html"},{"title":"fill_urand_rank3_r64 – Fortran Program","text":"public subroutine fill_urand_rank3_r64(A, min, max) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:,:,:) :: A real(kind=real64), intent(in) :: min real(kind=real64), intent(in) :: max Contents None","tags":"","loc":"proc/fill_urand_rank3_r64.html"},{"title":"fill_urand_rank3_i32 – Fortran Program","text":"public subroutine fill_urand_rank3_i32(A, min, max) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout), dimension(:,:,:) :: A integer(kind=int32), intent(in) :: min integer(kind=int32), intent(in) :: max Contents None","tags":"","loc":"proc/fill_urand_rank3_i32.html"},{"title":"fill_urand_rank3_i64 – Fortran Program","text":"public subroutine fill_urand_rank3_i64(A, min, max) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout), dimension(:,:,:) :: A integer(kind=int64), intent(in) :: min integer(kind=int64), intent(in) :: max Contents None","tags":"","loc":"proc/fill_urand_rank3_i64.html"},{"title":"urand – Fortran Program","text":"public interface urand Return a uniform random variable from min (inclusive) to max (inclusive for integer functions, exclusive for real) Contents Module Procedures urand_r32 urand_r64 urand_i32 urand_i64 Module Procedures public function urand_r32 (min, max) result(x) Return a uniform random variable [min, max) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: min a , inclusive real(kind=real32), intent(in) :: max b , exclusive Return Value real(kind=real32) x \\sim \\mathcal{U}[a, b) public function urand_r64 (min, max) result(x) Return a uniform random variable [min, max) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: min a , inclusive real(kind=real64), intent(in) :: max b , exclusive Return Value real(kind=real64) x \\sim \\mathcal{U}[a, b) public function urand_i32 (min, max) result(x) Return a uniform random variable [min, max] Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: min a , inclusive integer(kind=int32), intent(in) :: max b , inclusive Return Value integer(kind=int32) x \\sim \\mathcal{U}[a, b] public function urand_i64 (min, max) result(x) Return a uniform random variable [min, max] Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: min a , inclusive integer(kind=int64), intent(in) :: max b , inclusive Return Value integer(kind=int64) x \\sim \\mathcal{U}[a, b]","tags":"","loc":"interface/urand.html"},{"title":"fill_urand – Fortran Program","text":"public interface fill_urand Fill a rank 1, 2, or 3 array with a uniform random variable from min (inclusive) to max (inclusive for integer functions, exclusive for real) Example usage: integer , dimension ( 64 ) :: x_i32 real ( real32 ), dimension ( 8 , 8 ) :: x_r32 real ( real64 ), dimension ( 4 , 4 , 4 ) :: x_64 call fill_urand ( x_i32 , 0 , 10 ) ! Fill rank1, integer array call fill_urand ( x_r32 , - 1.0 , 1.0 ) ! Fill rank2, real(real32) array call fill_urand ( x_r64 , - 1 0.d0 , 1 0.d0 ) ! Fill rank3, real(real64) array Contents Module Procedures fill_urand_rank1_r32 fill_urand_rank1_r64 fill_urand_rank1_i32 fill_urand_rank1_i64 fill_urand_rank2_r32 fill_urand_rank2_r64 fill_urand_rank2_i32 fill_urand_rank2_i64 fill_urand_rank3_r32 fill_urand_rank3_r64 fill_urand_rank3_i32 fill_urand_rank3_i64 Module Procedures public subroutine fill_urand_rank1_r32 (A, min, max) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(inout), dimension(:) :: A real(kind=real32), intent(in) :: min real(kind=real32), intent(in) :: max public subroutine fill_urand_rank1_r64 (A, min, max) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:) :: A real(kind=real64), intent(in) :: min real(kind=real64), intent(in) :: max public subroutine fill_urand_rank1_i32 (A, min, max) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout), dimension(:) :: A integer(kind=int32), intent(in) :: min integer(kind=int32), intent(in) :: max public subroutine fill_urand_rank1_i64 (A, min, max) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout), dimension(:) :: A integer(kind=int64), intent(in) :: min integer(kind=int64), intent(in) :: max public subroutine fill_urand_rank2_r32 (A, min, max) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(inout), dimension(:,:) :: A real(kind=real32), intent(in) :: min real(kind=real32), intent(in) :: max public subroutine fill_urand_rank2_r64 (A, min, max) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:,:) :: A real(kind=real64), intent(in) :: min real(kind=real64), intent(in) :: max public subroutine fill_urand_rank2_i32 (A, min, max) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout), dimension(:,:) :: A integer(kind=int32), intent(in) :: min integer(kind=int32), intent(in) :: max public subroutine fill_urand_rank2_i64 (A, min, max) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout), dimension(:,:) :: A integer(kind=int64), intent(in) :: min integer(kind=int64), intent(in) :: max public subroutine fill_urand_rank3_r32 (A, min, max) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(inout), dimension(:,:,:) :: A real(kind=real32), intent(in) :: min real(kind=real32), intent(in) :: max public subroutine fill_urand_rank3_r64 (A, min, max) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:,:,:) :: A real(kind=real64), intent(in) :: min real(kind=real64), intent(in) :: max public subroutine fill_urand_rank3_i32 (A, min, max) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout), dimension(:,:,:) :: A integer(kind=int32), intent(in) :: min integer(kind=int32), intent(in) :: max public subroutine fill_urand_rank3_i64 (A, min, max) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout), dimension(:,:,:) :: A integer(kind=int64), intent(in) :: min integer(kind=int64), intent(in) :: max","tags":"","loc":"interface/fill_urand.html"},{"title":"factorial_int16 – Fortran Program","text":"public recursive function factorial_int16(x) result(x_fact) Recursively compute the factorial of a 16-bit integer. The max value that can be passed is 7\n If x is less than 0 or greater 7, the function will return 0 Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x 0 \\leq x \\leq 7 Return Value integer(kind=int16) x! Contents None","tags":"","loc":"proc/factorial_int16.html"},{"title":"factorial_int32 – Fortran Program","text":"public recursive function factorial_int32(x) result(x_fact) Recursively compute the factorial of a 32-bit integer. The max value that can be passed is 16\n If x is less than 0 or greater 16, the function will return 0 Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x 0 \\leq x \\leq 16 Return Value integer(kind=int32) x! Contents None","tags":"","loc":"proc/factorial_int32.html"},{"title":"factorial_int64 – Fortran Program","text":"public recursive function factorial_int64(x) result(x_fact) Recursively compute the factorial of a 64-bit integer. The max value that can be passed is 20\n If x is less than 0 or greater 20, the function will return 0 Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x 0 \\leq x \\leq 20 Return Value integer(kind=int64) x! Contents None","tags":"","loc":"proc/factorial_int64.html"},{"title":"factorial_int128 – Fortran Program","text":"public recursive function factorial_int128(x) result(x_fact) Recursively compute the factorial of a 128-bit integer [supported on gfortran]. The max value that can be passed is 33\n If x is less than 0 or greater 33, the function will return 0 Arguments Type Intent Optional Attributes Name integer(kind=int128), intent(in) :: x 0 \\leq x \\leq 33 Return Value integer(kind=int128) x! Contents None","tags":"","loc":"proc/factorial_int128.html"},{"title":"exp_series_r32 – Fortran Program","text":"public function exp_series_r32(x) result(exp) Compute e&#94;x using a taylor series with 12 terms Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: x Return Value real Contents None","tags":"","loc":"proc/exp_series_r32.html"},{"title":"exp_series_r64 – Fortran Program","text":"public function exp_series_r64(x) result(exp) Calculate e&#94;x using a taylor series with 20 terms Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x Return Value real(kind=real64) Contents None","tags":"","loc":"proc/exp_series_r64.html"},{"title":"sind_series – Fortran Program","text":"public function sind_series(x_, n_) result(sin_x) Compute sine using a truncated taylor series Arguments Type Intent Optional Attributes Name real, intent(in) :: x_ Angle in degrees integer, intent(in) :: n_ Number of terms to use Return Value real Contents None","tags":"","loc":"proc/sind_series.html"},{"title":"nth_root_r32 – Fortran Program","text":"public function nth_root_r32(x_, n_) result(root_) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: x_ integer, intent(in) :: n_ Return Value real(kind=real32) Contents None","tags":"","loc":"proc/nth_root_r32.html"},{"title":"nth_root_r64 – Fortran Program","text":"public function nth_root_r64(x_, n_) result(root_) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x_ integer, intent(in) :: n_ Return Value real(kind=real64) Contents None","tags":"","loc":"proc/nth_root_r64.html"},{"title":"fibonacci_loop – Fortran Program","text":"public function fibonacci_loop(n) result(f_n) Update current F number\n Update previous two numbers Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: n Nth fibonacci to compute Return Value integer(kind=int64) Contents None","tags":"","loc":"proc/fibonacci_loop.html"},{"title":"factorial – Fortran Program","text":"public interface factorial Compute x! Contents Module Procedures factorial_int16 factorial_int32 factorial_int64 factorial_int128 Module Procedures public recursive function factorial_int16 (x) result(x_fact) Recursively compute the factorial of a 16-bit integer. The max value that can be passed is 7\n If x is less than 0 or greater 7, the function will return 0 Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x 0 \\leq x \\leq 7 Return Value integer(kind=int16) x! public recursive function factorial_int32 (x) result(x_fact) Recursively compute the factorial of a 32-bit integer. The max value that can be passed is 16\n If x is less than 0 or greater 16, the function will return 0 Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x 0 \\leq x \\leq 16 Return Value integer(kind=int32) x! public recursive function factorial_int64 (x) result(x_fact) Recursively compute the factorial of a 64-bit integer. The max value that can be passed is 20\n If x is less than 0 or greater 20, the function will return 0 Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x 0 \\leq x \\leq 20 Return Value integer(kind=int64) x! public recursive function factorial_int128 (x) result(x_fact) Recursively compute the factorial of a 128-bit integer [supported on gfortran]. The max value that can be passed is 33\n If x is less than 0 or greater 33, the function will return 0 Arguments Type Intent Optional Attributes Name integer(kind=int128), intent(in) :: x 0 \\leq x \\leq 33 Return Value integer(kind=int128) x!","tags":"","loc":"interface/factorial.html"},{"title":"nth_root – Fortran Program","text":"public interface nth_root Compute \\sqrt[n]{x} Contents Module Procedures nth_root_r32 nth_root_r64 Module Procedures public function nth_root_r32 (x_, n_) result(root_) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: x_ integer, intent(in) :: n_ Return Value real(kind=real32) public function nth_root_r64 (x_, n_) result(root_) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x_ integer, intent(in) :: n_ Return Value real(kind=real64)","tags":"","loc":"interface/nth_root.html"},{"title":"exp_series – Fortran Program","text":"public interface exp_series Compute e&#94;x using a truncated taylor series Contents Module Procedures exp_series_r32 exp_series_r64 Module Procedures public function exp_series_r32 (x) result(exp) Compute e&#94;x using a taylor series with 12 terms Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: x Return Value real public function exp_series_r64 (x) result(exp) Calculate e&#94;x using a taylor series with 20 terms Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x Return Value real(kind=real64)","tags":"","loc":"interface/exp_series.html"},{"title":"point2_to_array – Fortran Program","text":"public function point2_to_array(self) result(array) Arguments Type Intent Optional Attributes Name class( point2 ), intent(in) :: self Return Value real(kind=real64),\n  dimension(2) Contents None","tags":"","loc":"proc/point2_to_array.html"},{"title":"point2_from_polar_r32 – Fortran Program","text":"public function point2_from_polar_r32(rho, theta) result(point) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: rho real(kind=real32), intent(in) :: theta Return Value type( point2 ) Contents None","tags":"","loc":"proc/point2_from_polar_r32.html"},{"title":"point2_from_polar_r64 – Fortran Program","text":"public function point2_from_polar_r64(rho, theta) result(point) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: rho real(kind=real64), intent(in) :: theta Return Value type( point2 ) Contents None","tags":"","loc":"proc/point2_from_polar_r64.html"},{"title":"point2_from_polar_int – Fortran Program","text":"public function point2_from_polar_int(rho, theta) result(point) Arguments Type Intent Optional Attributes Name integer, intent(in) :: rho integer, intent(in) :: theta Return Value type( point2 ) Contents None","tags":"","loc":"proc/point2_from_polar_int.html"},{"title":"point2_rho – Fortran Program","text":"public function point2_rho(self) result(rho) Calculate the magnitude (distance from the origin) of Arguments Type Intent Optional Attributes Name class( point2 ), intent(in) :: self Return Value real(kind=real64) Contents None","tags":"","loc":"proc/point2_rho.html"},{"title":"point2_theta – Fortran Program","text":"public function point2_theta(self) result(theta) Return the angle (in degrees) of the polar representation of a point Arguments Type Intent Optional Attributes Name class( point2 ), intent(in) :: self Return Value real(kind=real64) Contents None","tags":"","loc":"proc/point2_theta.html"},{"title":"point2_plus_point2 – Fortran Program","text":"public function point2_plus_point2(self, p2) result(p3) Arguments Type Intent Optional Attributes Name class( point2 ), intent(in) :: self class( point2 ), intent(in) :: p2 Return Value type( point2 ) Contents None","tags":"","loc":"proc/point2_plus_point2.html"},{"title":"point2_minus_point2 – Fortran Program","text":"public function point2_minus_point2(self, p2) result(p3) Arguments Type Intent Optional Attributes Name class( point2 ), intent(in) :: self class( point2 ), intent(in) :: p2 Return Value type( point2 ) Contents None","tags":"","loc":"proc/point2_minus_point2.html"},{"title":"point2_unary_minus – Fortran Program","text":"public function point2_unary_minus(self) result(p3) Arguments Type Intent Optional Attributes Name class( point2 ), intent(in) :: self Return Value type( point2 ) Contents None","tags":"","loc":"proc/point2_unary_minus.html"},{"title":"point2_distance_between_point2 – Fortran Program","text":"public function point2_distance_between_point2(self, p2) result(dist) Arguments Type Intent Optional Attributes Name class( point2 ), intent(in) :: self class( point2 ), intent(in) :: p2 Return Value real(kind=real64) Contents None","tags":"","loc":"proc/point2_distance_between_point2.html"},{"title":"point3_to_array – Fortran Program","text":"public function point3_to_array(self) result(array) Arguments Type Intent Optional Attributes Name class( point3 ), intent(in) :: self Return Value real(kind=real64),\n  dimension(3) Contents None","tags":"","loc":"proc/point3_to_array.html"},{"title":"point3_from_spherical_r32 – Fortran Program","text":"public function point3_from_spherical_r32(rho, theta, phi) result(point) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: rho real(kind=real32), intent(in) :: theta real(kind=real32), intent(in) :: phi Return Value type( point3 ) Contents None","tags":"","loc":"proc/point3_from_spherical_r32.html"},{"title":"point3_from_spherical_r64 – Fortran Program","text":"public function point3_from_spherical_r64(rho, theta, phi) result(point) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: rho real(kind=real64), intent(in) :: theta real(kind=real64), intent(in) :: phi Return Value type( point3 ) Contents None","tags":"","loc":"proc/point3_from_spherical_r64.html"},{"title":"point3_from_spherical_int – Fortran Program","text":"public function point3_from_spherical_int(rho, theta, phi) result(point) Arguments Type Intent Optional Attributes Name integer, intent(in) :: rho integer, intent(in) :: theta integer, intent(in) :: phi Return Value type( point3 ) Contents None","tags":"","loc":"proc/point3_from_spherical_int.html"},{"title":"point3_rho – Fortran Program","text":"public function point3_rho(self) result(rho) Calculate the magnitude (distance from the origin) of Arguments Type Intent Optional Attributes Name class( point3 ), intent(in) :: self Return Value real(kind=real64) Contents None","tags":"","loc":"proc/point3_rho.html"},{"title":"point3_theta – Fortran Program","text":"public function point3_theta(self) result(theta) Return the inlination theta Arguments Type Intent Optional Attributes Name class( point3 ), intent(in) :: self Return Value real(kind=real64) Contents None","tags":"","loc":"proc/point3_theta.html"},{"title":"point3_phi – Fortran Program","text":"public function point3_phi(self) result(phi) return the azimuth phi Arguments Type Intent Optional Attributes Name class( point3 ), intent(in) :: self Return Value real(kind=real64) Contents None","tags":"","loc":"proc/point3_phi.html"},{"title":"point3_plus_point3 – Fortran Program","text":"public function point3_plus_point3(self, p2) result(p3) Arguments Type Intent Optional Attributes Name class( point3 ), intent(in) :: self class( point3 ), intent(in) :: p2 Return Value type( point3 ) Contents None","tags":"","loc":"proc/point3_plus_point3.html"},{"title":"point3_minus_point3 – Fortran Program","text":"public function point3_minus_point3(self, p2) result(p3) Arguments Type Intent Optional Attributes Name class( point3 ), intent(in) :: self class( point3 ), intent(in) :: p2 Return Value type( point3 ) Contents None","tags":"","loc":"proc/point3_minus_point3.html"},{"title":"point3_unary_minus – Fortran Program","text":"public function point3_unary_minus(self) result(p3) Arguments Type Intent Optional Attributes Name class( point3 ), intent(in) :: self Return Value type( point3 ) Contents None","tags":"","loc":"proc/point3_unary_minus.html"},{"title":"point3_dot_point3 – Fortran Program","text":"public function point3_dot_point3(self, p2) result(dot) Arguments Type Intent Optional Attributes Name class( point3 ), intent(in) :: self class( point3 ), intent(in) :: p2 Return Value real(kind=real64) Contents None","tags":"","loc":"proc/point3_dot_point3.html"},{"title":"point3_cross_point3 – Fortran Program","text":"public function point3_cross_point3(self, p2) result(p3) Arguments Type Intent Optional Attributes Name class( point3 ), intent(in) :: self class( point3 ), intent(in) :: p2 Return Value type( point3 ) Contents None","tags":"","loc":"proc/point3_cross_point3.html"},{"title":"point3_distance_between_point3 – Fortran Program","text":"public function point3_distance_between_point3(self, p2) result(dist) Arguments Type Intent Optional Attributes Name class( point3 ), intent(in) :: self class( point3 ), intent(in) :: p2 Return Value real(kind=real64) Contents None","tags":"","loc":"proc/point3_distance_between_point3.html"},{"title":"vector3_magnitude – Fortran Program","text":"public function vector3_magnitude(self) result(length) Arguments Type Intent Optional Attributes Name class( vector3 ), intent(in) :: self Return Value real(kind=real64) Contents None","tags":"","loc":"proc/vector3_magnitude.html"},{"title":"vector3_to_array – Fortran Program","text":"public function vector3_to_array(self) result(array) Arguments Type Intent Optional Attributes Name class( vector3 ), intent(in) :: self Return Value real(kind=real64),\n  dimension(3) Contents None","tags":"","loc":"proc/vector3_to_array.html"},{"title":"vector3_plus_vector3 – Fortran Program","text":"public function vector3_plus_vector3(self, v2) result(v3) Arguments Type Intent Optional Attributes Name class( vector3 ), intent(in) :: self class( vector3 ), intent(in) :: v2 Return Value type( vector3 ) Contents None","tags":"","loc":"proc/vector3_plus_vector3.html"},{"title":"vector3_minus_vector3 – Fortran Program","text":"public function vector3_minus_vector3(self, v2) result(v3) Arguments Type Intent Optional Attributes Name class( vector3 ), intent(in) :: self class( vector3 ), intent(in) :: v2 Return Value type( vector3 ) Contents None","tags":"","loc":"proc/vector3_minus_vector3.html"},{"title":"vector3_unary_minus – Fortran Program","text":"public function vector3_unary_minus(self) result(v3) Arguments Type Intent Optional Attributes Name class( vector3 ), intent(in) :: self Return Value type( vector3 ) Contents None","tags":"","loc":"proc/vector3_unary_minus.html"},{"title":"vector3_times_scalar_r32 – Fortran Program","text":"public function vector3_times_scalar_r32(self, k) result(v2) Arguments Type Intent Optional Attributes Name class( vector3 ), intent(in) :: self real(kind=real32), intent(in) :: k Return Value type( vector3 ) Contents None","tags":"","loc":"proc/vector3_times_scalar_r32.html"},{"title":"vector3_times_scalar_r64 – Fortran Program","text":"public function vector3_times_scalar_r64(self, k) result(v2) Arguments Type Intent Optional Attributes Name class( vector3 ), intent(in) :: self real(kind=real64), intent(in) :: k Return Value type( vector3 ) Contents None","tags":"","loc":"proc/vector3_times_scalar_r64.html"},{"title":"vector3_times_scalar_int – Fortran Program","text":"public function vector3_times_scalar_int(self, k) result(v2) Arguments Type Intent Optional Attributes Name class( vector3 ), intent(in) :: self integer, intent(in) :: k Return Value type( vector3 ) Contents None","tags":"","loc":"proc/vector3_times_scalar_int.html"},{"title":"scalar_times_vector3_r32 – Fortran Program","text":"public function scalar_times_vector3_r32(k, v1) result(v2) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: k class( vector3 ), intent(in) :: v1 Return Value type( vector3 ) Contents None","tags":"","loc":"proc/scalar_times_vector3_r32.html"},{"title":"scalar_times_vector3_r64 – Fortran Program","text":"public function scalar_times_vector3_r64(k, v1) result(v2) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: k class( vector3 ), intent(in) :: v1 Return Value type( vector3 ) Contents None","tags":"","loc":"proc/scalar_times_vector3_r64.html"},{"title":"scalar_times_vector3_int – Fortran Program","text":"public function scalar_times_vector3_int(k, v1) result(v2) Arguments Type Intent Optional Attributes Name integer, intent(in) :: k class( vector3 ), intent(in) :: v1 Return Value type( vector3 ) Contents None","tags":"","loc":"proc/scalar_times_vector3_int.html"},{"title":"vector3_dot_vector3 – Fortran Program","text":"public function vector3_dot_vector3(self, v2) result(dot) Arguments Type Intent Optional Attributes Name class( vector3 ), intent(in) :: self class( vector3 ), intent(in) :: v2 Return Value real(kind=real64) Contents None","tags":"","loc":"proc/vector3_dot_vector3.html"},{"title":"vector3_cross_vector3 – Fortran Program","text":"public function vector3_cross_vector3(self, v2) result(normal) Arguments Type Intent Optional Attributes Name class( vector3 ), intent(in) :: self class( vector3 ), intent(in) :: v2 Return Value type( vector3 ) Contents None","tags":"","loc":"proc/vector3_cross_vector3.html"},{"title":"vector3_angle_between_vector3 – Fortran Program","text":"public function vector3_angle_between_vector3(self, v2) result(theta) Return angle between vectors in degrees Arguments Type Intent Optional Attributes Name class( vector3 ), intent(in) :: self class( vector3 ), intent(in) :: v2 Return Value real(kind=real64) Contents None","tags":"","loc":"proc/vector3_angle_between_vector3.html"},{"title":"cross_product_r32 – Fortran Program","text":"public function cross_product_r32(v1, v2) result(normal) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(3) :: v1 Vectors to cross multiply real, intent(in), dimension(3) :: v2 Vectors to cross multiply Return Value real,\n  dimension(3) Normal vector that is the output Contents None","tags":"","loc":"proc/cross_product_r32.html"},{"title":"cross_product_r64 – Fortran Program","text":"public function cross_product_r64(v1, v2) result(normal) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(3) :: v1 Vectors to cross multiply real(kind=real64), intent(in), dimension(3) :: v2 Vectors to cross multiply Return Value real(kind=real64),\n  dimension(3) Normal vector that is the output Contents None","tags":"","loc":"proc/cross_product_r64.html"},{"title":"distance – Fortran Program","text":"public function distance(p1, p2) result(d1) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(3) :: p1 Points to calculate distance between real, intent(in), dimension(3) :: p2 Points to calculate distance between Return Value real Contents None","tags":"","loc":"proc/distance.html"},{"title":"line2_atx – Fortran Program","text":"public function line2_atx(self, x) result(y) Arguments Type Intent Optional Attributes Name class( line2 ), intent(in) :: self real(kind=real64), intent(in) :: x Return Value real(kind=real64) Contents None","tags":"","loc":"proc/line2_atx.html"},{"title":"line2_aty – Fortran Program","text":"public function line2_aty(self, y) result(x) Arguments Type Intent Optional Attributes Name class( line2 ), intent(in) :: self real(kind=real64), intent(in) :: y Return Value real(kind=real64) Contents None","tags":"","loc":"proc/line2_aty.html"},{"title":"point2_from_array_r32 – Fortran Program","text":"public subroutine point2_from_array_r32(point, array) Arguments Type Intent Optional Attributes Name class( point2 ), intent(out) :: point real(kind=real32), intent(in), dimension(2) :: array Contents None","tags":"","loc":"proc/point2_from_array_r32.html"},{"title":"point2_from_array_r64 – Fortran Program","text":"public subroutine point2_from_array_r64(point, array) Arguments Type Intent Optional Attributes Name class( point2 ), intent(out) :: point real(kind=real64), intent(in), dimension(2) :: array Contents None","tags":"","loc":"proc/point2_from_array_r64.html"},{"title":"point2_from_array_int – Fortran Program","text":"public subroutine point2_from_array_int(point, array) Arguments Type Intent Optional Attributes Name class( point2 ), intent(out) :: point integer, intent(in), dimension(2) :: array Contents None","tags":"","loc":"proc/point2_from_array_int.html"},{"title":"point2_print_cartesian – Fortran Program","text":"public subroutine point2_print_cartesian(self) Arguments Type Intent Optional Attributes Name class( point2 ), intent(in) :: self Contents None","tags":"","loc":"proc/point2_print_cartesian.html"},{"title":"point2_print_polar – Fortran Program","text":"public subroutine point2_print_polar(self) Print the polar coordinates of a point in this form Arguments Type Intent Optional Attributes Name class( point2 ), intent(in) :: self Contents None","tags":"","loc":"proc/point2_print_polar.html"},{"title":"point3_from_array_r32 – Fortran Program","text":"public subroutine point3_from_array_r32(point, array) Arguments Type Intent Optional Attributes Name class( point3 ), intent(out) :: point real(kind=real32), intent(in), dimension(3) :: array Contents None","tags":"","loc":"proc/point3_from_array_r32.html"},{"title":"point3_from_array_r64 – Fortran Program","text":"public subroutine point3_from_array_r64(point, array) Arguments Type Intent Optional Attributes Name class( point3 ), intent(out) :: point real(kind=real64), intent(in), dimension(3) :: array Contents None","tags":"","loc":"proc/point3_from_array_r64.html"},{"title":"point3_from_array_int – Fortran Program","text":"public subroutine point3_from_array_int(point, array) Arguments Type Intent Optional Attributes Name class( point3 ), intent(out) :: point integer, intent(in), dimension(3) :: array Contents None","tags":"","loc":"proc/point3_from_array_int.html"},{"title":"point3_print_cartesian – Fortran Program","text":"public subroutine point3_print_cartesian(self) Arguments Type Intent Optional Attributes Name class( point3 ), intent(in) :: self Contents None","tags":"","loc":"proc/point3_print_cartesian.html"},{"title":"point3_print_spherical – Fortran Program","text":"public subroutine point3_print_spherical(self) Print the polar coordinates of a point in this form Arguments Type Intent Optional Attributes Name class( point3 ), intent(in) :: self Contents None","tags":"","loc":"proc/point3_print_spherical.html"},{"title":"vector3_print – Fortran Program","text":"public subroutine vector3_print(self) Arguments Type Intent Optional Attributes Name class( vector3 ), intent(in) :: self Contents None","tags":"","loc":"proc/vector3_print.html"},{"title":"vector3_from_array_r32 – Fortran Program","text":"public subroutine vector3_from_array_r32(vector, array) Arguments Type Intent Optional Attributes Name class( vector3 ), intent(out) :: vector real(kind=real32), intent(in), dimension(3) :: array Contents None","tags":"","loc":"proc/vector3_from_array_r32.html"},{"title":"vector3_from_array_r64 – Fortran Program","text":"public subroutine vector3_from_array_r64(vector, array) Arguments Type Intent Optional Attributes Name class( vector3 ), intent(out) :: vector real(kind=real64), intent(in), dimension(3) :: array Contents None","tags":"","loc":"proc/vector3_from_array_r64.html"},{"title":"vector3_from_array_int – Fortran Program","text":"public subroutine vector3_from_array_int(vector, array) Arguments Type Intent Optional Attributes Name class( vector3 ), intent(out) :: vector integer, intent(in), dimension(3) :: array Contents None","tags":"","loc":"proc/vector3_from_array_int.html"},{"title":"line2_from_two_point2 – Fortran Program","text":"public subroutine line2_from_two_point2(line, two_points) Arguments Type Intent Optional Attributes Name class( line2 ), intent(out) :: line class( point2 ), intent(in), dimension(2), target :: two_points Contents None","tags":"","loc":"proc/line2_from_two_point2.html"},{"title":"line2_print – Fortran Program","text":"public subroutine line2_print(self) Arguments Type Intent Optional Attributes Name class( line2 ), intent(in) :: self Contents None","tags":"","loc":"proc/line2_print.html"},{"title":"cross_product – Fortran Program","text":"public interface cross_product Contents Module Procedures cross_product_r32 cross_product_r64 Module Procedures public function cross_product_r32 (v1, v2) result(normal) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(3) :: v1 Vectors to cross multiply real, intent(in), dimension(3) :: v2 Vectors to cross multiply Return Value real,\n  dimension(3) Normal vector that is the output public function cross_product_r64 (v1, v2) result(normal) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(3) :: v1 Vectors to cross multiply real(kind=real64), intent(in), dimension(3) :: v2 Vectors to cross multiply Return Value real(kind=real64),\n  dimension(3) Normal vector that is the output","tags":"","loc":"interface/cross_product.html"},{"title":"operator(*) – Fortran Program","text":"public interface operator(*) Contents Module Procedures scalar_times_vector3_r32 scalar_times_vector3_r64 scalar_times_vector3_int Module Procedures public function scalar_times_vector3_r32 (k, v1) result(v2) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: k class( vector3 ), intent(in) :: v1 Return Value type( vector3 ) public function scalar_times_vector3_r64 (k, v1) result(v2) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: k class( vector3 ), intent(in) :: v1 Return Value type( vector3 ) public function scalar_times_vector3_int (k, v1) result(v2) Arguments Type Intent Optional Attributes Name integer, intent(in) :: k class( vector3 ), intent(in) :: v1 Return Value type( vector3 )","tags":"","loc":"interface/operator(*).html"},{"title":"intersection_int – Fortran Program","text":"public function intersection_int(A, B) result(inters) Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:) :: A set A integer, intent(in), dimension(:) :: B set B Return Value integer,\n  dimension(:),allocatable A \\cap B Contents None","tags":"","loc":"proc/intersection_int.html"},{"title":"intersection_r32 – Fortran Program","text":"public function intersection_r32(A, B) result(inters) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), dimension(:) :: A set A real(kind=real32), intent(in), dimension(:) :: B set B Return Value real(kind=real32),\n  dimension(:),allocatable A \\cap B Contents None","tags":"","loc":"proc/intersection_r32.html"},{"title":"intersection_r64 – Fortran Program","text":"public function intersection_r64(A, B) result(inters) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:) :: A set A real(kind=real64), intent(in), dimension(:) :: B set B Return Value real(kind=real64),\n  dimension(:),allocatable A \\cap B Contents None","tags":"","loc":"proc/intersection_r64.html"},{"title":"union_int – Fortran Program","text":"public function union_int(A, B) result(union_set) Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:) :: A set A integer, intent(in), dimension(:) :: B set B Return Value integer,\n  dimension(:),allocatable A \\cup B Contents None","tags":"","loc":"proc/union_int.html"},{"title":"union_r32 – Fortran Program","text":"public function union_r32(A, B) result(union_set) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), dimension(:) :: A set A real(kind=real32), intent(in), dimension(:) :: B set B Return Value real(kind=real32),\n  dimension(:),allocatable A \\cup B Contents None","tags":"","loc":"proc/union_r32.html"},{"title":"union_r64 – Fortran Program","text":"public function union_r64(A, B) result(union_set) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:) :: A set A real(kind=real64), intent(in), dimension(:) :: B set B Return Value real(kind=real64),\n  dimension(:),allocatable A \\cup B Contents None","tags":"","loc":"proc/union_r64.html"},{"title":"belongs_to_int – Fortran Program","text":"public function belongs_to_int(x, A) result(bool) Check if a value x belongs to a set \\textrm{A} Arguments Type Intent Optional Attributes Name integer, intent(in) :: x integer, dimension(:) :: A Return Value logical Contents None","tags":"","loc":"proc/belongs_to_int.html"},{"title":"belongs_to_r32 – Fortran Program","text":"public function belongs_to_r32(x, A, eps) result(bool) Check if a value x belongs to a set within a certain tolerance \\epsilon . If \\epsilon is not specified, it will automatically\n calculated using the \\verb|array_epsilon| function Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: x real(kind=real32), dimension(:) :: A real(kind=real32), optional :: eps x = y \\iff \\textrm{abs}(x - y) < \\epsilon Return Value logical Contents None","tags":"","loc":"proc/belongs_to_r32.html"},{"title":"belongs_to_r64 – Fortran Program","text":"public function belongs_to_r64(x, A, eps) result(bool) Check if a value x belongs to a set within a certain tolerance \\epsilon . If \\epsilon is not specified, it will automatically\n calculated using the \\verb|array_epsilon| function Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x real(kind=real64), dimension(:) :: A real(kind=real64), optional :: eps x = y \\iff \\textrm{abs}(x - y) < \\epsilon Return Value logical Contents None","tags":"","loc":"proc/belongs_to_r64.html"},{"title":"array_epsilon_r32 – Fortran Program","text":"public function array_epsilon_r32(array) result(eps) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), dimension(:) :: array Return Value real(kind=real32) Contents None","tags":"","loc":"proc/array_epsilon_r32.html"},{"title":"array_epsilon_r64 – Fortran Program","text":"public function array_epsilon_r64(array) result(eps) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:) :: array Return Value real(kind=real64) Contents None","tags":"","loc":"proc/array_epsilon_r64.html"},{"title":"abs_max_val_r32 – Fortran Program","text":"public function abs_max_val_r32(array) result(abs_max_val) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), dimension(:) :: array Return Value real(kind=real32) Contents None","tags":"","loc":"proc/abs_max_val_r32.html"},{"title":"abs_max_val_r64 – Fortran Program","text":"public function abs_max_val_r64(array) result(abs_max_val) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:) :: array Return Value real(kind=real64) Contents None","tags":"","loc":"proc/abs_max_val_r64.html"},{"title":"intersection – Fortran Program","text":"public interface intersection Compute the intersection of two sets Contents Module Procedures intersection_int intersection_r32 intersection_r64 Module Procedures public function intersection_int (A, B) result(inters) Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:) :: A set A integer, intent(in), dimension(:) :: B set B Return Value integer,\n  dimension(:), allocatable A \\cap B public function intersection_r32 (A, B) result(inters) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), dimension(:) :: A set A real(kind=real32), intent(in), dimension(:) :: B set B Return Value real(kind=real32),\n  dimension(:), allocatable A \\cap B public function intersection_r64 (A, B) result(inters) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:) :: A set A real(kind=real64), intent(in), dimension(:) :: B set B Return Value real(kind=real64),\n  dimension(:), allocatable A \\cap B","tags":"","loc":"interface/intersection.html"},{"title":"union – Fortran Program","text":"public interface union Compute the union of two sets Contents Module Procedures union_int union_r32 union_r64 Module Procedures public function union_int (A, B) result(union_set) Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:) :: A set A integer, intent(in), dimension(:) :: B set B Return Value integer,\n  dimension(:), allocatable A \\cup B public function union_r32 (A, B) result(union_set) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), dimension(:) :: A set A real(kind=real32), intent(in), dimension(:) :: B set B Return Value real(kind=real32),\n  dimension(:), allocatable A \\cup B public function union_r64 (A, B) result(union_set) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:) :: A set A real(kind=real64), intent(in), dimension(:) :: B set B Return Value real(kind=real64),\n  dimension(:), allocatable A \\cup B","tags":"","loc":"interface/union.html"},{"title":"belongs_to – Fortran Program","text":"public interface belongs_to Check if x \\in \\textrm{A} x belongs to A if there is at least one element y in A for which x = y Contents Module Procedures belongs_to_int belongs_to_r32 belongs_to_r64 Module Procedures public function belongs_to_int (x, A) result(bool) Check if a value x belongs to a set \\textrm{A} Arguments Type Intent Optional Attributes Name integer, intent(in) :: x integer, dimension(:) :: A Return Value logical public function belongs_to_r32 (x, A, eps) result(bool) Check if a value x belongs to a set within a certain tolerance \\epsilon . If \\epsilon is not specified, it will automatically\n calculated using the \\verb|array_epsilon| function Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: x real(kind=real32), dimension(:) :: A real(kind=real32), optional :: eps x = y \\iff \\textrm{abs}(x - y) < \\epsilon Return Value logical public function belongs_to_r64 (x, A, eps) result(bool) Check if a value x belongs to a set within a certain tolerance \\epsilon . If \\epsilon is not specified, it will automatically\n calculated using the \\verb|array_epsilon| function Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x real(kind=real64), dimension(:) :: A real(kind=real64), optional :: eps x = y \\iff \\textrm{abs}(x - y) < \\epsilon Return Value logical","tags":"","loc":"interface/belongs_to.html"},{"title":"array_epsilon – Fortran Program","text":"public interface array_epsilon Contents Module Procedures array_epsilon_r32 array_epsilon_r64 Module Procedures public function array_epsilon_r32 (array) result(eps) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), dimension(:) :: array Return Value real(kind=real32) public function array_epsilon_r64 (array) result(eps) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:) :: array Return Value real(kind=real64)","tags":"","loc":"interface/array_epsilon.html"},{"title":"abs_max_val – Fortran Program","text":"public interface abs_max_val Contents Module Procedures abs_max_val_r32 abs_max_val_r64 Module Procedures public function abs_max_val_r32 (array) result(abs_max_val) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), dimension(:) :: array Return Value real(kind=real32) public function abs_max_val_r64 (array) result(abs_max_val) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:) :: array Return Value real(kind=real64)","tags":"","loc":"interface/abs_max_val.html"},{"title":"chapter_select – Fortran Program","text":"subroutine chapter_select() Arguments None Contents None","tags":"","loc":"proc/chapter_select.html"},{"title":"chapter_selected – Fortran Program","text":"subroutine chapter_selected(chp) Arguments Type Intent Optional Attributes Name integer, intent(in) :: chp Contents None","tags":"","loc":"proc/chapter_selected.html"},{"title":"problem_select – Fortran Program","text":"subroutine problem_select() Arguments None Contents None","tags":"","loc":"proc/problem_select.html"},{"title":"program_start – Fortran Program","text":"subroutine program_start() Arguments None Contents None","tags":"","loc":"proc/program_start.html"},{"title":"program_end – Fortran Program","text":"subroutine program_end() Arguments None Contents None","tags":"","loc":"proc/program_end.html"},{"title":"to_continue – Fortran Program","text":"subroutine to_continue() Arguments None Contents None","tags":"","loc":"proc/to_continue.html"},{"title":"chapter_4 – Fortran Program","text":"All of the programming exercises for Chapter 4: Loops and Character Manipulation Uses iso_fortran_env Contents Functions is_alphnum is_alph is_num is_lower is_upper calc_current_flow to_kelvin to_celcius Subroutines p4_1 p4_3 p4_4 p4_5 p4_6 p4_7 p4_8 p4_9 p4_10 p4_11 p4_12 p4_13 p4_14 p4_15 p4_16 p4_17 p4_18 p4_19 to_lower to_upper Functions public function is_alphnum (char) Test whether an ASCII character is alpha-numeric Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: char Return Value logical public function is_alph (char) Test whether an ASCII character is a letter Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: char Return Value logical public function is_num (char) Test whether an ASCII character is numeric Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: char Return Value logical public function is_lower (char) Test whether an ASCII character is a lowercase letter Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: char Return Value logical public function is_upper (char) Test whether an ASCII character is an uppercase letter Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: char Return Value logical public elemental function calc_current_flow (v_D, I_O, T) result(i_D) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: v_D The voltage across the diode, in volts real(kind=real64), intent(in) :: I_O The leakage current of the diode, in amperes real(kind=real64), intent(in) :: T Temperature, in kelvins (K) Return Value real(kind=real64) The current flow through the diode in amperes public elemental function to_kelvin (F) Convert a temperature in Fahrenheit to Kelvin Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: F Return Value real(kind=real64) public elemental function to_celcius (F) Convert a temperature from Fahrenheit to celcius Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: F Return Value real(kind=real64) Subroutines public subroutine p4_1 () Test if the following equalities are valid statements, and if they are,\n evaluate them Arguments None public subroutine p4_3 () Write a Fortran program to evaluate the equation y(x) = x&#94;2 - 3x + 2 for all values between -1 and 3,\n in steps of 0.1. Arguments None public subroutine p4_4 () Write the Fortran statements required to calculate y(t) from the equation: Read more… Arguments None public subroutine p4_5 () Write a Fortran program to calculate the factorial function. Be sure to handle the special \n cases of 0! and of illegal input values. Arguments None public subroutine p4_6 () What is the difference in behavior between a cycle statement and an exit statement? Arguments None public subroutine p4_7 () Modify program stats_2 to use the DO WHILE construct instaed of the while construct currently in the program Read more… Arguments None public subroutine p4_8 () Examine the following DO statements and determine how many times each loop will\n be exectued. Read more… Arguments None public subroutine p4_9 () Examine the following loops, determine the value of ires and the number of times\n each loop executes Arguments None public subroutine p4_10 () Examine the followin while loops and determine the value of ires at the end of each of \n the loops. Arguments None public subroutine p4_11 () Modify program ball from example 4-7 to read in the acceleration due to gravity\n at a particular location, and to calculate the maximum range of the ball for that acceleration.\n After modifying the program, run it with accelerations of -9.8, -9.7, and -9.6m/s2. Read more… Arguments None public subroutine p4_12 () Modify program ball from Example 4-7 to read in the initial velocity with which the ball\n is thrown. After modifying the program, run it with initial velocities of 10, 20, and 20 \n m/sec. What effect does changin the initial velocity have on the range of the ball? What\n effect does it have on the best angle theta at which to throw the ball? Arguments None public subroutine p4_13 () Arguments None public subroutine p4_14 () Write a Fortran program to evaluate the function \n y(x) = ln(1/1-x)\n for any user-specified value of x, where ln is the natural logarithm.\n Write the program with a while loop, so that the program repeats the calculation \n for each legal value of x entered into the program. When an illegal value of x is entered,\n terminate the program. Arguments None public subroutine p4_15 () Write a Fortran program to convert all uppercase characters in a user-supplied character\n string to lowercase, without changing the uppercase and nonalphabetic characters in the string.\n Assume that your computer uses the ASCII collating sequence. Arguments None public subroutine p4_16 () Calculating Orbits. Read more… Arguments None public subroutine p4_17 () Write a program caps that reads in a character string, searches for all of the words \n within the string, and capitalizes the first letter of each word, while shifting the \n remainder of the word to lowercase. Assume that all nonalphabetic and nonumeric characters\n can mark the boundaries of a word within the character variable (periods, commas,etc.). \n Nonalphabetic characters should be left unchanged. Arguments None public subroutine p4_18 () Write a computer program to calculate the current flowing through this diode\n for all voltages from -1.0V to +0.6 V, in 0.1 V steps. Repeat this process for the \n following temperatures: 75F, 100F, and 125F Arguments None public subroutine p4_19 () Write a program that promps a user for a binary number, which will be entered as a string\n of 0s and 1s in a character variable. This program should be able to handle numbers whos\n binary representation is up to 10 bits, corresponding to values from 0 to 1023. Arguments None public subroutine to_lower (char) Convert a single character to lowercase Arguments Type Intent Optional Attributes Name character(len=1), intent(inout) :: char public subroutine to_upper (char) Convert a single character to uppercase Arguments Type Intent Optional Attributes Name character(len=1), intent(inout) :: char","tags":"","loc":"module/chapter_4.html"},{"title":"chapter_7 – Fortran Program","text":"All of the programming exercises for Chapter 7: Procedures Uses iso_fortran_env Contents Subroutines p7_1 p7_2 p7_3 p7_4 p7_5 p7_6 p7_7 p7_8 p7_9 p7_10 Subroutines public subroutine p7_1 () DISCUSSION QUESTION What is the difference between a subroutine and a function? Arguments None public subroutine p7_2 () DISCUSSION QUESTION When a subroutine is called, how is data passed from the calling program to the subroutine,\n and how are the results of the subroutine returned to the calling program? Arguments None public subroutine p7_3 () DISCUSSION QUESTION What are the advantages and disadvantages of the pass-by-reference scheme used in Fortran? Arguments None public subroutine p7_4 () DISCUSSION QUESTION What are the advantages and disadvantages of each procedure array type? Arguments None public subroutine p7_5 () DISCUSSION QUESTION Suppose a 15-element array is passed to a subroutine. What happens if the subroutine attempts\n to write to element a(16)? Arguments None public subroutine p7_6 () DISCUSSION QUESTION If a real value is passed to a subroutine in an argument that is declared to be an integer,\n what happens? Arguments None public subroutine p7_7 () DISCUSSION QUESTION How can p7_6 be modified so that the compiler catches the argument mismatch between\n the actual argument and the dummy argument in the subroutine? Arguments None public subroutine p7_8 () DISCUSSION QUESTION What is the purpose of the INTENT attribute? Where can it be used? Why should it be used? Arguments None public subroutine p7_9 () NOT APPLICABLE Arguments None public subroutine p7_10 () NOT APPLICABLE Arguments None","tags":"","loc":"module/chapter_7.html"},{"title":"chapter_6 – Fortran Program","text":"Arrays Uses iso_fortran_env Contents Subroutines p6_1 p6_3 p6_4 p6_5 p6_6 p6_7 p6_8 p6_10 p6_11 Subroutines public subroutine p6_1 () DISCUSSION QUESTION How may arrays be declared? Arguments None public subroutine p6_3 () DISCUSSION QUESTION Execute this subroutine on your computer with both bounds checking turned on and \n bounds checking turned off. What happens? Arguments None public subroutine p6_4 () DISCUSSION QUESTION Determine the shape and size of the arrays specified by the following statements: Arguments None public subroutine p6_5 () DISCUSSION QUESTION Determine which of the following Fortran program fragments are valid. For each valid statement,\n specify what will happen in the program. (Assume default typing for any variables that are not \n explicitly typed within the program fragments.) Arguments None public subroutine p6_6 () DISCUSSION QUESTION What is meant by each of the following array terms? Size, shape, extent, rank, conformable. Arguments None public subroutine p6_7 () DISCUSSION QUESTION Given an array my_array defined as shown, determine whether each of the following\n array sections is valid Arguments None public subroutine p6_8 () DISCUSSION QUESTION What will the output from each of the WRITE statements in the following subroutine be?\n Why is the output of the two statements different? Arguments None public subroutine p6_10 () Polar to Rectangular Conversion Read more… Arguments None public subroutine p6_11 () Rectangular to Polar Conversion Read more… Arguments None","tags":"","loc":"module/chapter_6.html"},{"title":"chapter_5 – Fortran Program","text":"All of the programming exercises for Chapter 5: Basic IO Uses iso_fortran_env Contents Subroutines p5_1 p5_2 p5_3 p5_4 p5_5 p5_6 Subroutines public subroutine p5_1 () DISCUSSION QUESTION What is the purpose of a format? What are the three ways to define a format? Arguments None public subroutine p5_2 () DISCUSSION QUESTION What is printed out by the following Fortran statements? Arguments None public subroutine p5_3 () DISCUSSION QUESTION What is printed out by the following Fortran statements? Arguments None public subroutine p5_4 (file_name) DISCUSSION QUESTION Read in 5_4.dat and find out what the output will be for the following statements: Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name public subroutine p5_5 (file_name) DISCUSSION QUESTION Read in 5_5.dat and find out what the value of each variable will be when the \n READ statements have been completed Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name public subroutine p5_6 () Generate a table of the base 10 logarithms between 1 and 10 in steps of 0.1 Arguments None","tags":"","loc":"module/chapter_5.html"},{"title":"foreng – Fortran Program","text":"Uses foreng_math foreng_numeric foreng_io foreng_science Contents None","tags":"","loc":"module/foreng.html"},{"title":"foreng_env – Fortran Program","text":"Top level module for all of the useful functions written for Fortran for Scientists and Engineers Uses iso_fortran_env Contents Variables PI_64 PI PI_32 int128 Variables Type Visibility Attributes Name Initial real(kind=real64), public, parameter :: PI_64 = 3.141592653589793 real(kind=real64), public, parameter :: PI = PI_64 real(kind=real32), public, parameter :: PI_32 = 3.14159265 integer, public, parameter :: int128 = selected_int_kind(38)","tags":"","loc":"module/foreng_env.html"},{"title":"foreng_io_char – Fortran Program","text":"A module to deal with the manipulation of characters based on their ASCII collating sequence. This module provides public parameters that are common ASCII cutoff values when dealing with alphanumeric characters. Contents Variables ZERO_ASCII NINE_ASCII UPPER_A_ASCII UPPER_Z_ASCII LOWER_A_ASCII LOWER_Z_ASCII UPPER_LOWER_OFFSET Functions is_alphnum is_alph is_num is_lower is_upper to_lower to_upper Variables Type Visibility Attributes Name Initial integer, public, parameter :: ZERO_ASCII = 48 ASCII value of the digit '0' integer, public, parameter :: NINE_ASCII = 57 ASCII value of the digit '9' integer, public, parameter :: UPPER_A_ASCII = 65 ASCII VALUE of the character 'A' integer, public, parameter :: UPPER_Z_ASCII = 90 ASCII VALUE of the character 'Z' integer, public, parameter :: LOWER_A_ASCII = 97 ASCII VALUE of the character 'a' integer, public, parameter :: LOWER_Z_ASCII = 122 ASCII VALUE of the character 'z' integer, public, parameter :: UPPER_LOWER_OFFSET = 32 The difference between UPPER_A_ASCII and LOWER_A_ASCII Functions public elemental function is_alphnum (char) Check if a character is alphanumeric\n This function checks the ASCII collating sequence of the passed character and returns true if the character is alpha (A-Z, a-z) or numeric (0-9) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: char Return Value logical public elemental function is_alph (char) Check if a character belongs to the alphabet\n This function checks the ASCII collating sequence of the passed character and returns true if the character belongs to the Roman alphabet. Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: char Return Value logical public elemental function is_num (char) Check if a character is a numerical digit.\n Return true if a character is between 0-9 Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: char Return Value logical public elemental function is_lower (char) Check if a character is a lowercase alpha character\n Returns true if the ASCII value of char lies between LOWER_A_ASCII and LOWER_Z_ASCII Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: char Return Value logical public elemental function is_upper (char) Check if a character is a uppercase alpha character\n Returns true if the ASCII value of char lies between UPPER_A_ASCII and UPPER_Z_ASCII Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: char Return Value logical public elemental function to_lower (char) result(char_upper) Convert an uppercase alpha character to its lowercase counterpart. If the passed character is not uppercase, return the same character. Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: char Return Value character(len=1) public elemental function to_upper (char) result(char_lower) Convert a lowercase alpha character to its uppercase counterpart. If the passed character is not lowercase, return the same character. Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: char Return Value character(len=1)","tags":"","loc":"module/foreng_io_char.html"},{"title":"foreng_io – Fortran Program","text":"Top-level Foreng module grouping modules that manipulate strings, characters, and input/output. Uses foreng_io_char Contents None","tags":"","loc":"module/foreng_io.html"},{"title":"foreng_numeric – Fortran Program","text":"Top level module used to store all the functionality relating to numerical analysis Uses foreng_numeric_matrices foreng_numeric_regression foreng_numeric_calculus Contents None","tags":"","loc":"module/foreng_numeric.html"},{"title":"foreng_numeric_matrices – Fortran Program","text":"Uses foreng_env Used by Descendants: foreng_numeric_matrices_gauss foreng_numeric_matrices_inverse Contents Interfaces gauss_elim inverse lu eliminate_column gauss_elim_sing_32 gauss_elim_sing_64 gauss_elim_sing_128 gauss_elim_mult_32 gauss_elim_mult_64 gauss_elim_mult_128 gauss_elim_inverse_32 gauss_elim_inverse_64 gauss_elim_inverse_128 eliminate_column_32 eliminate_column_64 eliminate_column_128 lu_decomp_32 lu_decomp_64 lu_decomp_128 Interfaces public interface gauss_elim public interface gauss_elim_sing_32 () Arguments None public interface gauss_elim_sing_64 () Arguments None public interface gauss_elim_sing_128 () Arguments None public interface gauss_elim_mult_32 () Arguments None public interface gauss_elim_mult_64 () Arguments None public interface gauss_elim_mult_128 () Arguments None public interface inverse public interface gauss_elim_inverse_32 () Arguments None public interface gauss_elim_inverse_64 () Arguments None public interface gauss_elim_inverse_128 () Arguments None public interface lu public interface lu_decomp_32 () Arguments None public interface lu_decomp_64 () Arguments None public interface lu_decomp_128 () Arguments None public interface eliminate_column public interface eliminate_column_32 () Arguments None public interface eliminate_column_64 () Arguments None public interface eliminate_column_128 () Arguments None interface public module function gauss_elim_sing_32(A, b) result(x) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), DIMENSION(:,:) :: A real(kind=real32), intent(in), DIMENSION(size(A,DIM=1)) :: b Return Value real(kind=real32),\n  DIMENSION(size(A,DIM=1)) interface public module function gauss_elim_sing_64(A, b) result(x) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), DIMENSION(:,:) :: A real(kind=real64), intent(in), DIMENSION(size(A,DIM=1)) :: b Return Value real(kind=real64),\n  DIMENSION(size(A,DIM=1)) interface public module function gauss_elim_sing_128(A, b) result(x) Arguments Type Intent Optional Attributes Name real(kind=real128), intent(in), DIMENSION(:,:) :: A real(kind=real128), intent(in), DIMENSION(size(A,DIM=1)) :: b Return Value real(kind=real128),\n  DIMENSION(size(A,DIM=1)) interface public module function gauss_elim_mult_32(A, b) result(x) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), DIMENSION(:,:) :: A real(kind=real32), intent(in), DIMENSION(:,:) :: b Return Value real(kind=real32),\n  DIMENSION(size(A,DIM=1), size(b,DIM=2)) interface public module function gauss_elim_mult_64(A, b) result(x) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), DIMENSION(:,:) :: A real(kind=real64), intent(in), DIMENSION(:,:) :: b Return Value real(kind=real64),\n  DIMENSION(size(A,DIM=1), size(b,DIM=2)) interface public module function gauss_elim_mult_128(A, b) result(x) Arguments Type Intent Optional Attributes Name real(kind=real128), intent(in), DIMENSION(:,:) :: A real(kind=real128), intent(in), DIMENSION(:,:) :: b Return Value real(kind=real128),\n  DIMENSION(size(A,DIM=1), size(b,DIM=2)) interface public module function gauss_elim_inverse_32(A) result(A_inv) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), DIMENSION(:,:) :: A Return Value real(kind=real32),\n  DIMENSION(size(A, DIM=1), size(A,DIM=1)) interface public module function gauss_elim_inverse_64(A) result(A_inv) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), DIMENSION(:,:) :: A Return Value real(kind=real64),\n  DIMENSION(size(A, DIM=1), size(A,DIM=1)) interface public module function gauss_elim_inverse_128(A) result(A_inv) Arguments Type Intent Optional Attributes Name real(kind=real128), intent(in), DIMENSION(:,:) :: A Return Value real(kind=real128),\n  DIMENSION(size(A, DIM=1), size(A,DIM=1)) interface public subroutine eliminate_column_32(A, icol, order) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(inout), DIMENSION(:,:) :: A integer, intent(in) :: icol integer, intent(inout), DIMENSION(:) :: order interface public subroutine eliminate_column_64(A, icol, order) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), DIMENSION(:,:) :: A integer, intent(in) :: icol integer, intent(inout), DIMENSION(:) :: order interface public subroutine eliminate_column_128(A, icol, order) Arguments Type Intent Optional Attributes Name real(kind=real128), intent(inout), DIMENSION(:,:) :: A integer, intent(in) :: icol integer, intent(inout), DIMENSION(:) :: order interface public subroutine lu_decomp_32(A, L, U) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), DIMENSION(:,:) :: A real(kind=real32), intent(out), DIMENSION(:,:), ALLOCATABLE :: L real(kind=real32), intent(out), DIMENSION(:,:), ALLOCATABLE :: U interface public subroutine lu_decomp_64(A, L, U) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), DIMENSION(:,:) :: A real(kind=real64), intent(out), DIMENSION(:,:), ALLOCATABLE :: L real(kind=real64), intent(out), DIMENSION(:,:), ALLOCATABLE :: U interface public subroutine lu_decomp_128(A, L, U) Arguments Type Intent Optional Attributes Name real(kind=real128), intent(in), DIMENSION(:,:) :: A real(kind=real128), intent(out), DIMENSION(:,:), ALLOCATABLE :: L real(kind=real128), intent(out), DIMENSION(:,:), ALLOCATABLE :: U","tags":"","loc":"module/foreng_numeric_matrices.html"},{"title":"foreng_numeric_regression – Fortran Program","text":"Uses foreng_env foreng_math Contents Functions calc_m_lls calc_b_lls calc_correlation_coefficient_lls Subroutines lls_fit lls_coefficient_fit generate_sys_eqns Functions public function calc_m_lls (X, Y) result(m) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), dimension(:) :: X real(kind=real32), intent(in), dimension(:) :: Y Return Value real(kind=real32) public function calc_b_lls (y_bar, x_bar, m) result(b) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: y_bar real(kind=real32), intent(in) :: x_bar real(kind=real32), intent(in) :: m Return Value real(kind=real32) public function calc_correlation_coefficient_lls (X, Y) result(r) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), dimension(:) :: X real(kind=real32), intent(in), dimension(:) :: Y Return Value real Subroutines public subroutine lls_fit (X, Y, m, b, stat) Linear Least Squares Fit Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), dimension(:) :: X real(kind=real32), intent(in), dimension(:) :: Y real(kind=real32), intent(out) :: m real(kind=real32), intent(out) :: b integer, optional :: stat public subroutine lls_coefficient_fit (X, Y, m, b, r, stat) Linear Least Squares Fit with correlation coefficient Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), dimension(:) :: X real(kind=real32), intent(in), dimension(:) :: Y real(kind=real32), intent(out) :: m real(kind=real32), intent(out) :: b real(kind=real32), intent(out) :: r integer, optional :: stat public subroutine generate_sys_eqns (X, Y, order, A, u) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:) :: X real(kind=real64), intent(in), dimension(:) :: Y integer, intent(in) :: order real(kind=real64), intent(out), dimension(:,:), allocatable :: A real(kind=real64), intent(out), dimension(:), allocatable :: u","tags":"","loc":"module/foreng_numeric_regression.html"},{"title":"foreng_numeric_conversion – Fortran Program","text":"Uses foreng_env Contents None","tags":"","loc":"module/foreng_numeric_conversion.html"},{"title":"foreng_numeric_calculus – Fortran Program","text":"Uses foreng_env Contents Functions calc_derivative Functions public function calc_derivative (func, x_0, dx) result(dydx) Arguments Type Intent Optional Attributes Name real(kind=real64), external :: func Ptr to an external function real(kind=real64), intent(in) :: x_0 Value at which to calculate the derivative real(kind=real64), optional :: dx Optional step size. If not present, defaults to 10&#94;{-100} Return Value real(kind=real64) \\frac{dy}{dx} at x = x_0","tags":"","loc":"module/foreng_numeric_calculus.html"},{"title":"foreng_science_phys – Fortran Program","text":"Uses foreng_env foreng_science_const Contents Functions calc_tension calc_decibels calc_gravity Functions public function calc_tension (W_, lc_, lp_, d_) result(T_) Arguments Type Intent Optional Attributes Name real, intent(in) :: W_ Weight of the object (kg) real, intent(in) :: lc_ length of the cable (m) real, intent(in) :: lp_ Length of the pole (m) real, intent(in) :: d_ Distance to attach the weight (m) Return Value real Tension in N public function calc_decibels (P1_, P2_) result(dB_) Arguments Type Intent Optional Attributes Name real, intent(in) :: P1_ real, intent(in) :: P2_ Return Value real public function calc_gravity (m1, m2, r) result(F) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: m1 mass of body 1 in kg real(kind=real64), intent(in) :: m2 mass of body 2 in kg real(kind=real64), intent(in) :: r distance between bodies in meters Return Value real(kind=real64) Gravitational force","tags":"","loc":"module/foreng_science_phys.html"},{"title":"foreng_science_temp – Fortran Program","text":"Uses foreng_env Contents Interfaces fahrenheit_to_celcius celcius_to_fahrenheit celcius_to_kelvin kelvin_to_celcius kelvin_to_fahrenheit fahrenheit_to_kelvin Functions fahrenheit_to_celcius_r32 fahrenheit_to_celcius_r64 celcius_to_fahrenheit_r32 celcius_to_fahrenheit_r64 celcius_to_kelvin_r32 celcius_to_kelvin_r64 kelvin_to_celcius_r32 kelvin_to_celcius_r64 kelvin_to_fahrenheit_r32 kelvin_to_fahrenheit_r64 fahrenheit_to_kelvin_r32 fahrenheit_to_kelvin_r64 Interfaces public interface fahrenheit_to_celcius public elemental function fahrenheit_to_celcius_r32 (F) result(C) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: F Return Value real(kind=real32) public elemental function fahrenheit_to_celcius_r64 (F) result(C) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: F Return Value real(kind=real64) public interface celcius_to_fahrenheit public elemental function celcius_to_fahrenheit_r32 (C) result(F) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: C Return Value real(kind=real32) public elemental function celcius_to_fahrenheit_r64 (C) result(F) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: C Return Value real(kind=real64) public interface celcius_to_kelvin public elemental function celcius_to_kelvin_r32 (C) result(K) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: C Return Value real(kind=real32) public elemental function celcius_to_kelvin_r64 (C) result(K) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: C Return Value real(kind=real64) public interface kelvin_to_celcius public elemental function kelvin_to_celcius_r32 (K) result(C) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: K Return Value real(kind=real32) public elemental function kelvin_to_celcius_r64 (K) result(C) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: K Return Value real(kind=real64) public interface kelvin_to_fahrenheit public elemental function kelvin_to_fahrenheit_r32 (K) result(F) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: K Return Value real(kind=real32) public elemental function kelvin_to_fahrenheit_r64 (K) result(F) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: K Return Value real(kind=real64) public interface fahrenheit_to_kelvin public elemental function fahrenheit_to_kelvin_r32 (F) result(K) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: F Return Value real(kind=real32) public elemental function fahrenheit_to_kelvin_r64 (F) result(K) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: F Return Value real(kind=real64) Functions public elemental function fahrenheit_to_celcius_r32 (F) result(C) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: F Return Value real(kind=real32) public elemental function fahrenheit_to_celcius_r64 (F) result(C) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: F Return Value real(kind=real64) public elemental function celcius_to_fahrenheit_r32 (C) result(F) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: C Return Value real(kind=real32) public elemental function celcius_to_fahrenheit_r64 (C) result(F) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: C Return Value real(kind=real64) public elemental function celcius_to_kelvin_r32 (C) result(K) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: C Return Value real(kind=real32) public elemental function celcius_to_kelvin_r64 (C) result(K) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: C Return Value real(kind=real64) public elemental function kelvin_to_celcius_r32 (K) result(C) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: K Return Value real(kind=real32) public elemental function kelvin_to_celcius_r64 (K) result(C) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: K Return Value real(kind=real64) public elemental function kelvin_to_fahrenheit_r32 (K) result(F) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: K Return Value real(kind=real32) public elemental function kelvin_to_fahrenheit_r64 (K) result(F) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: K Return Value real(kind=real64) public elemental function fahrenheit_to_kelvin_r32 (F) result(K) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: F Return Value real(kind=real32) public elemental function fahrenheit_to_kelvin_r64 (F) result(K) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: F Return Value real(kind=real64)","tags":"","loc":"module/foreng_science_temp.html"},{"title":"foreng_science_elec – Fortran Program","text":"Uses foreng_env Contents Functions calc_current_flow Functions public elemental function calc_current_flow (v_D, I_O, T) result(i_D_) Arguments Type Intent Optional Attributes Name real(kind=16), intent(in) :: v_D Voltage across the diode, in volts real(kind=16), intent(in) :: I_O Leakage current of the diode, in amperes real(kind=16), intent(in) :: T Temperature, in kelvins (K) Return Value integer","tags":"","loc":"module/foreng_science_elec.html"},{"title":"foreng_science_const – Fortran Program","text":"A series of scientific constants used in the science module Uses foreng_env Contents Variables BOLTZMANN_CONSTANT ELECTRON_CHARGE GRAVITATIONAL_CONSTANT AVOGADRO_NUMBER UNIVERSAL_GAS_CONSTANT EARTH_MASS Variables Type Visibility Attributes Name Initial real(kind=real64), public, parameter :: BOLTZMANN_CONSTANT = 1.38E-23 Joules/Kelvin (J/K) real(kind=real64), public, parameter :: ELECTRON_CHARGE = 1.602E-19 Coulombs (C) real(kind=real64), public, parameter :: GRAVITATIONAL_CONSTANT = 6.672E-11 N m2/kg2 real(kind=real64), public, parameter :: AVOGADRO_NUMBER = 6.023E23 Number of molecules in a mol real(kind=real64), public, parameter :: UNIVERSAL_GAS_CONSTANT = 8.314 L * kPa/mol * K real(kind=real64), public, parameter :: EARTH_MASS = 5.98E24 kg","tags":"","loc":"module/foreng_science_const.html"},{"title":"foreng_science – Fortran Program","text":"Uses foreng_science_temp foreng_science_elec foreng_science_const foreng_science_phys Contents None","tags":"","loc":"module/foreng_science.html"},{"title":"foreng_math_trig – Fortran Program","text":"Trigonometric functions defined for inputs whose units are degrees instead of radians. Uses foreng_env Contents Interfaces sind cosd tand asind acosd atand sinhd coshd tanhd deg_to_rad rad_to_deg Functions sind_r32 sind_r64 cosd_r32 cosd_r64 tand_r32 tand_r64 asind_r32 asind_r64 acosd_r32 acosd_r64 atand_r32 atand_r64 sinhd_r32 sinhd_r64 coshd_r32 coshd_r64 tanhd_r32 tanhd_r64 deg_to_rad_r32 deg_to_rad_r64 rad_to_deg_r32 rad_to_deg_r64 Interfaces public interface sind Calculate \\sin(\\theta) where \\theta is in degrees Read more… public elemental function sind_r32 (theta) result(sind) Single precision Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: theta \\theta in degrees Return Value real(kind=real32) public elemental function sind_r64 (theta) result(sind) Double precision Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: theta \\theta in degrees Return Value real(kind=real64) public interface cosd Calculate \\cos(\\theta) where \\theta is in degrees Read more… public elemental function cosd_r32 (theta) result(cosd) Single precision Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: theta \\theta in degrees Return Value real(kind=real32) public elemental function cosd_r64 (theta) result(cosd) Double precision Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: theta \\theta in degrees Return Value real(kind=real64) public interface tand Calculate \\tan(\\theta) where \\theta is in degrees Read more… public elemental function tand_r32 (theta) result(tand) Single precision Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: theta \\theta in degrees Return Value real(kind=real32) public elemental function tand_r64 (theta) result(tand) Double precision Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: theta \\theta in degrees Return Value real(kind=real64) public interface asind Calculate \\textrm{asin}(x) and return \\theta in degrees Read more… public elemental function asind_r32 (x) result(theta) Single precision Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: x Return Value real(kind=real32) \\theta in degrees public elemental function asind_r64 (x) result(theta) Double precision Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x Return Value real(kind=real64) \\theta in degrees public interface acosd Calculate \\textrm{acos}(x) and return \\theta in degrees Read more… public elemental function acosd_r32 (x) result(theta) Single precision Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: x Return Value real(kind=real32) \\theta in degrees public elemental function acosd_r64 (x) result(theta) Double precision Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x Return Value real(kind=real64) \\theta in degrees public interface atand Calculate \\textrm{atan}(x) and return \\theta in degrees Read more… public elemental function atand_r32 (x) result(theta) Single precision Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: x Return Value real(kind=real32) \\theta in degrees public elemental function atand_r64 (x) result(theta) Double precision Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x Return Value real(kind=real64) \\theta in degrees public interface sinhd public elemental function sinhd_r32 (theta) result(sinhd) Single precision Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: theta \\theta in degrees Return Value real(kind=real32) public elemental function sinhd_r64 (theta) result(sinhd) Double precision Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: theta \\theta in degrees Return Value real(kind=real64) public interface coshd public elemental function coshd_r32 (theta) result(coshd) Single precision Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: theta \\theta in degrees Return Value real(kind=real32) public elemental function coshd_r64 (theta) result(coshd) Double precision Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: theta \\theta in degrees Return Value real(kind=real64) public interface tanhd public elemental function tanhd_r32 (theta) result(tanhd) Single precision Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: theta \\theta in degrees Return Value real(kind=real32) public elemental function tanhd_r64 (theta) result(tanhd) Double precision Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: theta \\theta in degrees Return Value real(kind=real64) public interface deg_to_rad Convert \\theta from degrees to radians public elemental function deg_to_rad_r32 (degrees) result(radians) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: degrees Return Value real(kind=real32) public elemental function deg_to_rad_r64 (degrees) result(radians) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: degrees Return Value real(kind=real64) public interface rad_to_deg Conver \\theta from radians to degrees public elemental function rad_to_deg_r32 (radians) result(degrees) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: radians Return Value real(kind=real32) public elemental function rad_to_deg_r64 (radians) result(degrees) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: radians Return Value real(kind=real64) Functions public elemental function sind_r32 (theta) result(sind) Single precision Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: theta \\theta in degrees Return Value real(kind=real32) public elemental function sind_r64 (theta) result(sind) Double precision Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: theta \\theta in degrees Return Value real(kind=real64) public elemental function cosd_r32 (theta) result(cosd) Single precision Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: theta \\theta in degrees Return Value real(kind=real32) public elemental function cosd_r64 (theta) result(cosd) Double precision Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: theta \\theta in degrees Return Value real(kind=real64) public elemental function tand_r32 (theta) result(tand) Single precision Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: theta \\theta in degrees Return Value real(kind=real32) public elemental function tand_r64 (theta) result(tand) Double precision Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: theta \\theta in degrees Return Value real(kind=real64) public elemental function asind_r32 (x) result(theta) Single precision Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: x Return Value real(kind=real32) \\theta in degrees public elemental function asind_r64 (x) result(theta) Double precision Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x Return Value real(kind=real64) \\theta in degrees public elemental function acosd_r32 (x) result(theta) Single precision Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: x Return Value real(kind=real32) \\theta in degrees public elemental function acosd_r64 (x) result(theta) Double precision Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x Return Value real(kind=real64) \\theta in degrees public elemental function atand_r32 (x) result(theta) Single precision Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: x Return Value real(kind=real32) \\theta in degrees public elemental function atand_r64 (x) result(theta) Double precision Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x Return Value real(kind=real64) \\theta in degrees public elemental function sinhd_r32 (theta) result(sinhd) Single precision Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: theta \\theta in degrees Return Value real(kind=real32) public elemental function sinhd_r64 (theta) result(sinhd) Double precision Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: theta \\theta in degrees Return Value real(kind=real64) public elemental function coshd_r32 (theta) result(coshd) Single precision Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: theta \\theta in degrees Return Value real(kind=real32) public elemental function coshd_r64 (theta) result(coshd) Double precision Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: theta \\theta in degrees Return Value real(kind=real64) public elemental function tanhd_r32 (theta) result(tanhd) Single precision Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: theta \\theta in degrees Return Value real(kind=real32) public elemental function tanhd_r64 (theta) result(tanhd) Double precision Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: theta \\theta in degrees Return Value real(kind=real64) public elemental function deg_to_rad_r32 (degrees) result(radians) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: degrees Return Value real(kind=real32) public elemental function deg_to_rad_r64 (degrees) result(radians) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: degrees Return Value real(kind=real64) public elemental function rad_to_deg_r32 (radians) result(degrees) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: radians Return Value real(kind=real32) public elemental function rad_to_deg_r64 (radians) result(degrees) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: radians Return Value real(kind=real64)","tags":"","loc":"module/foreng_math_trig.html"},{"title":"foreng_math_stats – Fortran Program","text":"Uses foreng_env foreng_math_misc Contents Interfaces mean arithmetic_mean rms_mean harmonic_mean geometric_mean std_dev Functions rank_1_mean_r32 rank_1_mean_r64 rank_1_mean_i32 rank_1_mean_i64 rank1_arithmetic_mean_r32 rank1_arithmetic_mean_r64 rank1_arithmetic_mean_i32 rank1_arithmetic_mean_i64 rank1_root_mean_squared_mean_r32 rank1_root_mean_squared_mean_r64 rank1_root_mean_squared_mean_i32 rank1_root_mean_squared_mean_i64 rank1_harmonic_mean_r32 rank1_harmonic_mean_r64 rank1_harmonic_mean_i32 rank1_harmonic_mean_i64 rank1_geometric_mean_r32 rank1_geometric_mean_r64 rank1_geometric_mean_i32 rank1_geometric_mean_i64 std_dev_r32 std_dev_r64 std_dev_i32 std_dev_i64 Interfaces public interface mean public function rank_1_mean_r32 (data_, type) result(mean_) Calculate the mean of a 1d data set, given the \"type\" Read more… Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), dimension(:) :: data_ character(len=*), intent(in), optional :: type Return Value real(kind=real32) public function rank_1_mean_r64 (data_, type) result(mean_) Calculate the mean of a 1d data set, given the \"type\" Read more… Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:) :: data_ character(len=*), intent(in), optional :: type Return Value real(kind=real64) public function rank_1_mean_i32 (data_, type) result(mean_) Calculate the mean of a 1d data set, given the \"type\" Read more… Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), dimension(:) :: data_ character(len=*), intent(in), optional :: type Return Value real(kind=real32) public function rank_1_mean_i64 (data_, type) result(mean_) Calculate the mean of a 1d data set, given the \"type\" Read more… Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), dimension(:) :: data_ character(len=*), intent(in), optional :: type Return Value real(kind=real64) public interface arithmetic_mean public function rank1_arithmetic_mean_r32 (data_) result(arithmetic_mean_) Calculate the arithmetic mean of a rank 1 array Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: data_ (:) Return Value real(kind=real32) Rank 1 array containing the elements to calculate the mean for public function rank1_arithmetic_mean_r64 (data_) result(arithmetic_mean_) Calculate the arithmetic mean of a rank 1 array Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: data_ (:) Return Value real(kind=real64) Rank 1 array containing the elements to calculate the mean for public function rank1_arithmetic_mean_i32 (data_) result(arithmetic_mean_) Calculate the arithmetic mean of a rank 1 array Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: data_ (:) Rank 1 array containing the elements to calculate the mean for Return Value real(kind=real32) public function rank1_arithmetic_mean_i64 (data_) result(arithmetic_mean_) Calculate the arithmetic mean of a rank 1 array Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: data_ (:) Return Value real(kind=real64) Rank 1 array containing the elements to calculate the mean for public interface rms_mean public function rank1_root_mean_squared_mean_r32 (data_) result(rms_) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: data_ (:) Return Value real(kind=real32) Rank 1 array containing the elements to calculate the mean for public function rank1_root_mean_squared_mean_r64 (data_) result(rms_) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: data_ (:) Return Value real(kind=real64) Rank 1 array containing the elements to calculate the mean for public function rank1_root_mean_squared_mean_i32 (data_) result(rms_) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: data_ (:) Return Value real(kind=real32) Rank 1 array containing the elements to calculate the mean for public function rank1_root_mean_squared_mean_i64 (data_) result(rms_) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: data_ (:) Return Value real(kind=real64) Rank 1 array containing the elements to calculate the mean for public interface harmonic_mean public function rank1_harmonic_mean_r32 (data_) result(harmonic_mean_) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: data_ (:) Return Value real(kind=real32) Rank 1 array containing the elements to calculate the mean for public function rank1_harmonic_mean_r64 (data_) result(harmonic_mean_) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: data_ (:) Return Value real(kind=real64) Rank 1 array containing the elements to calculate the mean for public function rank1_harmonic_mean_i32 (data_) result(harmonic_mean_) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: data_ (:) Return Value real(kind=real32) Rank 1 array containing the elements to calculate the mean for public function rank1_harmonic_mean_i64 (data_) result(harmonic_mean_) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: data_ (:) Return Value real(kind=real64) Rank 1 array containing the elements to calculate the mean for public interface geometric_mean public function rank1_geometric_mean_r32 (data_) result(geometric_mean_) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: data_ (:) Return Value real(kind=real32) Rank 1 array containing the elements to calculate the mean for public function rank1_geometric_mean_r64 (data_) result(geometric_mean_) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: data_ (:) Return Value real(kind=real64) Rank 1 array containing the elements to calculate the mean for public function rank1_geometric_mean_i32 (data_) result(geometric_mean_) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: data_ (:) Return Value real(kind=real64) Rank 1 array containing the elements to calculate the mean for public function rank1_geometric_mean_i64 (data_) result(geometric_mean_) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: data_ (:) Return Value real(kind=real64) Rank 1 array containing the elements to calculate the mean for public interface std_dev public function std_dev_r32 (data) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), dimension(:) :: data Return Value real(kind=real32) population standard deviation public function std_dev_r64 (data) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:) :: data Return Value real(kind=real64) population standard deviation public function std_dev_i32 (data_) result(sigma) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), dimension(:) :: data_ Return Value real(kind=real32) population standard deviation public function std_dev_i64 (data) result(sigma) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), dimension(:) :: data Return Value real(kind=real64) population standard deviation Functions public function rank_1_mean_r32 (data_, type) result(mean_) Calculate the mean of a 1d data set, given the \"type\" Read more… Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), dimension(:) :: data_ character(len=*), intent(in), optional :: type Return Value real(kind=real32) public function rank_1_mean_r64 (data_, type) result(mean_) Calculate the mean of a 1d data set, given the \"type\" Read more… Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:) :: data_ character(len=*), intent(in), optional :: type Return Value real(kind=real64) public function rank_1_mean_i32 (data_, type) result(mean_) Calculate the mean of a 1d data set, given the \"type\" Read more… Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), dimension(:) :: data_ character(len=*), intent(in), optional :: type Return Value real(kind=real32) public function rank_1_mean_i64 (data_, type) result(mean_) Calculate the mean of a 1d data set, given the \"type\" Read more… Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), dimension(:) :: data_ character(len=*), intent(in), optional :: type Return Value real(kind=real64) public function rank1_arithmetic_mean_r32 (data_) result(arithmetic_mean_) Calculate the arithmetic mean of a rank 1 array Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: data_ (:) Return Value real(kind=real32) Rank 1 array containing the elements to calculate the mean for public function rank1_arithmetic_mean_r64 (data_) result(arithmetic_mean_) Calculate the arithmetic mean of a rank 1 array Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: data_ (:) Return Value real(kind=real64) Rank 1 array containing the elements to calculate the mean for public function rank1_arithmetic_mean_i32 (data_) result(arithmetic_mean_) Calculate the arithmetic mean of a rank 1 array Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: data_ (:) Rank 1 array containing the elements to calculate the mean for Return Value real(kind=real32) public function rank1_arithmetic_mean_i64 (data_) result(arithmetic_mean_) Calculate the arithmetic mean of a rank 1 array Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: data_ (:) Return Value real(kind=real64) Rank 1 array containing the elements to calculate the mean for public function rank1_root_mean_squared_mean_r32 (data_) result(rms_) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: data_ (:) Return Value real(kind=real32) Rank 1 array containing the elements to calculate the mean for public function rank1_root_mean_squared_mean_r64 (data_) result(rms_) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: data_ (:) Return Value real(kind=real64) Rank 1 array containing the elements to calculate the mean for public function rank1_root_mean_squared_mean_i32 (data_) result(rms_) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: data_ (:) Return Value real(kind=real32) Rank 1 array containing the elements to calculate the mean for public function rank1_root_mean_squared_mean_i64 (data_) result(rms_) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: data_ (:) Return Value real(kind=real64) Rank 1 array containing the elements to calculate the mean for public function rank1_harmonic_mean_r32 (data_) result(harmonic_mean_) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: data_ (:) Return Value real(kind=real32) Rank 1 array containing the elements to calculate the mean for public function rank1_harmonic_mean_r64 (data_) result(harmonic_mean_) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: data_ (:) Return Value real(kind=real64) Rank 1 array containing the elements to calculate the mean for public function rank1_harmonic_mean_i32 (data_) result(harmonic_mean_) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: data_ (:) Return Value real(kind=real32) Rank 1 array containing the elements to calculate the mean for public function rank1_harmonic_mean_i64 (data_) result(harmonic_mean_) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: data_ (:) Return Value real(kind=real64) Rank 1 array containing the elements to calculate the mean for public function rank1_geometric_mean_r32 (data_) result(geometric_mean_) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: data_ (:) Return Value real(kind=real32) Rank 1 array containing the elements to calculate the mean for public function rank1_geometric_mean_r64 (data_) result(geometric_mean_) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: data_ (:) Return Value real(kind=real64) Rank 1 array containing the elements to calculate the mean for public function rank1_geometric_mean_i32 (data_) result(geometric_mean_) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: data_ (:) Return Value real(kind=real64) Rank 1 array containing the elements to calculate the mean for public function rank1_geometric_mean_i64 (data_) result(geometric_mean_) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: data_ (:) Return Value real(kind=real64) Rank 1 array containing the elements to calculate the mean for public function std_dev_r32 (data) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), dimension(:) :: data Return Value real(kind=real32) population standard deviation public function std_dev_r64 (data) result(sigma) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:) :: data Return Value real(kind=real64) population standard deviation public function std_dev_i32 (data_) result(sigma) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), dimension(:) :: data_ Return Value real(kind=real32) population standard deviation public function std_dev_i64 (data) result(sigma) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), dimension(:) :: data Return Value real(kind=real64) population standard deviation","tags":"","loc":"module/foreng_math_stats.html"},{"title":"foreng_math – Fortran Program","text":"Top level module containing math functions (sets, factorials, trig) Uses foreng_math_trig foreng_math_sets foreng_math_misc foreng_math_stats foreng_math_prob foreng_math_geom Contents None","tags":"","loc":"module/foreng_math.html"},{"title":"foreng_math_prob – Fortran Program","text":"Contains functions used to compute probability distributions Uses foreng_env foreng_math_misc Contents Interfaces urand fill_urand Functions urand_r32 urand_r64 urand_i32 urand_i64 poisson standard_normal_rand Subroutines fill_urand_rank1_r32 fill_urand_rank1_r64 fill_urand_rank1_i32 fill_urand_rank1_i64 fill_urand_rank2_r32 fill_urand_rank2_r64 fill_urand_rank2_i32 fill_urand_rank2_i64 fill_urand_rank3_r32 fill_urand_rank3_r64 fill_urand_rank3_i32 fill_urand_rank3_i64 Interfaces public interface urand Return a uniform random variable from min (inclusive) to max (inclusive for integer functions, exclusive for real) public function urand_r32 (min, max) result(x) Return a uniform random variable [min, max) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: min a , inclusive real(kind=real32), intent(in) :: max b , exclusive Return Value real(kind=real32) x \\sim \\mathcal{U}[a, b) public function urand_r64 (min, max) result(x) Return a uniform random variable [min, max) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: min a , inclusive real(kind=real64), intent(in) :: max b , exclusive Return Value real(kind=real64) x \\sim \\mathcal{U}[a, b) public function urand_i32 (min, max) result(x) Return a uniform random variable [min, max] Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: min a , inclusive integer(kind=int32), intent(in) :: max b , inclusive Return Value integer(kind=int32) x \\sim \\mathcal{U}[a, b] public function urand_i64 (min, max) result(x) Return a uniform random variable [min, max] Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: min a , inclusive integer(kind=int64), intent(in) :: max b , inclusive Return Value integer(kind=int64) x \\sim \\mathcal{U}[a, b] public interface fill_urand Fill a rank 1, 2, or 3 array with a uniform random variable from min (inclusive) to max (inclusive for integer functions, exclusive for real) Read more… public subroutine fill_urand_rank1_r32 (A, min, max) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(inout), dimension(:) :: A real(kind=real32), intent(in) :: min real(kind=real32), intent(in) :: max public subroutine fill_urand_rank1_r64 (A, min, max) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:) :: A real(kind=real64), intent(in) :: min real(kind=real64), intent(in) :: max public subroutine fill_urand_rank1_i32 (A, min, max) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout), dimension(:) :: A integer(kind=int32), intent(in) :: min integer(kind=int32), intent(in) :: max public subroutine fill_urand_rank1_i64 (A, min, max) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout), dimension(:) :: A integer(kind=int64), intent(in) :: min integer(kind=int64), intent(in) :: max public subroutine fill_urand_rank2_r32 (A, min, max) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(inout), dimension(:,:) :: A real(kind=real32), intent(in) :: min real(kind=real32), intent(in) :: max public subroutine fill_urand_rank2_r64 (A, min, max) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:,:) :: A real(kind=real64), intent(in) :: min real(kind=real64), intent(in) :: max public subroutine fill_urand_rank2_i32 (A, min, max) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout), dimension(:,:) :: A integer(kind=int32), intent(in) :: min integer(kind=int32), intent(in) :: max public subroutine fill_urand_rank2_i64 (A, min, max) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout), dimension(:,:) :: A integer(kind=int64), intent(in) :: min integer(kind=int64), intent(in) :: max public subroutine fill_urand_rank3_r32 (A, min, max) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(inout), dimension(:,:,:) :: A real(kind=real32), intent(in) :: min real(kind=real32), intent(in) :: max public subroutine fill_urand_rank3_r64 (A, min, max) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:,:,:) :: A real(kind=real64), intent(in) :: min real(kind=real64), intent(in) :: max public subroutine fill_urand_rank3_i32 (A, min, max) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout), dimension(:,:,:) :: A integer(kind=int32), intent(in) :: min integer(kind=int32), intent(in) :: max public subroutine fill_urand_rank3_i64 (A, min, max) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout), dimension(:,:,:) :: A integer(kind=int64), intent(in) :: min integer(kind=int64), intent(in) :: max Functions public function urand_r32 (min, max) result(x) Return a uniform random variable [min, max) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: min a , inclusive real(kind=real32), intent(in) :: max b , exclusive Return Value real(kind=real32) x \\sim \\mathcal{U}[a, b) public function urand_r64 (min, max) result(x) Return a uniform random variable [min, max) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: min a , inclusive real(kind=real64), intent(in) :: max b , exclusive Return Value real(kind=real64) x \\sim \\mathcal{U}[a, b) public function urand_i32 (min, max) result(x) Return a uniform random variable [min, max] Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: min a , inclusive integer(kind=int32), intent(in) :: max b , inclusive Return Value integer(kind=int32) x \\sim \\mathcal{U}[a, b] public function urand_i64 (min, max) result(x) Return a uniform random variable [min, max] Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: min a , inclusive integer(kind=int64), intent(in) :: max b , inclusive Return Value integer(kind=int64) x \\sim \\mathcal{U}[a, b] public function poisson (k, t, lamda) result(P) Arguments Type Intent Optional Attributes Name integer, intent(in) :: k real, intent(in) :: t real, intent(in) :: lamda Return Value real public function standard_normal_rand () result(x) Arguments None Return Value real(kind=real64) Subroutines public subroutine fill_urand_rank1_r32 (A, min, max) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(inout), dimension(:) :: A real(kind=real32), intent(in) :: min real(kind=real32), intent(in) :: max public subroutine fill_urand_rank1_r64 (A, min, max) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:) :: A real(kind=real64), intent(in) :: min real(kind=real64), intent(in) :: max public subroutine fill_urand_rank1_i32 (A, min, max) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout), dimension(:) :: A integer(kind=int32), intent(in) :: min integer(kind=int32), intent(in) :: max public subroutine fill_urand_rank1_i64 (A, min, max) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout), dimension(:) :: A integer(kind=int64), intent(in) :: min integer(kind=int64), intent(in) :: max public subroutine fill_urand_rank2_r32 (A, min, max) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(inout), dimension(:,:) :: A real(kind=real32), intent(in) :: min real(kind=real32), intent(in) :: max public subroutine fill_urand_rank2_r64 (A, min, max) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:,:) :: A real(kind=real64), intent(in) :: min real(kind=real64), intent(in) :: max public subroutine fill_urand_rank2_i32 (A, min, max) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout), dimension(:,:) :: A integer(kind=int32), intent(in) :: min integer(kind=int32), intent(in) :: max public subroutine fill_urand_rank2_i64 (A, min, max) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout), dimension(:,:) :: A integer(kind=int64), intent(in) :: min integer(kind=int64), intent(in) :: max public subroutine fill_urand_rank3_r32 (A, min, max) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(inout), dimension(:,:,:) :: A real(kind=real32), intent(in) :: min real(kind=real32), intent(in) :: max public subroutine fill_urand_rank3_r64 (A, min, max) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:,:,:) :: A real(kind=real64), intent(in) :: min real(kind=real64), intent(in) :: max public subroutine fill_urand_rank3_i32 (A, min, max) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout), dimension(:,:,:) :: A integer(kind=int32), intent(in) :: min integer(kind=int32), intent(in) :: max public subroutine fill_urand_rank3_i64 (A, min, max) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout), dimension(:,:,:) :: A integer(kind=int64), intent(in) :: min integer(kind=int64), intent(in) :: max","tags":"","loc":"module/foreng_math_prob.html"},{"title":"foreng_math_misc – Fortran Program","text":"Miscellaneous Mathematic functions Uses foreng_env foreng_math_trig Contents Interfaces factorial nth_root exp_series Functions factorial_int16 factorial_int32 factorial_int64 factorial_int128 exp_series_r32 exp_series_r64 sind_series nth_root_r32 nth_root_r64 fibonacci_loop Interfaces public interface factorial Compute x! public recursive function factorial_int16 (x) result(x_fact) Recursively compute the factorial of a 16-bit integer. The max value that can be passed is 7\n If x is less than 0 or greater 7, the function will return 0 Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x 0 \\leq x \\leq 7 Return Value integer(kind=int16) x! public recursive function factorial_int32 (x) result(x_fact) Recursively compute the factorial of a 32-bit integer. The max value that can be passed is 16\n If x is less than 0 or greater 16, the function will return 0 Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x 0 \\leq x \\leq 16 Return Value integer(kind=int32) x! public recursive function factorial_int64 (x) result(x_fact) Recursively compute the factorial of a 64-bit integer. The max value that can be passed is 20\n If x is less than 0 or greater 20, the function will return 0 Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x 0 \\leq x \\leq 20 Return Value integer(kind=int64) x! public recursive function factorial_int128 (x) result(x_fact) Recursively compute the factorial of a 128-bit integer [supported on gfortran]. The max value that can be passed is 33\n If x is less than 0 or greater 33, the function will return 0 Arguments Type Intent Optional Attributes Name integer(kind=int128), intent(in) :: x 0 \\leq x \\leq 33 Return Value integer(kind=int128) x! public interface nth_root Compute \\sqrt[n]{x} public function nth_root_r32 (x_, n_) result(root_) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: x_ integer, intent(in) :: n_ Return Value real(kind=real32) public function nth_root_r64 (x_, n_) result(root_) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x_ integer, intent(in) :: n_ Return Value real(kind=real64) public interface exp_series Compute e&#94;x using a truncated taylor series public function exp_series_r32 (x) result(exp) Compute e&#94;x using a taylor series with 12 terms Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: x Return Value real public function exp_series_r64 (x) result(exp) Calculate e&#94;x using a taylor series with 20 terms Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x Return Value real(kind=real64) Functions public recursive function factorial_int16 (x) result(x_fact) Recursively compute the factorial of a 16-bit integer. The max value that can be passed is 7\n If x is less than 0 or greater 7, the function will return 0 Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x 0 \\leq x \\leq 7 Return Value integer(kind=int16) x! public recursive function factorial_int32 (x) result(x_fact) Recursively compute the factorial of a 32-bit integer. The max value that can be passed is 16\n If x is less than 0 or greater 16, the function will return 0 Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x 0 \\leq x \\leq 16 Return Value integer(kind=int32) x! public recursive function factorial_int64 (x) result(x_fact) Recursively compute the factorial of a 64-bit integer. The max value that can be passed is 20\n If x is less than 0 or greater 20, the function will return 0 Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x 0 \\leq x \\leq 20 Return Value integer(kind=int64) x! public recursive function factorial_int128 (x) result(x_fact) Recursively compute the factorial of a 128-bit integer [supported on gfortran]. The max value that can be passed is 33\n If x is less than 0 or greater 33, the function will return 0 Arguments Type Intent Optional Attributes Name integer(kind=int128), intent(in) :: x 0 \\leq x \\leq 33 Return Value integer(kind=int128) x! public function exp_series_r32 (x) result(exp) Compute e&#94;x using a taylor series with 12 terms Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: x Return Value real public function exp_series_r64 (x) result(exp) Calculate e&#94;x using a taylor series with 20 terms Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x Return Value real(kind=real64) public function sind_series (x_, n_) result(sin_x) Compute sine using a truncated taylor series Arguments Type Intent Optional Attributes Name real, intent(in) :: x_ Angle in degrees integer, intent(in) :: n_ Number of terms to use Return Value real public function nth_root_r32 (x_, n_) result(root_) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: x_ integer, intent(in) :: n_ Return Value real(kind=real32) public function nth_root_r64 (x_, n_) result(root_) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x_ integer, intent(in) :: n_ Return Value real(kind=real64) public function fibonacci_loop (n) result(f_n) Update current F number\n Update previous two numbers Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: n Nth fibonacci to compute Return Value integer(kind=int64)","tags":"","loc":"module/foreng_math_misc.html"},{"title":"foreng_math_geom – Fortran Program","text":"Uses foreng_env foreng_math_trig Contents Interfaces cross_product operator(*) Derived Types point2 point3 vector3 line2 Functions point2_to_array point2_from_polar_r32 point2_from_polar_r64 point2_from_polar_int point2_rho point2_theta point2_plus_point2 point2_minus_point2 point2_unary_minus point2_distance_between_point2 point3_to_array point3_from_spherical_r32 point3_from_spherical_r64 point3_from_spherical_int point3_rho point3_theta point3_phi point3_plus_point3 point3_minus_point3 point3_unary_minus point3_dot_point3 point3_cross_point3 point3_distance_between_point3 vector3_magnitude vector3_to_array vector3_plus_vector3 vector3_minus_vector3 vector3_unary_minus vector3_times_scalar_r32 vector3_times_scalar_r64 vector3_times_scalar_int scalar_times_vector3_r32 scalar_times_vector3_r64 scalar_times_vector3_int vector3_dot_vector3 vector3_cross_vector3 vector3_angle_between_vector3 cross_product_r32 cross_product_r64 distance line2_atx line2_aty Subroutines point2_from_array_r32 point2_from_array_r64 point2_from_array_int point2_print_cartesian point2_print_polar point3_from_array_r32 point3_from_array_r64 point3_from_array_int point3_print_cartesian point3_print_spherical vector3_print vector3_from_array_r32 vector3_from_array_r64 vector3_from_array_int line2_from_two_point2 line2_print Interfaces public interface cross_product public function cross_product_r32 (v1, v2) result(normal) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(3) :: v1 Vectors to cross multiply real, intent(in), dimension(3) :: v2 Vectors to cross multiply Return Value real,\n  dimension(3) Normal vector that is the output public function cross_product_r64 (v1, v2) result(normal) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(3) :: v1 Vectors to cross multiply real(kind=real64), intent(in), dimension(3) :: v2 Vectors to cross multiply Return Value real(kind=real64),\n  dimension(3) Normal vector that is the output public interface operator(*) public function scalar_times_vector3_r32 (k, v1) result(v2) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: k class( vector3 ), intent(in) :: v1 Return Value type( vector3 ) public function scalar_times_vector3_r64 (k, v1) result(v2) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: k class( vector3 ), intent(in) :: v1 Return Value type( vector3 ) public function scalar_times_vector3_int (k, v1) result(v2) Arguments Type Intent Optional Attributes Name integer, intent(in) :: k class( vector3 ), intent(in) :: v1 Return Value type( vector3 ) Derived Types type, public :: point2 A point object with coordinates stored in cartesian coordinates Components Type Visibility Attributes Name Initial real(kind=real64), public :: x real(kind=real64), public :: y Type-Bound Procedures procedure, public :: print => point2_print_cartesian procedure, public :: print_pol => point2_print_polar procedure, public :: rho => point2_rho procedure, public :: theta => point2_theta procedure, public :: to_array => point2_to_array procedure, public :: dist => point2_distance_between_point2 generic, public :: from_pol => from_pol_r32, from_pol_r64, from_pol_int This is the comment for a generic function generic, public :: assignment(=) => from_array_r32, from_array_r64, from_array_int generic, public :: operator(+) => add generic, public :: operator(-) => subtract_point2, unary_minus procedure, public :: add => point2_plus_point2 procedure, public :: subtract_point2 => point2_minus_point2 procedure, public :: unary_minus => point2_unary_minus procedure, public, nopass :: from_pol_r32 => point2_from_polar_r32 procedure, public, nopass :: from_pol_r64 => point2_from_polar_r64 procedure, public, nopass :: from_pol_int => point2_from_polar_int procedure, public :: from_array_r32 => point2_from_array_r32 procedure, public :: from_array_r64 => point2_from_array_r64 procedure, public :: from_array_int => point2_from_array_int type, public :: point3 Components Type Visibility Attributes Name Initial real(kind=real64), public :: x real(kind=real64), public :: y real(kind=real64), public :: z Type-Bound Procedures procedure, public :: print => point3_print_cartesian procedure, public :: print_sph => point3_print_spherical procedure, public :: rho => point3_rho procedure, public :: theta => point3_theta procedure, public :: phi => point3_phi procedure, public :: to_array => point3_to_array procedure, public :: dist => point3_distance_between_point3 generic, public :: from_sph => from_sph_r32, from_sph_r64, from_sph_int This is the comment for a generic function generic, public :: operator(+) => add generic, public :: assignment(=) => from_array_r32, from_array_r64, from_array_int generic, public :: operator(-) => subtract procedure, public :: add => point3_plus_point3 procedure, public :: point3_unary_minus procedure, public :: subtract => point3_minus_point3 procedure, public, nopass :: from_sph_r32 => point3_from_spherical_r32 procedure, public, nopass :: from_sph_r64 => point3_from_spherical_r64 procedure, public, nopass :: from_sph_int => point3_from_spherical_int procedure, public :: from_array_r32 => point3_from_array_r32 procedure, public :: from_array_r64 => point3_from_array_r64 procedure, public :: from_array_int => point3_from_array_int type, public :: vector3 Components Type Visibility Attributes Name Initial real(kind=real64), public :: x real(kind=real64), public :: y real(kind=real64), public :: z Type-Bound Procedures procedure, public :: print => vector3_print procedure, public :: length => vector3_magnitude procedure, public :: to_array => vector3_to_array generic, public :: from_array => from_array_r32, from_array_r64, from_array_int generic, public :: operator(+) => add_vector3 generic, public :: operator(-) => subtract_vector3, unary_minus generic, public :: operator(*) => multiply_scalar_r32, multiply_scalar_r64, multiply_scalar_int generic, public :: operator(.dot.) => dot generic, public :: operator(.cross.) => cross generic, public :: operator(.angle.) => angle_between generic, public :: assignment(=) => from_array_r32, from_array_r64, from_array_int procedure, public :: from_array_r32 => vector3_from_array_r32 procedure, public :: from_array_r64 => vector3_from_array_r64 procedure, public :: from_array_int => vector3_from_array_int procedure, public :: add_vector3 => vector3_plus_vector3 procedure, public :: multiply_scalar_r32 => vector3_times_scalar_r32 procedure, public :: multiply_scalar_r64 => vector3_times_scalar_r64 procedure, public :: multiply_scalar_int => vector3_times_scalar_int procedure, public :: dot => vector3_dot_vector3 procedure, public :: cross => vector3_cross_vector3 procedure, public :: angle_between => vector3_angle_between_vector3 procedure, public :: subtract_vector3 => vector3_minus_vector3 procedure, public :: unary_minus => vector3_unary_minus type, public :: line2 Components Type Visibility Attributes Name Initial real(kind=real64), public :: m real(kind=real64), public :: b Type-Bound Procedures procedure, public :: atx => line2_atx Evaluate y = mx + b for a given x procedure, public :: aty => line2_aty Evaluate y = mx + b for a given y procedure, public :: print => line2_print generic, public :: assignment(=) => from_two_points procedure, public :: from_two_points => line2_from_two_point2 Functions public function point2_to_array (self) result(array) Arguments Type Intent Optional Attributes Name class( point2 ), intent(in) :: self Return Value real(kind=real64),\n  dimension(2) public function point2_from_polar_r32 (rho, theta) result(point) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: rho real(kind=real32), intent(in) :: theta Return Value type( point2 ) public function point2_from_polar_r64 (rho, theta) result(point) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: rho real(kind=real64), intent(in) :: theta Return Value type( point2 ) public function point2_from_polar_int (rho, theta) result(point) Arguments Type Intent Optional Attributes Name integer, intent(in) :: rho integer, intent(in) :: theta Return Value type( point2 ) public function point2_rho (self) result(rho) Calculate the magnitude (distance from the origin) of Arguments Type Intent Optional Attributes Name class( point2 ), intent(in) :: self Return Value real(kind=real64) public function point2_theta (self) result(theta) Return the angle (in degrees) of the polar representation of a point Arguments Type Intent Optional Attributes Name class( point2 ), intent(in) :: self Return Value real(kind=real64) public function point2_plus_point2 (self, p2) result(p3) Arguments Type Intent Optional Attributes Name class( point2 ), intent(in) :: self class( point2 ), intent(in) :: p2 Return Value type( point2 ) public function point2_minus_point2 (self, p2) result(p3) Arguments Type Intent Optional Attributes Name class( point2 ), intent(in) :: self class( point2 ), intent(in) :: p2 Return Value type( point2 ) public function point2_unary_minus (self) result(p3) Arguments Type Intent Optional Attributes Name class( point2 ), intent(in) :: self Return Value type( point2 ) public function point2_distance_between_point2 (self, p2) result(dist) Arguments Type Intent Optional Attributes Name class( point2 ), intent(in) :: self class( point2 ), intent(in) :: p2 Return Value real(kind=real64) public function point3_to_array (self) result(array) Arguments Type Intent Optional Attributes Name class( point3 ), intent(in) :: self Return Value real(kind=real64),\n  dimension(3) public function point3_from_spherical_r32 (rho, theta, phi) result(point) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: rho real(kind=real32), intent(in) :: theta real(kind=real32), intent(in) :: phi Return Value type( point3 ) public function point3_from_spherical_r64 (rho, theta, phi) result(point) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: rho real(kind=real64), intent(in) :: theta real(kind=real64), intent(in) :: phi Return Value type( point3 ) public function point3_from_spherical_int (rho, theta, phi) result(point) Arguments Type Intent Optional Attributes Name integer, intent(in) :: rho integer, intent(in) :: theta integer, intent(in) :: phi Return Value type( point3 ) public function point3_rho (self) result(rho) Calculate the magnitude (distance from the origin) of Arguments Type Intent Optional Attributes Name class( point3 ), intent(in) :: self Return Value real(kind=real64) public function point3_theta (self) result(theta) Return the inlination theta Arguments Type Intent Optional Attributes Name class( point3 ), intent(in) :: self Return Value real(kind=real64) public function point3_phi (self) result(phi) return the azimuth phi Arguments Type Intent Optional Attributes Name class( point3 ), intent(in) :: self Return Value real(kind=real64) public function point3_plus_point3 (self, p2) result(p3) Arguments Type Intent Optional Attributes Name class( point3 ), intent(in) :: self class( point3 ), intent(in) :: p2 Return Value type( point3 ) public function point3_minus_point3 (self, p2) result(p3) Arguments Type Intent Optional Attributes Name class( point3 ), intent(in) :: self class( point3 ), intent(in) :: p2 Return Value type( point3 ) public function point3_unary_minus (self) result(p3) Arguments Type Intent Optional Attributes Name class( point3 ), intent(in) :: self Return Value type( point3 ) public function point3_dot_point3 (self, p2) result(dot) Arguments Type Intent Optional Attributes Name class( point3 ), intent(in) :: self class( point3 ), intent(in) :: p2 Return Value real(kind=real64) public function point3_cross_point3 (self, p2) result(p3) Arguments Type Intent Optional Attributes Name class( point3 ), intent(in) :: self class( point3 ), intent(in) :: p2 Return Value type( point3 ) public function point3_distance_between_point3 (self, p2) result(dist) Arguments Type Intent Optional Attributes Name class( point3 ), intent(in) :: self class( point3 ), intent(in) :: p2 Return Value real(kind=real64) public function vector3_magnitude (self) result(length) Arguments Type Intent Optional Attributes Name class( vector3 ), intent(in) :: self Return Value real(kind=real64) public function vector3_to_array (self) result(array) Arguments Type Intent Optional Attributes Name class( vector3 ), intent(in) :: self Return Value real(kind=real64),\n  dimension(3) public function vector3_plus_vector3 (self, v2) result(v3) Arguments Type Intent Optional Attributes Name class( vector3 ), intent(in) :: self class( vector3 ), intent(in) :: v2 Return Value type( vector3 ) public function vector3_minus_vector3 (self, v2) result(v3) Arguments Type Intent Optional Attributes Name class( vector3 ), intent(in) :: self class( vector3 ), intent(in) :: v2 Return Value type( vector3 ) public function vector3_unary_minus (self) result(v3) Arguments Type Intent Optional Attributes Name class( vector3 ), intent(in) :: self Return Value type( vector3 ) public function vector3_times_scalar_r32 (self, k) result(v2) Arguments Type Intent Optional Attributes Name class( vector3 ), intent(in) :: self real(kind=real32), intent(in) :: k Return Value type( vector3 ) public function vector3_times_scalar_r64 (self, k) result(v2) Arguments Type Intent Optional Attributes Name class( vector3 ), intent(in) :: self real(kind=real64), intent(in) :: k Return Value type( vector3 ) public function vector3_times_scalar_int (self, k) result(v2) Arguments Type Intent Optional Attributes Name class( vector3 ), intent(in) :: self integer, intent(in) :: k Return Value type( vector3 ) public function scalar_times_vector3_r32 (k, v1) result(v2) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: k class( vector3 ), intent(in) :: v1 Return Value type( vector3 ) public function scalar_times_vector3_r64 (k, v1) result(v2) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: k class( vector3 ), intent(in) :: v1 Return Value type( vector3 ) public function scalar_times_vector3_int (k, v1) result(v2) Arguments Type Intent Optional Attributes Name integer, intent(in) :: k class( vector3 ), intent(in) :: v1 Return Value type( vector3 ) public function vector3_dot_vector3 (self, v2) result(dot) Arguments Type Intent Optional Attributes Name class( vector3 ), intent(in) :: self class( vector3 ), intent(in) :: v2 Return Value real(kind=real64) public function vector3_cross_vector3 (self, v2) result(normal) Arguments Type Intent Optional Attributes Name class( vector3 ), intent(in) :: self class( vector3 ), intent(in) :: v2 Return Value type( vector3 ) public function vector3_angle_between_vector3 (self, v2) result(theta) Return angle between vectors in degrees Arguments Type Intent Optional Attributes Name class( vector3 ), intent(in) :: self class( vector3 ), intent(in) :: v2 Return Value real(kind=real64) public function cross_product_r32 (v1, v2) result(normal) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(3) :: v1 Vectors to cross multiply real, intent(in), dimension(3) :: v2 Vectors to cross multiply Return Value real,\n  dimension(3) Normal vector that is the output public function cross_product_r64 (v1, v2) result(normal) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(3) :: v1 Vectors to cross multiply real(kind=real64), intent(in), dimension(3) :: v2 Vectors to cross multiply Return Value real(kind=real64),\n  dimension(3) Normal vector that is the output public function distance (p1, p2) result(d1) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(3) :: p1 Points to calculate distance between real, intent(in), dimension(3) :: p2 Points to calculate distance between Return Value real public function line2_atx (self, x) result(y) Arguments Type Intent Optional Attributes Name class( line2 ), intent(in) :: self real(kind=real64), intent(in) :: x Return Value real(kind=real64) public function line2_aty (self, y) result(x) Arguments Type Intent Optional Attributes Name class( line2 ), intent(in) :: self real(kind=real64), intent(in) :: y Return Value real(kind=real64) Subroutines public subroutine point2_from_array_r32 (point, array) Arguments Type Intent Optional Attributes Name class( point2 ), intent(out) :: point real(kind=real32), intent(in), dimension(2) :: array public subroutine point2_from_array_r64 (point, array) Arguments Type Intent Optional Attributes Name class( point2 ), intent(out) :: point real(kind=real64), intent(in), dimension(2) :: array public subroutine point2_from_array_int (point, array) Arguments Type Intent Optional Attributes Name class( point2 ), intent(out) :: point integer, intent(in), dimension(2) :: array public subroutine point2_print_cartesian (self) Arguments Type Intent Optional Attributes Name class( point2 ), intent(in) :: self public subroutine point2_print_polar (self) Print the polar coordinates of a point in this form Arguments Type Intent Optional Attributes Name class( point2 ), intent(in) :: self public subroutine point3_from_array_r32 (point, array) Arguments Type Intent Optional Attributes Name class( point3 ), intent(out) :: point real(kind=real32), intent(in), dimension(3) :: array public subroutine point3_from_array_r64 (point, array) Arguments Type Intent Optional Attributes Name class( point3 ), intent(out) :: point real(kind=real64), intent(in), dimension(3) :: array public subroutine point3_from_array_int (point, array) Arguments Type Intent Optional Attributes Name class( point3 ), intent(out) :: point integer, intent(in), dimension(3) :: array public subroutine point3_print_cartesian (self) Arguments Type Intent Optional Attributes Name class( point3 ), intent(in) :: self public subroutine point3_print_spherical (self) Print the polar coordinates of a point in this form Arguments Type Intent Optional Attributes Name class( point3 ), intent(in) :: self public subroutine vector3_print (self) Arguments Type Intent Optional Attributes Name class( vector3 ), intent(in) :: self public subroutine vector3_from_array_r32 (vector, array) Arguments Type Intent Optional Attributes Name class( vector3 ), intent(out) :: vector real(kind=real32), intent(in), dimension(3) :: array public subroutine vector3_from_array_r64 (vector, array) Arguments Type Intent Optional Attributes Name class( vector3 ), intent(out) :: vector real(kind=real64), intent(in), dimension(3) :: array public subroutine vector3_from_array_int (vector, array) Arguments Type Intent Optional Attributes Name class( vector3 ), intent(out) :: vector integer, intent(in), dimension(3) :: array public subroutine line2_from_two_point2 (line, two_points) Arguments Type Intent Optional Attributes Name class( line2 ), intent(out) :: line class( point2 ), intent(in), dimension(2), target :: two_points public subroutine line2_print (self) Arguments Type Intent Optional Attributes Name class( line2 ), intent(in) :: self","tags":"","loc":"module/foreng_math_geom.html"},{"title":"foreng_math_sets – Fortran Program","text":"Contains functions that deal with the mathematical definition of sets. Find the union of two rank 1 arrays with \\verb|union| . Find \n the intersection with \\verb|intersection| . Check if a given x belongs to a set with \\verb|belongs_to| Uses foreng_env Contents Interfaces intersection union belongs_to array_epsilon abs_max_val Functions intersection_int intersection_r32 intersection_r64 union_int union_r32 union_r64 belongs_to_int belongs_to_r32 belongs_to_r64 array_epsilon_r32 array_epsilon_r64 abs_max_val_r32 abs_max_val_r64 Interfaces public interface intersection Compute the intersection of two sets public function intersection_int (A, B) result(inters) Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:) :: A set A integer, intent(in), dimension(:) :: B set B Return Value integer,\n  dimension(:), allocatable A \\cap B public function intersection_r32 (A, B) result(inters) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), dimension(:) :: A set A real(kind=real32), intent(in), dimension(:) :: B set B Return Value real(kind=real32),\n  dimension(:), allocatable A \\cap B public function intersection_r64 (A, B) result(inters) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:) :: A set A real(kind=real64), intent(in), dimension(:) :: B set B Return Value real(kind=real64),\n  dimension(:), allocatable A \\cap B public interface union Compute the union of two sets public function union_int (A, B) result(union_set) Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:) :: A set A integer, intent(in), dimension(:) :: B set B Return Value integer,\n  dimension(:), allocatable A \\cup B public function union_r32 (A, B) result(union_set) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), dimension(:) :: A set A real(kind=real32), intent(in), dimension(:) :: B set B Return Value real(kind=real32),\n  dimension(:), allocatable A \\cup B public function union_r64 (A, B) result(union_set) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:) :: A set A real(kind=real64), intent(in), dimension(:) :: B set B Return Value real(kind=real64),\n  dimension(:), allocatable A \\cup B public interface belongs_to Check if x \\in \\textrm{A} x belongs to A if there is at least one element y in A for which x = y public function belongs_to_int (x, A) result(bool) Check if a value x belongs to a set \\textrm{A} Arguments Type Intent Optional Attributes Name integer, intent(in) :: x integer, dimension(:) :: A Return Value logical public function belongs_to_r32 (x, A, eps) result(bool) Check if a value x belongs to a set within a certain tolerance \\epsilon . If \\epsilon is not specified, it will automatically\n calculated using the \\verb|array_epsilon| function Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: x real(kind=real32), dimension(:) :: A real(kind=real32), optional :: eps x = y \\iff \\textrm{abs}(x - y) < \\epsilon Return Value logical public function belongs_to_r64 (x, A, eps) result(bool) Check if a value x belongs to a set within a certain tolerance \\epsilon . If \\epsilon is not specified, it will automatically\n calculated using the \\verb|array_epsilon| function Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x real(kind=real64), dimension(:) :: A real(kind=real64), optional :: eps x = y \\iff \\textrm{abs}(x - y) < \\epsilon Return Value logical public interface array_epsilon public function array_epsilon_r32 (array) result(eps) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), dimension(:) :: array Return Value real(kind=real32) public function array_epsilon_r64 (array) result(eps) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:) :: array Return Value real(kind=real64) public interface abs_max_val public function abs_max_val_r32 (array) result(abs_max_val) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), dimension(:) :: array Return Value real(kind=real32) public function abs_max_val_r64 (array) result(abs_max_val) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:) :: array Return Value real(kind=real64) Functions public function intersection_int (A, B) result(inters) Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:) :: A set A integer, intent(in), dimension(:) :: B set B Return Value integer,\n  dimension(:), allocatable A \\cap B public function intersection_r32 (A, B) result(inters) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), dimension(:) :: A set A real(kind=real32), intent(in), dimension(:) :: B set B Return Value real(kind=real32),\n  dimension(:), allocatable A \\cap B public function intersection_r64 (A, B) result(inters) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:) :: A set A real(kind=real64), intent(in), dimension(:) :: B set B Return Value real(kind=real64),\n  dimension(:), allocatable A \\cap B public function union_int (A, B) result(union_set) Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:) :: A set A integer, intent(in), dimension(:) :: B set B Return Value integer,\n  dimension(:), allocatable A \\cup B public function union_r32 (A, B) result(union_set) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), dimension(:) :: A set A real(kind=real32), intent(in), dimension(:) :: B set B Return Value real(kind=real32),\n  dimension(:), allocatable A \\cup B public function union_r64 (A, B) result(union_set) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:) :: A set A real(kind=real64), intent(in), dimension(:) :: B set B Return Value real(kind=real64),\n  dimension(:), allocatable A \\cup B public function belongs_to_int (x, A) result(bool) Check if a value x belongs to a set \\textrm{A} Arguments Type Intent Optional Attributes Name integer, intent(in) :: x integer, dimension(:) :: A Return Value logical public function belongs_to_r32 (x, A, eps) result(bool) Check if a value x belongs to a set within a certain tolerance \\epsilon . If \\epsilon is not specified, it will automatically\n calculated using the \\verb|array_epsilon| function Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: x real(kind=real32), dimension(:) :: A real(kind=real32), optional :: eps x = y \\iff \\textrm{abs}(x - y) < \\epsilon Return Value logical public function belongs_to_r64 (x, A, eps) result(bool) Check if a value x belongs to a set within a certain tolerance \\epsilon . If \\epsilon is not specified, it will automatically\n calculated using the \\verb|array_epsilon| function Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x real(kind=real64), dimension(:) :: A real(kind=real64), optional :: eps x = y \\iff \\textrm{abs}(x - y) < \\epsilon Return Value logical public function array_epsilon_r32 (array) result(eps) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), dimension(:) :: array Return Value real(kind=real32) public function array_epsilon_r64 (array) result(eps) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:) :: array Return Value real(kind=real64) public function abs_max_val_r32 (array) result(abs_max_val) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), dimension(:) :: array Return Value real(kind=real32) public function abs_max_val_r64 (array) result(abs_max_val) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:) :: array Return Value real(kind=real64)","tags":"","loc":"module/foreng_math_sets.html"},{"title":"foreng_numeric_matrices_inverse – Fortran Program","text":"Uses Ancestors: foreng_numeric_matrices Contents None","tags":"","loc":"module/foreng_numeric_matrices_inverse.html"},{"title":"foreng_numeric_matrices_gauss – Fortran Program","text":"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! Uses Ancestors: foreng_numeric_matrices Contents None","tags":"","loc":"module/foreng_numeric_matrices_gauss.html"},{"title":"demo – Fortran Program","text":"Uses chapter_4 chapter_5 chapter_6 chapter_7 Contents Variables i j ierr errmsg p7_6_real Subroutines chapter_select chapter_selected problem_select program_start program_end to_continue Variables Type Attributes Name Initial integer :: i = 0 integer :: j = 0 integer :: ierr character(len=100) :: errmsg real :: p7_6_real = 1.0 Subroutines subroutine chapter_select () Arguments None subroutine chapter_selected (chp) Arguments Type Intent Optional Attributes Name integer, intent(in) :: chp subroutine problem_select () Arguments None subroutine program_start () Arguments None subroutine program_end () Arguments None subroutine to_continue () Arguments None","tags":"","loc":"program/demo.html"},{"title":"test_stats – Fortran Program","text":"Uses foreng_math Contents Variables x_i32 x_i64 x_r32 x_r64 Variables Type Attributes Name Initial integer(kind=int32), dimension(8) :: x_i32 = [10, 12, 23, 23, 16, 23, 21, 16] integer(kind=int64), dimension(8) :: x_i64 = [10, 12, 23, 23, 16, 23, 21, 16] real(kind=real32), dimension(8) :: x_r32 = [10, 12, 23, 23, 16, 23, 21, 16] real(kind=real64), dimension(8) :: x_r64 = [10, 12, 23, 23, 16, 23, 21, 16]","tags":"","loc":"program/test_stats.html"},{"title":"test_hyper – Fortran Program","text":"Contents Variables x Variables Type Attributes Name Initial real :: x = 4","tags":"","loc":"program/test_hyper.html"},{"title":"trig_test – Fortran Program","text":"Uses foreng_math Contents Variables thetad theta max_vals Variables Type Attributes Name Initial real(kind=real64) :: thetad = 90 real(kind=real64) :: theta real(kind=real64), dimension(3) :: max_vals = [-10.d0, 0d0, 5d0]","tags":"","loc":"program/trig_test.html"},{"title":"misc_test – Fortran Program","text":"Uses foreng_math_misc iso_fortran_env Contents None","tags":"","loc":"program/misc_test.html"},{"title":"prob_test – Fortran Program","text":"Uses foreng_math Contents Variables x x_2 test Variables Type Attributes Name Initial integer, dimension(1000) :: x real, dimension(100000) :: x_2 integer, dimension(8) :: test = [1, 2, 3, 4, 5, 6, 7, 8]","tags":"","loc":"program/prob_test.html"},{"title":"geom_test – Fortran Program","text":"Uses foreng_math_geom Contents Variables p1 p2 p3 dp p3_1 v1 v2 v3 line Variables Type Attributes Name Initial type( point2 ) :: p1 type( point2 ) :: p2 type( point2 ) :: p3 real(kind=real64) :: dp type( point3 ) :: p3_1 type( vector3 ) :: v1 type( vector3 ) :: v2 type( vector3 ) :: v3 type( line2 ) :: line","tags":"","loc":"program/geom_test.html"},{"title":"sets_test – Fortran Program","text":"Uses foreng_math Contents Variables setA setB uni inters Variables Type Attributes Name Initial real(kind=real32), dimension(10) :: setA = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] real(kind=real32), dimension(10) :: setB = [1, -10, 3, 5, -13, 6, -2, 8, 13, 10] real(kind=real32), dimension(:), allocatable :: uni real(kind=real32), dimension(:), allocatable :: inters","tags":"","loc":"program/sets_test.html"}]}