var tipuesearch = {"pages":[{"title":" Fortran Program ","text":"Fortran Program Hi, my name is ejovo13. Developer Info Evan Voyles Learning Fortran.","tags":"home","loc":"index.html"},{"title":"chapter_4.f90 – Fortran Program","text":"Contents Modules chapter_4 Source Code chapter_4.f90 Source Code module chapter_4 !! All of the programming exercises for Chapter 4: Loops and Character Manipulation use iso_fortran_env implicit none contains ! //TODO CLEAN UP OUTPUT OF ALL PROGRAMS subroutine p4_1 () !! Test if the following equalities are valid statements, and if they are, !! evaluate them logical :: a , b character ( 5 ) :: c , d a = '123' > 'abc' ! b = '9478' == 9478 c = ACHAR ( 65 ) // ACHAR ( 95 ) // ACHAR ( 72 ) d = ACHAR ( IACHAR ( 'j' ) + 5 ) print * , \"a: \" , a , \"b: \" , b , \"c: \" , c , \"d: \" , d end subroutine subroutine p4_3 () !! Write a Fortran program to evaluate the equation y(x) = x&#94;2 - 3x + 2 for all values between -1 and 3, !! in steps of 0.1. ! // TODO add latex support ! Puprose: to solve exercise 4.3 ! Data dictionary :: declared variables integer , parameter :: start_index = - 1 , end_index = 3 real , parameter :: step_size = 0.1 integer , parameter :: array_size = int (( end_index - start_index ) / step_size ) integer :: i real , dimension ( array_size ) :: output = [( 0.1 * i + - 1 , i = 0 ,( array_size - 1 ))] integer :: x do x = 1 , array_size output ( x ) = x ** 2 - 3 * x + 2 end do write ( * , 100 ) output 100 format ( ES9 . 2 ) end subroutine subroutine p4_4 () !! Write the Fortran statements required to calculate y(t) from the equation: !! !!   y(t) = ------ -3t&#94;2 + 5    t >= 0 !!           \\---   3t&#94;2 + 5    t < 0 !! ! //TODO print function to stdin real :: y , t print * , \"Please enter a t value that you would like to compute\" read * , t if ( t >= 0 ) then y = - 3 * ( t ** 2 ) + 5 else y = 3 * ( t ** 2 ) + 5 end if print 100 , \"y(t) with t = \" , t , \" is equal to \" , y 100 format ( A , ES9 . 2 , A , ES9 . 2 ) end subroutine subroutine p4_5 () !! Write a Fortran program to calculate the factorial function. Be sure to handle the special !! cases of 0! and of illegal input values. ! integer, parameter :: MY_INT_64 = selected_int_kind(38) integer ( int64 ) :: input , factorial , i = 1 , ierr ! logical :: value_accepted = .false. print * , \"Please enter an integer to find it's factorial, max value 33!\" read ( * , '(i10)' , iostat = ierr ) input do if ( ierr == 0 ) then exit end if print * , \"Value not accepted, please enter an integer\" read ( * , '(i2)' , iostat = ierr ) input end do if ( input == 0 ) then factorial = 1 end if do i = 1 , input if ( i == 1 ) then factorial = 1 else factorial = factorial * i end if if ( factorial < 0 ) then error stop \"Overflow error, input value too large\" end if end do print 99 , input , factorial 99 format ( I0 , \" factorial is: \" , I0 ) end subroutine subroutine p4_6 () !! What is the difference in behavior between a cycle statement and an exit statement? print * , \"A cycle statement sends the program control to the start of the loop, whereas the exit statement\" print * , \"exits the loop entirely\" end subroutine subroutine p4_7 () !! Modify program stats_2 to use the DO WHILE construct instaed of the while construct currently in the program !! !!     A modified statistical analysis program that avoids the divide-by-zero problems inherent in !! program stats_1. !! !! Purpose: !! !! To calculate mean and the standard deviation of an input !! !!  data set containing an arbitrary number of input values. !! !! Record of revisions: !! !!  Date      Programmer     Description of change !!  ====      ==========     ===================== !! 11/10/15  S. J. Chapman   Original code !! 11/12/15  S. J. Chapman   Correct divide-by-0 error if !!                           0 or 1 input values given. !! 02/16/21  E. J. Voyles    Add do-while construct !! IMPLICIT NONE ! Data dictionary: declare variable types, definitions, & units INTEGER :: n = 0 ! The number of input samples. REAL :: std_dev = 0. ! The standard deviation of the input samples. REAL :: sum_x = 0. ! The sum of the input values. REAL :: sum_x2 = 0. ! The sum of the squares of the input values. REAL :: x = 0. ! An input data value. REAL :: x_bar ! The average of the input samples. ! While Loop to read input values. DO ! Read in next value WRITE ( * , * ) 'Enter number: ' READ ( * , * ) x WRITE ( * , * ) 'The number is ' , x ! Test for loop exit IF ( x < 0 ) EXIT ! Otherwise, accumulate sums. n = n + 1 sum_x = sum_x + x sum_x2 = sum_x2 + x ** 2 END DO ! Check to see if we have enough input data. IF ( n < 2 ) THEN ! Insufficient information WRITE ( * , * ) 'At least 2 values must be entered!' ELSE ! There is enough information, so ! calculate the mean and standard deviation x_bar = sum_x / real ( n ) std_dev = sqrt ( ( real ( n ) * sum_x2 - sum_x ** 2 ) / ( real ( n ) * real ( n - 1 ))) ! Tell user. WRITE ( * , * ) 'The mean of this data set is:' , x_bar WRITE ( * , * ) 'The standard deviation is: ' , std_dev WRITE ( * , * ) 'The number of data points is:' , n END IF end subroutine subroutine p4_8 () !! Examine the following DO statements and determine how many times each loop will !! be exectued. implicit NONE integer :: irange , j , kount , i !, index integer :: count = 0 a : do irange = - 32768 , 32767 count = count + 1 end do a print * , \"(a) = \" , count count = 0 b : do j = 100 , 1 , - 10 count = count + 1 end do b print * , \"(b) = \" , count count = 0 c : do kount = 2 , 3 , 4 count = count + 1 end do c print * , \"(c) = \" , count count = 0 ! d: do index = -4,-7 !     count = count + 1 ! end do d print * , \"(d) = \" , count count = 0 e : do i = - 10 , 10 , 10 count = count + 1 end do e print * , \"(e) = \" , count count = 0 ! f: do i = 10, -2, 0 !     count = count + 1 ! end do f !!!!! This for loop shows an error, since the increment is 0 !!!!!!!!!! ! print *, \"(f) = \", count ! count = 0 end subroutine subroutine p4_9 () !! Examine the following loops, determine the value of ires and the number of times !! each loop executes integer :: ires ! (b) ! ires = 0 ! loop1: DO index1 = 1, 20, 5 !     IF ( index1 <= 10 ) CYCLE !     loop2: DO index2 = index1, 20, 5 !         ires = ires + index2 !     END DO loop2 ! END DO loop1 ! (c) ! ires = 0 ! loop1: do index1 = 10, 4, -2 !     loop2: do index2 = 2, index1, 2 !         if (index2 > 6) exit loop2 !         ires = ires + index2 !     end do loop2 ! end do loop1 ! (d) ! ires = 0 ! loop1: do index1 = 10, 4, -2 !     loop2: do index2 = 2, index1, 2 !         if (index2 > 6) exit loop1 !         ires = ires + index2 !     end do loop2 ! end do loop1 !! answers !! (b) ires = 43 !! (c) ires = 42 !! (d) loop2 is run 3 times, loop1 exits during it's first iteration, ires = 12 print * , \"Ires = \" , ires end subroutine subroutine p4_10 () !! Examine the followin while loops and determine the value of ires at the end of each of !! the loops. integer :: ires , count ! (a) !  ires = 0 ! loop1: DO !     ires = ires + 1 !     IF ( (ires / 10 ) * 10 == ires ) EXIT ! END DO loop1 ! (b) ! count = 0 ! ires = 2 ! loop2: DO !     ires = ires**2 !     count = count + 1 !     IF ( ires > 200 ) EXIT ! END DO loop2 ! ! (c) ! count = 0 ! ires = 2 ! DO WHILE ( ires > 200 ) ! ires = ires**2 ! count = count + 1 ! END DO print * , \"ires = \" , ires , \" count = \" , count end subroutine subroutine p4_11 () !! Modify program ball from example 4-7 to read in the acceleration due to gravity !! at a particular location, and to calculate the maximum range of the ball for that acceleration. !! After modifying the program, run it with accelerations of -9.8, -9.7, and -9.6m/s2. !! !! What effect does the reduction in gravitational attraction have on the range ofthe ball? !! What effect does the reduction in gravitational attraction have on the best angle theta at which to throw the ball? ! Purpose: ! !       To test how the flight of a ball changes in different gravitational fields ! ! ! Data Dictionary: Declare constants and variables implicit none real :: g ! The gravitational constant, g. This value will be read in at the start of every execution real :: vx ! The horizontal velocity of the ball real :: vy ! The vertical velocity of the ball real :: v0 = 20 ! The initial velocity of the ball real :: tf ! Time when the ball lands real :: max_distance = 0 ! Maximum distance traveled integer :: theta = 0 ! Angle at which the ball is thrown integer :: max_theta ! The theta for which the ball travels the most distance real , dimension ( 0 : 90 ) :: distance_traveled ! The distance traveled for each theta value character ( 50 ) :: FMT ! The format of the output table real , parameter :: PI = 3.1415927 ! Mathematical constant pi integer :: ierr ! flag for reading in the gravitational value character ( 50 ) :: errmsg ! the error message for reagding in FMT = \"(I3, A, F5.2, A, F6.2, A, F5.2)\" 100 print * , \"Please enter a real, negative value for the gravitational constant\" read ( * , * , iostat = ierr , iomsg = errmsg ) g if ( ierr /= 0 ) then print * , \"ierr = \" , ierr , \" iomsg = \" , errmsg goto 100 end if print * , \"Theta | time in air(s) | distance traveled(m) | vy\" print * , \"--------------------------------------------------\" do theta = 0 , 90 , 1 vx = v0 * cos (( theta / 18 0. ) * PI ) vy = v0 * sin (( theta / 18 0. ) * PI ) ! Find tf tf = vy / ( - g / 2 ) distance_traveled ( theta ) = tf * vx if ( distance_traveled ( theta ) > max_distance ) then max_distance = distance_traveled ( theta ) max_theta = theta end if print ( FMT ), theta , \" | \" , tf , \" | \" , distance_traveled ( theta ), \" | \" , vy end do print * , \"Max distance traveled: \" , max_distance , \"With theta: \" , max_theta end subroutine subroutine p4_12 () !! Modify program ball from Example 4-7 to read in the initial velocity with which the ball !! is thrown. After modifying the program, run it with initial velocities of 10, 20, and 20 !! m/sec. What effect does changin the initial velocity have on the range of the ball? What !! effect does it have on the best angle theta at which to throw the ball? ! Purpose: ! !       To test how the flight of a ball changes with different initial velocites ! ! ! Data Dictionary: Declare constants and variables implicit none real :: g = - 9.8 ! The gravitational constant, g. real :: vx ! The horizontal velocity of the ball, m/sec real :: vy ! The vertical velocity of the ball real :: v0 ! The initial velocity of the ball, this will be read in upon execution real :: tf ! Time when the ball lands real :: max_distance = 0 ! Maximum distance traveled integer :: theta = 0 ! Angle at which the ball is thrown integer :: max_theta ! The theta for which the ball travels the most distance real , dimension ( 0 : 90 ) :: distance_traveled ! The distance traveled for each theta value character ( 50 ) :: FMT ! The format of the output table real , parameter :: PI = 3.1415927 ! Mathematical constant pi integer :: ierr ! flag for reading in the gravitational value character ( 50 ) :: errmsg ! the error message for reagding in FMT = \"(I3, A, F5.2, A, F6.2, A, F5.2)\" 100 print * , \"Please enter a real value for the initial velocity\" read ( * , * , iostat = ierr , iomsg = errmsg ) v0 if ( ierr /= 0 ) then print * , \"ierr = \" , ierr , \" iomsg = \" , errmsg goto 100 end if print * , \"Theta | time in air(s) | distance traveled(m) | vy\" print * , \"--------------------------------------------------\" do theta = 0 , 90 , 1 vx = v0 * cos (( theta / 18 0. ) * PI ) vy = v0 * sin (( theta / 18 0. ) * PI ) ! Find tf tf = vy / ( - g / 2 ) distance_traveled ( theta ) = tf * vx if ( distance_traveled ( theta ) > max_distance ) then max_distance = distance_traveled ( theta ) max_theta = theta end if print ( FMT ), theta , \" | \" , tf , \" | \" , distance_traveled ( theta ), \" | \" , vy end do print * , \"Max distance traveled: \" , max_distance , \"With theta: \" , max_theta end subroutine subroutine p4_13 () print * , \"Work in progress\" end subroutine subroutine p4_14 () !! Write a Fortran program to evaluate the function !! y(x) = ln(1/1-x) !! for any user-specified value of x, where ln is the natural logarithm. !! Write the program with a while loop, so that the program repeats the calculation !! for each legal value of x entered into the program. When an illegal value of x is entered, !! terminate the program. !   Purpose: !       This program calculates the value of ln(1/(1-x)) for all valid !       values of x entered by the user ! ! IMPLICIT NONE ! Data dictionary: declare variable types, definitions, & units. real :: x ! The x value to be evaluated integer :: ierr = 0 ! The error status when reading in the value character ( 100 ) :: errmsg ! The error message generated when reading in a value do while ( ierr == 0 ) print * , \"Please enter a real number greater than 1\" read ( * , * , iostat = ierr , iomsg = errmsg ) x if ( x <= 1 . or . ierr /= 0 ) exit print 100 , x , log (( 1 ) / ( x - 1 )) end do 100 Format ( \"f(\" , f10 . 2 , \") = \" , f7 . 3 ) end subroutine subroutine p4_15 () !! Write a Fortran program to convert all uppercase characters in a user-supplied character !! string to lowercase, without changing the uppercase and nonalphabetic characters in the string. !! Assume that your computer uses the ASCII collating sequence. !   Purpose: !       This program converts all uppercase letters to lowercase letters IMPLICIT NONE ! Data Dictionary: declare variable types, definitions, and units integer , parameter :: MAX_LENGTH = 30 character ( len = MAX_LENGTH ) :: start_string character ( MAX_LENGTH ) :: end_string integer :: i integer :: this_char_index character :: this_char print * , \"Please enter a string you would like to convert to lowercase\" read '(30A)' , start_string do i = 1 , MAX_LENGTH this_char = start_string ( i : i ) this_char_index = iachar ( this_char ) if ( this_char_index >= 65 . and . this_char_index <= 90 ) then end_string ( i : i ) = achar ( this_char_index + 32 ) else end_string ( i : i ) = this_char end if end do print * , \"Converted string: \" , start_string , \" to string: \" , end_string end subroutine subroutine p4_16 () !! Calculating Orbits. !! !! When a satellinte orbits the Eath, the satellite's orbit will form an ellipse with the !! Earth located at one of the focal points of the ellipse. The satellite's orbit can be !! expressed in polar coordintaes as !! !! r = p/(1 - \\epsilon * cos( \\theta )) !! !! Where r and theta are the distance and angle of the satellite from the center of the earth, !! p is a parameter specifying the size of the orbit, and \\epsilon is a parameter representing the !! eccentricity of the orbit. A circular orbit has an eccentricity of zero. An elliptical orbit has !! an eccentricity of 0 <= e <= 1. If \\epsilon > 1, the satellite follows a hyperbolic path and escapes !! from Earth's gravitational field. !! !! Consider a satellite with a size parameter p = 1200 km. Write a program to calculate the !! distance of the satellite from the center of the Earth as a function of theta if the satellite has !! an eccentricity of (a) e = 0; (b) e = 0.25; (c) e = 0.5. Write a single program in which !! r and e are both input values. !! !! How close does each orbit come to the earth? How far away does each orbit get from the earth? !   Purpose: !      To calculate the position of a satellite orbiting the Earth. ! Data dictionary: declare variable types, definitions, and units integer , parameter :: P = 1200 ! Size of the orbit, in km. integer , parameter :: NTHETA = 200 real , parameter :: PI = 3.1415927 real , parameter :: THETA_STEP = ( 2 * PI ) / NTHETA real :: eccentricity ! Eccentricity of the orbit, 0 <= e <= 1 real :: theta ! Polar coordinate for the satellite. real :: r ! Distance from the center of the earth. real :: apoapsis = P ! Farthest distance from the center of the earth real :: periapsis = P ! Closest distance from the center of the earth integer :: ierr character ( 30 ) :: errmsg integer itheta print * , \"Please enter an eccentricity value, between 0 and 1.\" read ( * , * , iostat = ierr , iomsg = errmsg ) eccentricity do while ( ierr /= 0 . and . ( eccentricity > 1 . or . eccentricity < 0 )) print * , \"Input invalid, please enter a real value between 0 and 1.\" read ( * , * , iostat = ierr , iomsg = errmsg ) eccentricity end do do itheta = 1 , NTHETA theta = itheta * THETA_STEP r = p / ( 1 - ( eccentricity * cos ( theta ))) if ( r < periapsis ) periapsis = r if ( r > apoapsis ) apoapsis = r print * , theta , r end do print * , \"The periapsis is: \" , periapsis , \"km, and the apoapsis is: \" , apoapsis , \"km\" end subroutine subroutine p4_17 () !! Write a program caps that reads in a character string, searches for all of the words !! within the string, and capitalizes the first letter of each word, while shifting the !! remainder of the word to lowercase. Assume that all nonalphabetic and nonumeric characters !! can mark the boundaries of a word within the character variable (periods, commas,etc.). !! Nonalphabetic characters should be left unchanged. ! 2. Define the input and output ! input: A character string from the terminal. ! output: The same string with the only the first letter per word capitalized. ! 3. Describe the algorithm ! We should first read in the string ! Alphabetic character ranges: !   lowercase: [97, 122] !   uppercase: [65, 90] ! Numeric character ranges: !   [48, 57] ! ! We assume that all nonalphabetic and nonnumeric characters can mark the boundaries of a word. ! Purpose: !   To capitalize the first letter per word in a character string. ! Data dictionary: integer , parameter :: MAX_STR_LEN = 500 character (:), allocatable :: input_str character ( 30 ) :: FMT integer :: i integer :: num_chars character ( 1 ) :: prev_char , this_char print * , \"Please enter a the number of characters to record\" read ( * , \"(I10)\" ) num_chars allocate ( character ( num_chars ) :: input_str ) write ( FMT , '(\"(A\", I0, \")\")' ) num_chars ! print *, \"Format statement saved as: \", FMT print * , \"Now please enter the string you would like to transform\" read ( * , FMT ) input_str print * , \"String before transformation: \" , input_str if ( is_alph ( input_str ( 1 :))) then call to_upper ( input_str ( 1 :)) end if do i = 2 , MAX_STR_LEN prev_char = input_str ( i - 1 :) this_char = input_str ( i :) ! If the character is the start of the word, then capitalize it if (. not . is_alphnum ( prev_char )) then ! If the previous character is a word boundary if ( is_lower ( this_char )) then ! And this character is lowercase call to_upper ( input_str ( i :)) ! Then capitalize it end if else if ( is_upper ( this_char )) then call to_lower ( input_str ( i :)) end if end if end do print * , \"String after transformation: \" , input_str end subroutine subroutine p4_18 () !!Write a computer program to calculate the current flowing through this diode !! for all voltages from -1.0V to +0.6 V, in 0.1 V steps. Repeat this process for the !! following temperatures: 75F, 100F, and 125F ! Purpose: !   To calculate the current flowing through a semiconductor diode real ( real64 ), dimension ( 3 ) :: T_f = [ 75 , 100 , 125 ] real ( real64 ), dimension ( 3 ) :: T_k real ( real64 ), parameter :: I_O = 2.0E-6 real ( real64 ), dimension ( 17 ) :: v_D real ( real64 ), dimension ( 3 , 17 ) :: i_D integer :: i , j do i = 1 , 17 v_D ( i ) = - 1.0 + ( 0.1 * ( i - 1 )) end do ! print *, v_D T_k = to_kelvin ( T_f ) print * , \" \" print * , \"Calculating the current flowing through a semiconductor diode for three separate temperatures\" print * , \"and voltages ranging from -1.0 to 0.6 V\" print * , \" \" print 999 , v_D print 100 100 format ( 250 ( \"-\" )) do i = 1 , 3 do j = 1 , 17 i_D ( i , j ) = calc_current_flow ( v_D ( j ), I_O , T_k ( i )) end do print 99 , T_k ( i ), i_D ( i ,:) 99 format ( F9 . 3 , 2 X , \" | \" , 17 ( ES10 . 3 , 3 X )) 999 format ( \"  T(K) \\ V \" , \" | \" , 17 ( F6 . 3 , 7 X )) end do end subroutine subroutine p4_19 () !! Write a program that promps a user for a binary number, which will be entered as a string !! of 0s and 1s in a character variable. This program should be able to handle numbers whos !! binary representation is up to 10 bits, corresponding to values from 0 to 1023. ! Purpose: !   To convert binary numbers to decimal. implicit none ! Data dictionary integer , parameter :: MAX_LEN = 10 integer , parameter :: ZERO_ASCII = 48 integer , parameter :: ONE_ASCII = 49 character ( MAX_LEN ) :: binary_representation character (:), allocatable :: binary_trimmed integer :: len_trim = 0 logical :: input_is_valid = . true . integer :: i = 0 character ( 1 ) :: this_char = '' integer :: char_value = 0 real :: decimal_representation = 0 integer :: this_bit = 0 ! print *, \"decimal_representation = \", decimal_representation print * , \"Please enter a binary number that is between 1 and 10 bits\" read ( * , \"(A10)\" ) binary_representation ! print *, \"Converting binary number: \", binary_representation binary_trimmed = trim ( binary_representation ) len_trim = len ( binary_trimmed ) ! First let's validate the input do i = 1 , len_trim this_char = binary_trimmed ( i :) char_value = ichar ( this_char ) if ( char_value /= ZERO_ASCII . and . char_value /= ONE_ASCII ) then input_is_valid = . false . print * , \"invalid char = \" , this_char print * , \"invalid val = \" , char_value print * , \"invalid pos = \" , i print * , \"\" print * , \"ZERO_ASCII = \" , ZERO_ASCII print * , \"ONE_ASCII = \" , ONE_ASCII exit end if end do if ( input_is_valid ) then ! print *, \"input is valid, converting now\" do i = 1 , len_trim read ( binary_representation ( i :), \"(I1)\" ) this_bit ! print *, \"Current working bit: \", this_bit decimal_representation = ( this_bit * 2 ** ( len_trim - i )) + decimal_representation end do else print * , \"input is invalid, please try restarting the program\" end if print 99 , binary_representation , int ( decimal_representation ) 99 format ( \"binary num: \" , T15 , A10 , / , 'decimal:' , T15 , I0 ) decimal_representation = 0 end subroutine !-------------------------------------! !------- HELPER FUNCTIONS ------------! !-------------------------------------! logical function is_alphnum ( char ) !! Test whether an ASCII character is alpha-numeric character ( 1 ), intent ( in ) :: char if ( is_num ( char ) . or . is_alph ( char )) then is_alphnum = . true . else is_alphnum = . false . end if end function logical function is_alph ( char ) !! Test whether an ASCII character is a letter character ( 1 ), intent ( in ) :: char if ( is_upper ( char ) . or . is_lower ( char )) then is_alph = . true . else is_alph = . false . end if end function logical function is_num ( char ) !! Test whether an ASCII character is numeric character ( 1 ), intent ( in ) :: char integer :: char_value char_value = iachar ( char ) if ( char_value >= 48 . and . char_value <= 57 ) then is_num = . true . else is_num = . false . end if end function logical function is_lower ( char ) !! Test whether an ASCII character is a lowercase letter character ( 1 ), intent ( in ) :: char integer :: char_value !! ASCII value char_value = iachar ( char ) if ( char_value >= 97 . and . char_value <= 122 ) then is_lower = . true . else is_lower = . false . end if end function logical function is_upper ( char ) !! Test whether an ASCII character is an uppercase letter character ( 1 ), intent ( in ) :: char integer :: char_value !! ASCII value char_value = iachar ( char ) if ( char_value >= 65 . and . char_value <= 90 ) then is_upper = . true . else is_upper = . false . end if end function subroutine to_lower ( char ) !! Convert a single character to lowercase character ( 1 ), intent ( inout ) :: char if ( is_upper ( char )) char = achar (( iachar ( char ) + 32 )) end subroutine subroutine to_upper ( char ) !! Convert a single character to uppercase character ( 1 ), intent ( inout ) :: char if ( is_lower ( char )) char = achar (( iachar ( char ) - 32 )) end subroutine elemental function calc_current_flow ( v_D , I_O , T ) result ( i_D ) ! Data Dictionary ! // TODO add proper documentation real ( real64 ) :: i_D !! The current flow through the diode in amperes real ( real64 ), intent ( in ) :: v_D !! The voltage across the diode, in volts real ( real64 ), intent ( in ) :: I_O !! The leakage current of the diode, in amperes real ( real64 ), intent ( in ) :: T !! Temperature, in kelvins (K) real ( real64 ), parameter :: q = 1.602E-19 !! The charge on an electron, 1.602 X 10-19 Coulombs real ( real64 ), parameter :: k = 1.38E-23 !! Boltzmann's constant, 1.38 X 10-23 J/K i_D = I_O * ( exp (( q * v_D ) / ( k * T )) - 1 ) end function elemental real ( real64 ) function to_kelvin ( F ) !! Convert a temperature in Fahrenheit to Kelvin real ( real64 ), intent ( in ) :: F to_kelvin = to_celcius ( F ) + 273 end function elemental real ( real64 ) function to_celcius ( F ) !! Convert a temperature from Fahrenheit to celcius real ( real64 ), intent ( in ) :: F to_celcius = ( F - 32 ) * ( 5. / 9. ) end function end module","tags":"","loc":"sourcefile/chapter_4.f90.html"},{"title":"chapter_7.f90 – Fortran Program","text":"Contents Modules chapter_7 Source Code chapter_7.f90 Source Code module chapter_7 !! All of the programming exercises for Chapter 7: Procedures use iso_fortran_env implicit none contains subroutine p7_1 () !! ** DISCUSSION QUESTION ** <br> !! What is the difference between a subroutine and a function? print * , \"A subroutine can modify arguments that are passed to it, but it will never have\" print * , \"a return value. Functions in Fortran, just like their mathematical definition,\" print * , \"necessarily have a return value. A subroutine and function is similar with\" print * , \"respect to the fact that they both are a tool to repeat and reuse code.\" end subroutine subroutine p7_2 () !! ** DISCUSSION QUESTION ** <br> !! When a subroutine is called, how is data passed from the calling program to the subroutine, !! and how are the results of the subroutine returned to the calling program? print * , \"Parameters are passed around inside subroutines as references, that is to say\" print * , \"that there is not a block of memory that is copied to the subroutine, instead\" print * , \"the argument is passed with a pointer to the block of memory that stores the value.\" end subroutine subroutine p7_3 () !! ** DISCUSSION QUESTION ** <br> !! What are the advantages and disadvantages of the pass-by-reference scheme used in Fortran? print * , \"Advantages: \" print * , \" - Don't have to copy large amounts of data (which can be slow)\" print * , \"Disadvantages: \" print * , \" - Data address might be far away from the caller, leading to slow load times\" print * , \" - Modifiying the data in the subroutine can affect the original parameter\" end subroutine subroutine p7_4 () !! ** DISCUSSION QUESTION ** <br> !! What are the advantages and disadvantages of each procedure array type? print * , \"Explicit shaped dummy arrays:\" print * , \" - Compiler knows exactly the shape and size of an argument, and\" print * , \"can therefore check for out-of-bounds errors during compilation\" print * , \" - We have to pass the size of the array when calling the procedure\" print * print * , \"Assumed-shape dummy arrays:\" print * , \" - Allow the compiler to check SOME indexing errors, and avoids having\" print * , \"to pass a size parameter\" print * , \" - can be used in full-matrix statements (e.g. A + B)\" print * print * , \"Assumed-size dummy arrays:\" print * , \" - Should NEVER be used because the compiler can't check for errors.\" end subroutine subroutine p7_5 () !! ** DISCUSSION QUESTION **<br> !! Suppose a 15-element array is passed to a subroutine. What happens if the subroutine attempts !! to write to element a(16)? print * , \"If the array is explicit-shaped, then there will be an error at compile time.\" print * , \"If the array is assumed-shape, then there will be an error at run time.\" print * , \"An assumed-size error will allow the unsafe access to be performed.\" end subroutine subroutine p7_6 () !! **DISCUSSION QUESTION** <br> !! If a real value is passed to a subroutine in an argument that is declared to be an integer, !! what happens? print * , \"Sometimes the compiler will give a warning, but still allow the real to be passed\" print * , \"In this case, however, my gfortran compiler produced an error so I can't even pass\" print * , \"a real value into a subroutine expecting an integer.\" ! integer, intent(in) :: i ! write(*,*) \" I = \", i end subroutine subroutine p7_7 () !! ** DISCUSSION QUESTION** <br> !! How can p7_6 be modified so that the compiler catches the argument mismatch between !! the actual argument and the dummy argument in the subroutine? print * , \"We can ensure that an int will be passed to the subroutine by wrapping\" print * , \"the parameter with the INT(x) function upon calling\" end subroutine subroutine p7_8 () !! **DISCUSSION QUESTION** <br> !! What is the purpose of the INTENT attribute? Where can it be used? Why should it be used? print * , \"The INTENT attribute signals to the compiler whether or not the variables are\" print * , \"read, write, or read write. This attribute is specified where the variables are\" print * , \"being declared in a procedure. They should be used so that you don't\" print * , \"accidentally alter a variable that you didn't want/expect to.\" end subroutine subroutine p7_9 () !! **NOT APPLICABLE** end subroutine subroutine p7_10 () !! **NOT APPLICABLE** end subroutine end module chapter_7","tags":"","loc":"sourcefile/chapter_7.f90.html"},{"title":"chapter_6.f90 – Fortran Program","text":"Contents Modules chapter_6 Source Code chapter_6.f90 Source Code module chapter_6 !! Arrays use iso_fortran_env implicit none contains subroutine p6_1 () !! ** DISCUSSION QUESTION ** !! How may arrays be declared? integer , dimension ( 1 : 10 ) :: my_array integer , dimension ( - 10 : - 1 ) :: my_neg_array double precision , dimension ( 10 ) :: my_product my_array = 3 my_neg_array = - 2 my_product = real ( my_array ) ** real ( my_neg_array ) print * , my_product end subroutine subroutine p6_3 () !! ** DISCUSSION QUESTION ** !! Execute this subroutine on your computer with both bounds checking turned on and !! bounds checking turned off. What happens? real , dimension ( 5 ) :: test = [ 1. , 2. , 3. , 4. , 5. ] real , dimension ( 5 ) :: test1 integer :: i do i = 1 , 5 test1 ( i ) = sqrt ( test ( i )) write ( * , 100 ) 'SQRT(' , test ( i ), ') = ' , test1 ( i ) 100 format ( A , F6 . 3 , A , F14 . 4 ) end do end subroutine subroutine p6_4 () !! ** DISCUSSION QUESTION ** !! Determine the shape and size of the arrays specified by the following statements: ! (a) ! character(len=80), dimension(60) :: line ! An array that is 1 dimensionsal, has 60 entries, and each entry is a charactar of length 80. ! (b) ! integer, parameter :: ISTART = 32 ! INTEGER, PARAMETER :: ISTOP = 256 ! INTEGER, DIMENSION(ISTART:ISTOP) :: char ! char is an array of size (256-32 + 1) = 225 ! (c) ! INTEGER, PARAMETER :: NUM_CLASS = 3 ! INTEGER, PARAMETER :: NUM_STUDENT = 35 ! LOGICAL, DIMENSION(NUM_STUDENT, NUM_CLASS) :: passfail ! passfail is an array of size 33. end subroutine subroutine p6_5 () !! ** DISCUSSION QUESTION ** !! Determine which of the following Fortran program fragments are valid. For each valid statement, !! specify what will happen in the program. (Assume default typing for any variables that are not !! explicitly typed within the program fragments.) ! (a) ! INTEGER, DIMENSION(100) :: icount, jcount !. . . ! icount = [ (i, i=1, 100)] ! implied do loop ! jcount = icount + 1 ! (a) has valid syntax, this will create two arrays, icount which is a size 100 array that ! contains the sequence of natural numbers from 1 to 100, and jcount contains the sequence of ! natural numbers from 2 to 101. ! print *, icount ! print *, jcount ! (b) ! REAL, DIMENSION(10) :: value ! value(1:10:2) = [5., 4., 3., 2., 1. ] ! value(2:11:2) = [10., 9., 8., 7., 6. ] ! write (*, 100) value ! 100 format ('Value = ',/,(F10.2)) ! (c) ! INTEGER, DIMENSION(6) :: a ! INTEGER, DIMENSION(6) :: b ! a = [1, -3, 0, -5, -9, 3] ! b = [-6, 6, 0, 5, 2, -1] ! WRITE (*, *) a > b ! All the fragments are valid! print * , \"All code fragments are valid\" end subroutine subroutine p6_6 () !! ** DISCUSSION QUESTION ** !! What is meant by each of the following array terms? Size, shape, extent, rank, conformable. integer , parameter :: DEFINITION_LENGTH = 65 character ( DEFINITION_LENGTH ) :: sizeDef , shapeDef , extentDef , rankDef , conformableDef sizeDef = \"Number of elements of A\" shapeDef = \"Return the dimensions of A\" extentDef = \"The number of elements in a single dimension\" rankDef = \"The number of dimensions\" conformableDef = \"Two arrays that have the same shape and extent are conformable\" print 100 , sizeDef , shapeDef , extentDef , rankDef , conformableDef 100 Format ( \"size: \" , T30 , A , / , \"shape: \" , T30 , A , / , \"extent: \" , T30 , A , / , \"rank: \" , T30 , A , / , \"conformable: \" , T30 , A ) end subroutine subroutine p6_7 () !! ** DISCUSSION QUESTION ** !! Given an array my_array defined as shown, determine whether each of the following !! array sections is valid REAL , DIMENSION ( - 2 : 7 ) :: my_array = [ - 3 , - 2 , - 1 , 0 , 1 , 2 , 3 , 4 , 5 , 6 ] INTEGER , DIMENSION ( 5 ) :: list = [ - 2 , 1 , 2 , 4 , 2 ] ! (a) ! print *, my_array(-3, 3) ! (b) print * , my_array ( - 2 : 2 ) ! (c) print * , my_array ( 1 : 5 : 2 ) ! (d) print * , my_array ( list ) end subroutine subroutine p6_8 () !! ** DISCUSSION QUESTION ** !! What will the output from each of the WRITE statements in the following subroutine be? !! Why is the output of the two statements different? INTEGER , DIMENSION ( 0 : 7 ) :: my_data INTEGER :: i , j my_data = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 ] DO i = 0 , 1 WRITE ( * , 100 ) ( my_data ( 4 * i + j ), j = 0 , 3 ) ! Will write two lists of 4 items 100 FORMAT ( 6 ( 1 X , I4 )) END DO WRITE ( * , 100 ) (( my_data ( 4 * i + j ), j = 0 , 3 ), i = 0 , 1 ) ! Will write one line with 6 items and a second line with 2 itmes end subroutine subroutine p6_10 () !! Polar to Rectangular Conversion !! Write a program that reads the polar coordinates of a 2D vector into a rank !! 1 array POLAR. polar(1) will contain the mgnitude and polar(2) will contain the !! angle theta in degrees, and converts the vector from !! polar to rectangular form, storing the result in a rank1 array RECT. !! Rect(1) should be the x component and rect(2) will be the y component. real ( real64 ), parameter :: PI = 3.141592653589793 real ( real64 ), dimension ( 2 ) :: polar , rect real ( real64 ) :: rads integer :: ierr character ( 100 ) :: errmsg print * , \"Please enter the magnitude and angle (degrees) of a point in polar coordinates\" read ( * , * , iostat = ierr , iomsg = errmsg ) polar ( 1 ), polar ( 2 ) if ( ierr == 0 ) then ! No error occurred rads = ( polar ( 2 ) / 180 ) * ( PI ) print * , polar ( 2 ), \" in rads is: \" , rads rect ( 1 ) = polar ( 1 ) * cos ( rads ) rect ( 2 ) = polar ( 1 ) * sin ( rads ) end if print * , \"The polar coordinates \" , polar , \" in rectangular form are:\" print * , rect end subroutine subroutine p6_11 () !! Rectangular to Polar Conversion !! Write a program that reads the rectangular components of a 2D vector into a rank 1 !! array rect. real ( real64 ), parameter :: PI = 3.141592653589793 real ( real64 ), dimension ( 2 ) :: polar , rect real ( real64 ) :: rads , mag integer :: ierr character ( 100 ) :: errmsg print * , \"Please enter the x and y components of a point in rectangular coordinates\" read ( * , * , iostat = ierr , iomsg = errmsg ) rect ( 1 ), rect ( 2 ) if ( ierr == 0 ) then ! No error occurred rads = atan2 ( rect ( 2 ), rect ( 1 )) polar ( 2 ) = rads * ( 180 ) / PI mag = sqrt (( rect ( 1 ) ** 2 + rect ( 2 ) ** 2 )) print * , rads , \" in degrees is \" , polar ( 2 ) polar ( 1 ) = mag end if print * , \"The rect coordinates \" , rect , \" in polar form are:\" print * , polar end subroutine end module","tags":"","loc":"sourcefile/chapter_6.f90.html"},{"title":"chapter_5.f90 – Fortran Program","text":"Contents Modules chapter_5 Source Code chapter_5.f90 Source Code module chapter_5 !! All of the programming exercises for Chapter 5: Basic IO use iso_fortran_env contains subroutine p5_1 () !! ** DISCUSSION QUESTION ** !! What is the purpose of a format? What are the three ways to define a format? print * , \"The purpose of a format is to have complete control of the output/input of a program.\" print * , \"We can, for example, style the output into a table using formats. \" print * , \"We can define a format three different ways.\" print 99 , 1 , \"Using a raw format string in the call: \" print 111 , \"write(*, '(F5.3, A)') my_float, my_character\" print 99 , 2 , \"Using a label combined with a format call:\" print 111 , \"100 FORMAT(F5.3, A) ... write(*,100) my_float, my_character\" print 99 , 3 , \"Storing the format with a variable:\" print 111 , \"FMT = '(F5.3,A)' ... write(*, FMT) my_float, my_character\" 111 format ( T15 , a ) 99 format ( I0 , \"). \" , a ) end subroutine subroutine p5_2 () !! ** DISCUSSION QUESTION ** !! What is printed out by the following Fortran statements? print * , \"(a)\" print * , \"integer :: i\" print * , \"character(len=20) :: fmt\" print * , \"fmt = '('i = ', I8.5)'\" print * , \"i = -123\" print * , \"write(*,fmt) i\" print * , \"write(*, '(I0)') i\" ! (b) ! real :: a, b, sum, difference ! a = 1.0020E6 ! b = 1.0001E6 ! sum = a + b ! difference = a - b ! write (*, 101) a, b, sum, difference ! 101 FORMAT('A = ', ES14.6, ' B = ', E14.6, & ! ' Sum = ', E14.6, ' Diff = ', F14.6) ! (c) ! integer :: i1, i2 ! i1 = 10 ! i2 = 4**2 ! write (*, 300) i1 > i2 ! 300 FORMAT ('Result = ', L6) end subroutine subroutine p5_3 () !! ** DISCUSSION QUESTION ** !! What is printed out by the following Fortran statements? real :: a = 1.602E-19 , b = 5 7.2957795 , c = - 1 print * , \"File:\" print * , \"----\" print * , \"real :: a = 1.602E-19, b = 57.2957795, c = -1\" print * , \"write (*, '(ES14.7, 2(1X, E13.7))') a, b, c\" print * print * , \"Output:\" print * , \"-------\" write ( * , '(ES14.7, 2(1X, E13.7))' ) a , b , c end subroutine subroutine p5_4 ( file_name ) !! ** DISCUSSION QUESTION ** !! Read in 5_4.dat and find out what the output will be for the following statements: character ( * ), intent ( in ) :: file_name Character ( 5 ) :: a Character ( 10 ) :: b character ( 15 ) :: c character ( 100 ) :: errmsg integer :: ierr open ( unit = 10 , file = file_name , iostat = ierr , iomsg = errmsg , status = \"old\" ) if ( ierr /= 0 ) then print * , \"ERR: \" , errmsg else READ ( unit = 10 , fmt = '(3A10)' ) a , b , c close ( unit = 10 ) print * , \"a: \" , a , \" b: \" , b , \" c: \" , c end if end subroutine subroutine p5_5 ( file_name ) !! ** DISCUSSION QUESTION ** !! Read in 5_5.dat and find out what the value of each variable will be when the !! READ statements have been completed character ( * ), intent ( in ) :: file_name integer :: item1 , item2 , item3 , item4 , item5 integer :: item6 , item7 , item8 , item9 , item10 integer :: ierr character ( 100 ) :: errmsg open ( unit = 10 , file = file_name , status = 'old' , action = 'read' , iostat = ierr , iomsg = errmsg ) if ( ierr /= 0 ) then print * , \"ERR: \" , errmsg else ! (a) read ( 10 , * ) item1 , item2 , item3 , item4 , item5 , item6 read ( 10 , * ) item7 , item8 , item9 , item10 ! (b) ! read (10, 8) item1, item2, item3, item4, item5, item6 ! read (10, 8) item7, item8, item9, item10 ! 8 FORMAT(4I10) print * , item1 , item2 , item3 , item4 , item5 , item6 , item7 , item8 , item9 , item10 close ( unit = 10 ) end if end subroutine subroutine p5_6 () !! Generate a table of the base 10 logarithms between 1 and 10 in steps of 0.1 integer :: ipower , jpower , i real , dimension ( 10 , 0 : 9 ) :: result ones_place : do ipower = 1 , 10 tenths_place : do jpower = 0 , 9 result ( ipower , jpower ) = log10 ( ipower + 0.1 * jpower ) end do tenths_place end do ones_place write ( * , 200 ) ( i , i = 0 , 9 ) write ( * , 300 ) write ( * , 100 ) ( i , result ( i ,:), i = 1 , 10 ) 100 format ( I3 , \".0  | \" , 10 F7 . 4 ) 200 format ( 7 ( \" \" ), \"|\" , 10 ( 4 X , \"X.\" , I0 )) 300 format ( 80 ( \"-\" )) end subroutine end module chapter_5","tags":"","loc":"sourcefile/chapter_5.f90.html"},{"title":"math_trig.f90 – Fortran Program","text":"Contents Submodules trig Source Code math_trig.f90 Source Code submodule ( foreng_math ) trig implicit none contains module procedure sind_r32 sind = sin ( deg_to_rad ( theta )) end procedure module procedure sind_r64 sind = sin ( deg_to_rad ( theta )) end procedure module procedure cosd_r32 cosd = cos ( deg_to_rad ( theta )) end procedure module procedure cosd_r64 cosd = cos ( deg_to_rad ( theta )) end procedure module procedure tand_r32 tand = tan ( deg_to_rad ( theta )) end procedure module procedure tand_r64 tand = tan ( deg_to_rad ( theta )) end procedure module procedure asind_r32 asind = asin ( deg_to_rad ( theta )) end procedure module procedure asind_r64 asind = asin ( deg_to_rad ( theta )) end procedure module procedure acosd_r32 acosd = acos ( deg_to_rad ( theta )) end procedure module procedure acosd_r64 acosd = acos ( deg_to_rad ( theta )) end procedure module procedure atand_r32 atand = atan ( deg_to_rad ( theta )) end procedure module procedure atand_r64 atand = atan ( deg_to_rad ( theta )) end procedure module procedure sinhd_r32 sinhd = sinh ( deg_to_rad ( theta )) end procedure module procedure sinhd_r64 sinhd = sinh ( deg_to_rad ( theta )) end procedure module procedure coshd_r32 coshd = cosh ( deg_to_rad ( theta )) end procedure module procedure coshd_r64 coshd = cosh ( deg_to_rad ( theta )) end procedure module procedure tanhd_r32 tanhd = tanh ( deg_to_rad ( theta )) end procedure module procedure tanhd_r64 tanhd = tanh ( deg_to_rad ( theta )) end procedure module procedure deg_to_rad_r32 radians = degrees / 180_real32 * PI_32 end procedure module procedure deg_to_rad_r64 radians = degrees / 180_real64 * PI end procedure module procedure rad_to_deg_r32 degrees = radians / PI_32 * 180_real32 end procedure module procedure rad_to_deg_r64 degrees = radians / PI * 180_real64 end procedure end submodule","tags":"","loc":"sourcefile/math_trig.f90.html"},{"title":"hyper_test.f90 – Fortran Program","text":"Contents Programs test_hyper Source Code hyper_test.f90 Source Code program test_hyper implicit none real :: x = 4 print * , \"sinh(x) = \" , sinh ( x ) end program test_hyper","tags":"","loc":"sourcefile/hyper_test.f90.html"},{"title":"matrices.f90 – Fortran Program","text":"Contents Modules foreng_matrices Source Code matrices.f90 Source Code module foreng_matrices !! Top level module for specific matrix operations (elimination, matrix generation, systems of equations) end module","tags":"","loc":"sourcefile/matrices.f90.html"},{"title":"math.f90 – Fortran Program","text":"Contents Modules foreng_math Source Code math.f90 Source Code module foreng_math !! Top level module containing math functions (sets, factorials, trig) use foreng implicit none ! private :: EPS_32, EPS_64 ! real(real32) :: EPS_32 = 1E-7 ! real(real64) :: EPS_64 = 1E-14 !=============================================================================! !=                         Trigonometry Interface                            =! !=============================================================================! interface sind module procedure sind_r32 module procedure sind_r64 end interface interface cosd module procedure cosd_r32 module procedure cosd_r64 end interface interface tand module procedure tand_r32 module procedure tand_r64 end interface interface asind module procedure asind_r32 module procedure asind_r64 end interface interface acosd module procedure acosd_r32 module procedure acosd_r64 end interface interface atand module procedure atand_r32 module procedure atand_r64 end interface interface sinhd module procedure sinhd_r32 module procedure sinhd_r64 end interface interface coshd module procedure coshd_r32 module procedure coshd_r64 end interface interface tanhd module procedure tanhd_r32 module procedure tanhd_r64 end interface interface deg_to_rad module procedure deg_to_rad_r32 module procedure deg_to_rad_r64 end interface interface rad_to_deg module procedure rad_to_deg_r32 module procedure rad_to_deg_r64 end interface !=============================================================================! !=                               Set Interface                               =! !=============================================================================! interface intersection module procedure intersection_int module procedure intersection_r32 module procedure intersection_r64 end interface interface union module procedure union_int module procedure union_r32 module procedure union_r64 end interface interface belongs_to module procedure belongs_to_int module procedure belongs_to_r32 module procedure belongs_to_r64 end interface interface array_epsilon module procedure array_epsilon_r32 module procedure array_epsilon_r64 end interface interface abs_max_val module procedure abs_max_val_r32 module procedure abs_max_val_r64 end interface !=============================================================================! !=                         Trigonometry Functions                            =! !=============================================================================! interface module elemental real ( real32 ) function sind_r32 ( theta ) result ( sind ) real ( real32 ), intent ( in ) :: theta end function module elemental real ( real64 ) function sind_r64 ( theta ) result ( sind ) real ( real64 ), intent ( in ) :: theta end function module elemental real ( real32 ) function cosd_r32 ( theta ) result ( cosd ) real ( real32 ), intent ( in ) :: theta end function module elemental real ( real64 ) function cosd_r64 ( theta ) result ( cosd ) real ( real64 ), intent ( in ) :: theta end function module elemental real ( real32 ) function tand_r32 ( theta ) result ( tand ) real ( real32 ), intent ( in ) :: theta end function module elemental real ( real64 ) function tand_r64 ( theta ) result ( tand ) real ( real64 ), intent ( in ) :: theta end function module elemental real ( real32 ) function asind_r32 ( theta ) result ( asind ) real ( real32 ), intent ( in ) :: theta end function module elemental real ( real64 ) function asind_r64 ( theta ) result ( asind ) real ( real64 ), intent ( in ) :: theta end function module elemental real ( real32 ) function acosd_r32 ( theta ) result ( acosd ) real ( real32 ), intent ( in ) :: theta end function module elemental real ( real64 ) function acosd_r64 ( theta ) result ( acosd ) real ( real64 ), intent ( in ) :: theta end function module elemental real ( real32 ) function atand_r32 ( theta ) result ( atand ) real ( real32 ), intent ( in ) :: theta end function module elemental real ( real64 ) function atand_r64 ( theta ) result ( atand ) real ( real64 ), intent ( in ) :: theta end function module elemental real ( real32 ) function sinhd_r32 ( theta ) result ( sinhd ) real ( real32 ), intent ( in ) :: theta end function module elemental real ( real64 ) function sinhd_r64 ( theta ) result ( sinhd ) real ( real64 ), intent ( in ) :: theta end function module elemental real ( real32 ) function coshd_r32 ( theta ) result ( coshd ) real ( real32 ), intent ( in ) :: theta end function module elemental real ( real64 ) function coshd_r64 ( theta ) result ( coshd ) real ( real64 ), intent ( in ) :: theta end function module elemental real ( real32 ) function tanhd_r32 ( theta ) result ( tanhd ) real ( real32 ), intent ( in ) :: theta end function module elemental real ( real64 ) function tanhd_r64 ( theta ) result ( tanhd ) real ( real64 ), intent ( in ) :: theta end function module elemental real ( real32 ) function deg_to_rad_r32 ( degrees ) result ( radians ) real ( real32 ), intent ( in ) :: degrees end function module elemental real ( real64 ) function deg_to_rad_r64 ( degrees ) result ( radians ) real ( real64 ), intent ( in ) :: degrees end function module elemental real ( real32 ) function rad_to_deg_r32 ( radians ) result ( degrees ) real ( real32 ), intent ( in ) :: radians end function module elemental real ( real64 ) function rad_to_deg_r64 ( radians ) result ( degrees ) real ( real64 ), intent ( in ) :: radians end function end interface !=============================================================================! !=                               Set Functions                               =! !=============================================================================! interface module function intersection_int ( setA , setB ) result ( inters ) integer , dimension (:), intent ( in ) :: setA , setB integer , dimension (:), allocatable :: inters end function module function intersection_r32 ( setA , setB ) result ( inters ) real ( real32 ), dimension (:), intent ( in ) :: setA , setB real ( real32 ), dimension (:), allocatable :: inters end function module function intersection_r64 ( setA , setB ) result ( inters ) real ( real64 ), dimension (:), intent ( in ) :: setA , setB real ( real64 ), dimension (:), allocatable :: inters end function module function union_int ( setA , setB ) result ( union_set ) integer , intent ( in ), dimension (:) :: setA , setB integer , dimension (:), allocatable :: union_set end function module function union_r32 ( setA , setB ) result ( union_set ) real ( real32 ), intent ( in ), dimension (:) :: setA , setB real ( real32 ), dimension (:), allocatable :: union_set end function module function union_r64 ( setA , setB ) result ( union_set ) real ( real64 ), intent ( in ), dimension (:) :: setA , setB real ( real64 ), dimension (:), allocatable :: union_set end function module logical function belongs_to_int ( x , A ) result ( bool ) integer , intent ( in ) :: x integer , dimension (:) :: A end function module logical function belongs_to_r32 ( x , A , eps ) result ( bool ) real ( real32 ), intent ( in ) :: x real ( real32 ), dimension (:) :: A real ( real32 ), optional :: eps end function module logical function belongs_to_r64 ( x , A , eps ) result ( bool ) real ( real64 ), intent ( in ) :: x real ( real64 ), dimension (:) :: A real ( real64 ), optional :: eps end function module real ( real32 ) function array_epsilon_r32 ( array ) result ( eps ) real ( real32 ), dimension (:), intent ( in ) :: array end function module real ( real64 ) function array_epsilon_r64 ( array ) result ( eps ) real ( real64 ), dimension (:), intent ( in ) :: array end function module real ( real32 ) function abs_max_val_r32 ( array ) result ( abs_max_val ) real ( real32 ), dimension (:), intent ( in ) :: array end function module real ( real64 ) function abs_max_val_r64 ( array ) result ( abs_max_val ) real ( real64 ), dimension (:), intent ( in ) :: array end function end interface end module","tags":"","loc":"sourcefile/math.f90.html"},{"title":"trig_test.f90 – Fortran Program","text":"Contents Programs trig_test Source Code trig_test.f90 Source Code program trig_test use foreng_math implicit none real ( real64 ) :: thetad = 90 real ( real64 ) :: theta real ( real64 ), dimension ( 3 ) :: max_vals = [ - 1 0.d0 , 0 d0 , 5 d0 ] theta = deg_to_rad ( thetad ) print * , \"theta = \" , theta print * , \"thetad = \" , thetad print * , \"sin(theta) = \" , sin ( theta ) print * , \"sind(thetad) = \" , sind ( thetad ) print * , \"sinh(theta) = \" , sinh ( theta ) print * , \"sinhd(theta) = \" , sinhd ( thetad ) print * , \"MAXVAL(max_vals) = \" , maxval ( max_vals ) end program","tags":"","loc":"sourcefile/trig_test.f90.html"},{"title":"foreng.f90 – Fortran Program","text":"Contents Modules foreng Source Code foreng.f90 Source Code module foreng !! Top level module for all of the useful functions written for Fortran for Scientists and Engineers use iso_fortran_env , only : real64 , real32 , int64 , int32 , int16 implicit none ! public :: sgl, dbl, short, long, pi, pi_s !     integer, parameter :: SGL = real32 !     integer, parameter :: DBL = real64 !     integer, parameter :: SHORT = int16 !     integer, parameter :: LONG = int64 real ( real64 ), parameter :: PI_64 = 3.141592653589793 real ( real64 ), parameter :: PI = PI_64 real ( real32 ), parameter :: PI_32 = 3.14159265 !=============================================================================! !=                      List of incorporated modules                         =! !=============================================================================! ! Math !   _trig !   _sets end module","tags":"","loc":"sourcefile/foreng.f90.html"},{"title":"math_sets.f90 – Fortran Program","text":"Contents Submodules sets Source Code math_sets.f90 Source Code submodule ( foreng_math ) sets implicit none contains module procedure intersection_int integer :: setA_card integer :: i integer :: zero = 0 setA_card = size ( setA ) do i = 1 , setA_card if ( belongs_to ( setA ( i ), setB )) then !! If element of set1 is ALSO in set2... if ( allocated ( inters )) then inters = [ inters , setA ( i )] else allocate ( inters ( 1 )) inters = setA ( i ) end if else cycle end if end do if (. not . allocated ( inters )) then !! If the intersection is the empty set allocate ( inters ( 1 )) inters = zero / zero end if end procedure module procedure intersection_r32 integer :: setA_card integer :: i real ( real32 ) :: zero = 0 real ( real32 ) :: eps eps = array_epsilon ([ setA , setB ]) setA_card = size ( setA ) do i = 1 , setA_card if ( belongs_to ( setA ( i ), setB , eps )) then !! If element of set1 is ALSO in set2... print * , \"MATCH!!\" if ( allocated ( inters )) then inters = [ inters , setA ( i )] else allocate ( inters ( 1 )) inters = setA ( i ) end if else cycle end if end do if (. not . allocated ( inters )) then !! If the intersection is the empty set allocate ( inters ( 1 )) inters = zero / zero end if end procedure module procedure intersection_r64 integer :: setA_card integer :: i real ( real64 ) :: zero = 0 real ( real64 ) :: eps eps = array_epsilon ([ setA , setB ]) setA_card = size ( setA ) do i = 1 , setA_card if ( belongs_to ( setA ( i ), setB , eps )) then !! If element of set1 is ALSO in set2... if ( allocated ( inters )) then inters = [ inters , setA ( i )] else allocate ( inters ( 1 )) inters = setA ( i ) end if else cycle end if end do if (. not . allocated ( inters )) then !! If the intersection is the empty set allocate ( inters ( 1 )) inters = zero / zero end if end procedure module procedure union_int integer :: setB_cardinality integer :: i setB_cardinality = size ( setB ) !! Set union right away to setA union_set = setA do i = 1 , setB_cardinality if ( belongs_to ( setB ( i ), union_set )) then !! If set2(i) is already a part of the union, then don't add it cycle else union_set = [ union_set , setB ( i )] end if end do end procedure module procedure union_r32 integer :: setB_cardinality integer :: i setB_cardinality = size ( setB ) !! Set union right away to setA union_set = setA do i = 1 , setB_cardinality if ( belongs_to ( setB ( i ), union_set )) then !! If set2(i) is already a part of the union, then don't add it print * , \"MATCH FOUND!!\" cycle else union_set = [ union_set , setB ( i )] end if end do end procedure module procedure union_r64 integer :: setB_cardinality integer :: i setB_cardinality = size ( setB ) !! Set union right away to setA union_set = setA do i = 1 , setB_cardinality if ( belongs_to ( setB ( i ), union_set )) then !! If set2(i) is already a part of the union, then don't add it cycle else union_set = [ union_set , setB ( i )] end if end do end procedure module procedure belongs_to_int !! Check if an element belongs to a set integer :: cardinality !! Cardinality (size) of the set to check integer :: i cardinality = size ( A ) do i = 1 , cardinality bool = . false . if ( A ( i ) == x ) then bool = . true . return else cycle end if end do end procedure module procedure belongs_to_r32 !! Check if an element belongs to a set integer :: cardinality !! Cardinality (size) of the set to check integer :: i real ( real32 ) :: eps_ if (. not . present ( eps )) then eps_ = array_epsilon ( A ) else eps_ = eps end if cardinality = size ([ A , x ]) do i = 1 , cardinality bool = . false . if ( abs ( A ( i ) - x ) <= eps_ ) then bool = . true . return else cycle end if end do end procedure module procedure belongs_to_r64 !! Check if an element belongs to a set integer :: cardinality !! Cardinality (size) of the set to check integer :: i if (. not . present ( eps )) then eps = array_epsilon ([ A , x ]) end if cardinality = size ( A ) do i = 1 , cardinality bool = . false . if ( abs ( A ( i ) - x ) < eps ) then bool = . true . return else cycle end if end do end procedure module procedure array_epsilon_r32 real ( real32 ) :: max_val max_val = abs_max_val ( array ) eps = epsilon ( max_val ) end procedure module procedure array_epsilon_r64 real ( real64 ) :: max_val max_val = abs_max_val ( array ) eps = epsilon ( max_val ) end procedure module procedure abs_max_val_r32 abs_max_val = maxval ( abs ( array )) end procedure module procedure abs_max_val_r64 abs_max_val = maxval ( abs ( array )) end procedure end submodule","tags":"","loc":"sourcefile/math_sets.f90.html"},{"title":"sets_test.f90 – Fortran Program","text":"Contents Programs sets_test Source Code sets_test.f90 Source Code program sets_test use foreng_math implicit none ! integer, dimension(10) :: setA = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] ! integer, dimension(10) :: setB = [1, -10, 3, 5, -13, 6, -2, 8, 13, 10] real ( real32 ), dimension ( 10 ) :: setA = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] real ( real32 ), dimension ( 10 ) :: setB = [ 1 , - 10 , 3 , 5 , - 13 , 6 , - 2 , 8 , 13 , 10 ] ! real(real64), dimension(10) :: setA = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] ! real(real64), dimension(10) :: setB = [1, -10, 3, 5, -13, 6, -2, 8, 13, 10] ! integer, dimension(:), allocatable :: uni_int, inters_int real ( real32 ), dimension (:), allocatable :: uni , inters ! real(real64), dimension(:), allocatable :: uni, inters uni = union ( setA , setB ) inters = intersection ( setA , setB ) print * , \"For:\" print * , \"setA: \" , setA print * , \"setB: \" , setB print * , \"============================\" print * , \"union:        \" , uni print * , \"intersection: \" , inters end program","tags":"","loc":"sourcefile/sets_test.f90.html"},{"title":"demo.f90 – Fortran Program","text":"Contents Programs demo Source Code demo.f90 Source Code program demo use chapter_4 use chapter_5 use chapter_6 use chapter_7 integer :: i = 0 , j = 0 , ierr character ( 100 ) :: errmsg real :: p7_6_real = 1.0 print * ! empty line print 123 print 121 , \"| Fortran for Engineers demo suite - Evan Voyles |\" print 123 121 format ( T16 , a ) 123 format ( T16 , 50 ( \"-\" )) mainloop : do call chapter_select () print * , \"[4] Chapter 4: Loops & Character Manipulation\" print * , \"[5] Chapter 5: Basic IO\" print * , \"[6] Chapter 6: Arrays\" print * , \"[7] Chapter 7: Procedures\" print * , \"[8] Chapter 8: Additional Features of Arrays\" print * , \"[9] Chapter 9: Additional Features of Procedures\" print * , \"[10] Chapter 10: Character Variables\" print * print * , \"0 to exit\" read ( unit = 5 , fmt =* , iostat = ierr , iomsg = errmsg ) i if ( ierr /= 0 ) then print * , \"please enter a valid integer from [0:10]\" cycle mainloop end if select case ( i ) case ( 4 ) call chapter_selected ( i ) chapter4 : do print * , \"Problem 1: Legal expressions\" print * , \"Problem 2: Squares of even integers\" print * , \"Problem 3: Function evaluation\" print * , \"Problem 4: Piecewise function evaluation\" print * , \"Problem 5: Factorial\" print * , \"Problem 6: Difference between CYCLE and EXIT\" print * , \"Problem 7: Simple statistics\" print * , \"Problem 8: Loop execution counts\" print * , \"Problem 9: Loop execution values\" print * , \"Problem 10: Loop execution values (pt II)\" print * , \"Problem 11: Flight of ball\" print * , \"Problem 12: Flight of ball (pt II)\" print * , \"Problem 13: Day of the year\" print * , \"Problem 14: Logarithmic function evaluation\" print * , \"Problem 15: Uppercase to lowercase\" print * , \"Problem 16: Calculating orbits\" print * , \"Problem 17: Capitalize first letter\" print * , \"Problem 18: Current through a diode\" print * , \"Problem 19: Binary to decimal\" call problem_select () read ( unit = 5 , fmt =* , iostat = ierr , iomsg = errmsg ) j if ( ierr /= 0 ) then print * , \"please enter a valid integer from [-1:19]\" cycle chapter4 end if call program_start () select case ( j ) case ( 1 ) call p4_1 () case ( 2 ) print * , \"Problem 2 selected\" case ( 3 ) call p4_3 () case ( 4 ) call p4_4 () case ( 5 ) call p4_5 () case ( 6 ) call p4_6 () case ( 7 ) call p4_7 () case ( 8 ) call p4_8 () case ( 9 ) call p4_9 () case ( 10 ) call p4_10 () case ( 11 ) call p4_11 () case ( 12 ) call p4_12 () case ( 13 ) call p4_13 () case ( 14 ) call p4_14 () case ( 15 ) call p4_15 () case ( 16 ) call p4_16 () case ( 17 ) call p4_17 () case ( 18 ) call p4_18 () case ( 19 ) call p4_19 () case ( - 1 ) print * , \"Going to chapter select\" exit chapter4 case ( 0 ) print * , \"Exiting demo\" exit mainloop case default print * , \"Please enter a valid number 1-19, -1 to go back, or 0 to exit\" end select call program_end () end do chapter4 case ( 5 ) call chapter_selected ( i ) chapter5 : do print * , \"Problem 1: What is the purpose of a format?\" print * , \"Problem 2: What is printed?\" print * , \"Problem 3: What is printed? (pt II)\" print * , \"Problem 4: For 5_4.dat, what is read in?\" print * , \"Problem 5: For 5_5.dat, what is read in?\" print * , \"Problem 6: Table of logarithms\" ! print *, \"Problem 7: Simple statistics\" ! print *, \"Problem 8: Loop execution counts\" ! print *, \"Problem 9: Loop execution values\" ! print *, \"Problem 10: Loop execution values (pt II)\" ! print *, \"Problem 11: Flight of ball\" ! print *, \"Problem 12: Flight of ball (pt II)\" ! print *, \"Problem 13: Day of the year\" ! print *, \"Problem 14: Logarithmic function evaluation\" ! print *, \"Problem 15: Uppercase to lowercase\" ! print *, \"Problem 16: Calculating orbits\" ! print *, \"Problem 17: Capitalize first letter\" ! print *, \"Problem 18: Current through a diode\" ! print *, \"Problem 19: Binary to decimal\" call problem_select () read ( unit = 5 , fmt =* , iostat = ierr , iomsg = errmsg ) j if ( ierr /= 0 ) then print * , \"please enter a valid integer from [-1:19]\" cycle chapter5 end if call program_start () select case ( j ) case ( 1 ) call p5_1 () case ( 2 ) call p5_2 () case ( 3 ) call p5_3 () case ( 4 ) call p5_4 ( \"5_4.dat\" ) case ( 5 ) call p5_5 ( \"5_5.dat\" ) case ( 6 ) call p5_6 () ! case(7) !     call p4_7() ! case(8) !     call p4_8() ! case(9) !     call p4_9() ! case(10) !     call p4_10() ! case(11) !     call p4_11() ! case(12) !     call p4_12() ! case(13) !     call p4_13() ! case(14) !     call p4_14() ! case(15) !     call p4_15() ! case(16) !     call p4_16() ! case(17) !     call p4_17() ! case(18) !     call p4_18() ! case(19) !     call p4_19() case ( - 1 ) print * , \"Going to chapter select\" exit chapter5 case ( 0 ) print * , \"Exiting demo\" exit mainloop case default print * , \"Please enter a valid number 1-6, -1 to go back, or 0 to exit\" end select call program_end () end do chapter5 case ( 6 ) call chapter_selected ( i ) chapter6 : do print * , \"Problem 6: Array Terminology\" print * , \"Problem 10: Polar to Rectangular Conversion\" print * , \"Problem 11: Rectangular to Polar Conversion\" ! print *, \"Problem 12: Flight of ball (pt II)\" ! print *, \"Problem 13: Day of the year\" ! print *, \"Problem 14: Logarithmic function evaluation\" ! print *, \"Problem 15: Uppercase to lowercase\" ! print *, \"Problem 16: Calculating orbits\" ! print *, \"Problem 17: Capitalize first letter\" ! print *, \"Problem 18: Current through a diode\" ! print *, \"Problem 19: Binary to decimal\" call problem_select () read ( unit = 5 , fmt =* , iostat = ierr , iomsg = errmsg ) j if ( ierr /= 0 ) then print * , \"please enter a valid integer from [-1:19]\" cycle chapter6 end if call program_start () select case ( j ) ! case(1) !     call p4_1() ! case(2) !     print *, \"Problem 2 selected\" ! case(3) !     call p4_3() ! case(4) !     call p4_4() ! case(5) !     call p4_5() case ( 6 ) call p6_6 () ! case(7) !     call p4_7() ! case(8) !     call p4_8() ! case(9) !     call p4_9() case ( 10 ) call p6_10 () case ( 11 ) call p6_11 () ! case(12) !     call p4_12() ! case(13) !     call p4_13() ! case(14) !     call p4_14() ! case(15) !     call p4_15() ! case(16) !     call p4_16() ! case(17) !     call p4_17() ! case(18) !     call p4_18() ! case(19) !     call p4_19() case ( - 1 ) print * , \"Going to chapter select\" exit chapter6 case ( 0 ) print * , \"Exiting demo\" exit mainloop case default print * , \"Please enter a valid number 6, 10, or 11, -1 to go back, or 0 to exit\" end select call program_end () end do chapter6 ! // TODO ADD ALL OTHER CHAPTERS case ( 7 ) call chapter_selected ( i ) chapter7 : do print * , \"Problem 1: Difference between subroutine and function\" print * , \"Problem 2: How is data passed in Fortran procedures?\" print * , \"Problem 3: Advantages and disadvantages of pass-by-reference?\" print * , \"Problem 4: How can arrays be declared as dummy variables?\" print * , \"Problem 5: Array error-bound subscripting\" print * , \"Problem 6: Pass REAL value to INTEGER subroutine\" print * , \"Problem 7: Check mismateched arguments in Problem 6\" print * , \"Problem 8: Loop execution counts\" print * , \"Problem 9: Loop execution values\" print * , \"Problem 10: Loop execution values (pt II)\" print * , \"Problem 11: Flight of ball\" print * , \"Problem 12: Flight of ball (pt II)\" print * , \"Problem 13: Day of the year\" print * , \"Problem 14: Logarithmic function evaluation\" print * , \"Problem 15: Uppercase to lowercase\" print * , \"Problem 16: Calculating orbits\" print * , \"Problem 17: Capitalize first letter\" print * , \"Problem 18: Current through a diode\" print * , \"Problem 19: Binary to decimal\" print * , \"Problem 20: Loop execution counts\" print * , \"Problem 21: Loop execution values\" print * , \"Problem 22: Loop execution values (pt II)\" print * , \"Problem 23: Flight of ball\" print * , \"Problem 24: Flight of ball (pt II)\" print * , \"Problem 25: Day of the year\" print * , \"Problem 26: Logarithmic function evaluation\" print * , \"Problem 27: Uppercase to lowercase\" call problem_select () read ( unit = 5 , fmt =* , iostat = ierr , iomsg = errmsg ) j if ( ierr /= 0 ) then print * , \"please enter a valid integer from [-1:19]\" cycle chapter7 end if call program_start () select case ( j ) case ( 1 ) call p7_1 () case ( 2 ) call p7_2 () case ( 3 ) call p7_3 () case ( 4 ) call p7_4 () case ( 5 ) call p7_5 () case ( 6 ) call p7_6 () case ( 7 ) call p7_7 () case ( 8 ) call p4_8 () case ( 9 ) call p4_9 () case ( 10 ) call p4_10 () case ( 11 ) call p4_11 () case ( 12 ) call p4_12 () case ( 13 ) call p4_13 () case ( 14 ) call p4_14 () case ( 15 ) call p4_15 () case ( 16 ) call p4_16 () case ( 17 ) call p4_17 () case ( 18 ) call p4_18 () case ( 19 ) call p4_19 () case ( - 1 ) print * , \"Going to chapter select\" exit chapter7 case ( 0 ) print * , \"Exiting demo\" exit mainloop case default print * , \"Please enter a valid number 1-19, -1 to go back, or 0 to exit\" end select call program_end () end do chapter7 case ( 8 ) print * , \"Chapter 8 selected\" case ( 9 ) print * , \"Chapter 9 selected\" case ( 10 ) print * , \"Chapter 10 selected\" case ( 11 ) print * , \"Chapter 11 selected\" case ( 12 ) print * , \"Chapter 12 selected\" case ( 13 ) print * , \"Chapter 13 selected\" case ( 14 ) print * , \"Chapter 14 selected\" case ( 15 ) print * , \"Chapter 15 selected\" case ( 16 ) print * , \"Chapter 16 selected\" case ( 17 ) print * , \"Chapter 17 selected\" case ( 0 ) print * , \"Exiting succesfully\" exit mainloop case default print * , \"Please enter a number 1-17\" end select ! print*, \"Example 1: Demo for xy plot\" ! print*, \"Example 2: Line specification\" ! print*, \"Example 3: Plot several data series at the same time\" ! print*, \"Example 4: Plot four data series at the same time\" ! print*, \"Example 5: Use line style, line colors and more...\" ! print*, \"Example 6: An interesting plot, sin(x) and its zero on the same plot\" ! print*, \"Example 7: Plot a matrix against a vector\" ! print*, \"Example 8: Plot a matrix against a vector and set the linespec and legend\" ! print*, \"Example 9: Use gnuplot for animation\" ! print*, \"Example 10: Use ogpf options\" ! print*, \"Example 11: simple polar plot\" ! print*, \"Example 12: A plot with logarithmic x axis\" ! print*, \"Example 13: A matrix plot with logarithmic y axis\" ! print*, \"Example 14: A loglog plot\" ! print*, \"Example 15: Plotting a function\" ! print*, \"Example 16: Save the gnuplot script into a file for future use\" ! print*, \"Example 17: Multi window plots, using script\" ! print*, \"Example 18: Running an external script file\" ! print*, \"Example 19: Multiple linestyle in matrix plot\" ! print*, \"Example 20: Scatter plot\" ! print*, \"Example 21: Stem plot\" ! print*, \"Example 22: Stem plot animation\" ! print*, \"Example 23: Another animation using matrix plot\" ! print*, \"Example 24: Multiplot layout\" ! print*, \"Example 25: Multiplot layout followed by simple plot\" ! print*, \"Example 26: Plot matrix vs. matrix\" ! print*, \"Example 27: Using secondary y axis\" ! print*, \"Example 28: Using secondary x and y axis\" ! print*, \"Example 29: Using color and size for title and labels\" ! print*, \"Example 30: More on labels color and size with secondary axes\" ! print* ! print*, \"***   Surface and Contour Plots ***\" ! print* ! print*, \"Example 101: Simple 3D plot using surf\" ! print*, \"Example 102: Surface plot and color palette \" ! print*, \"Example 103: Surface plot with hidden details and its contour\" ! print*, \"Example 104: Cylindrical mapping\" ! print*, \"Example 105: More contour plot\" ! print*, \"Example 106: Animation of 3D plots\" ! print*, \"Example 106: Multiplot layout in 3D\" ! print*, \"Example 107: Multiplot layout for 3D data\" ! print*, \"Example 108: Plot a 2D grid\" ! print* ! write (unit=*, fmt='(a)') \"2D plots: select an example: 1 through 30\" ! write (unit=*, fmt='(a)') \"3D plots: select an example: 101 through 108\" ! write (unit=*, fmt='(a)', advance='no') \"enter 0 for exit:  \" ! read*, i ! select case(i) !     case(1) !         call exmp01 !     case(2) !         call exmp02 !     case(3) !         call exmp03 !     case(4) !         call exmp04 !     case(5) !         call exmp05 !     case(6) !         call exmp06 !     case(7) !         call exmp07 !     case(8) !         call exmp08 !     case(9) !         call exmp09 !     case(10) !         call exmp10 !     case(11) !         call exmp11 !     case(12) !         call exmp12 !     case(13) !         call exmp13 !     case(14) !         call exmp14 !     case(15) !         call exmp15 !     case(16) !         call exmp16 !     case(17) !         call exmp17 !     case(18) !         call exmp18 !     case(19) !         call exmp19 !     case(20) !         call exmp20 !     case(21) !         call exmp21 !     case(22) !         call exmp22 !     case(23) !         call exmp23 !     case(24) !         call exmp24 !     case(25) !         call exmp25 !     case(26) !         call exmp26 !     case(27) !         call exmp27 !     case(28) !         call exmp28 !     case(29) !         call exmp29 !    case(30) !         call exmp30 !         ! 3D plots !     case(101) !         call exmp101 !     case(102) !         call exmp102 !     case(103) !         call exmp103 !     case(104) !         call exmp104 !     case(105) !         call exmp105 !     case(106) !         call exmp106 !     case(107) !         call exmp107 !    case(108) !         call exmp108 !     case (0) !         print*, \"Program terminated successfully\" !         exit mainloop !     case default !         print*, \"Try again, use a valid example number\" !         print*, \"Enter 0 to exit\" ! end select ! print* ! print*, \"press any key to continue...\" ! read* end do mainloop contains subroutine chapter_select () 999 format ( 80 ( \"*\" )) 111 format ( \"*\" , T34 , a , T80 , \"*\" ) print * print 999 print 111 , \"Select chapter\" print 999 print * end subroutine subroutine chapter_selected ( chp ) integer , intent ( in ) :: chp 999 format ( 80 ( \"*\" )) 111 format ( \"*\" , T34 , a , I0 , a , T80 , \"*\" ) print * print 999 print 111 , \"Chapter \" , chp , \" selected\" print 999 print * end subroutine subroutine problem_select () 999 format ( 80 ( \"*\" )) 111 format ( \"*\" , T34 , a , T80 , \"*\" ) print * print 999 print 111 , \"Select problem\" print 999 print * print * , \"  0 to exit, -1 to go back\" end subroutine subroutine program_start () 999 format ( 80 ( \"*\" )) 111 format ( \"*\" , T34 , a , T80 , \"*\" ) print * print 999 print 111 , \"Program start\" print 999 print * end subroutine subroutine program_end () 999 format ( 80 ( \"*\" )) 111 format ( \"*\" , T34 , a , T80 , \"*\" ) print * print 999 print 111 , \"Program ended\" print 999 print * call to_continue () end subroutine subroutine to_continue () print * , \"Press return to continue....\" read * end subroutine end program","tags":"","loc":"sourcefile/demo.f90.html"},{"title":"trig.f90 – Fortran Program","text":"Contents Modules trig Source Code trig.f90 Source Code module trig real ( 8 ), parameter :: PI_D = 3.141592653589793 real , parameter :: PI = 3.14159265 integer , parameter :: SGL = selected_int_kind ( 7 ) integer , parameter :: DBL = selected_int_kind ( 15 ) !//TODO add interface for all trig degree functions !//TODO add support for hyperbolic degree functions interface deg_to_rad module procedure deg_to_rad_sgl module procedure deg_to_rad_dbl module procedure deg_to_rad_int end interface interface rad_to_deg module procedure rad_to_deg_sgl module procedure rad_to_deg_dbl module procedure rad_to_deg_int end interface interface !! Trig degrees module elemental real function sind ( theta ) real , intent ( in ) :: theta end function module elemental real function cosd ( theta ) real , intent ( in ) :: theta end function module elemental real function tand ( theta ) real , intent ( in ) :: theta end function module elemental real function asind ( theta ) real , intent ( in ) :: theta end function module elemental real function acosd ( theta ) real , intent ( in ) :: theta end function module elemental real function atand ( theta ) real , intent ( in ) :: theta end function end interface contains !! Trig conversion elemental real ( SGL ) function deg_to_rad_sgl ( degrees ) result ( rad ) real ( SGL ), intent ( in ) :: degrees rad = degrees / 18 0.0 * PI end function elemental real ( DBL ) function deg_to_rad_dbl ( degrees ) result ( rad ) real ( DBL ), intent ( in ) :: degrees rad = degrees / 18 0.0 * PI_D end function elemental real ( SGL ) function deg_to_rad_int ( degrees ) result ( rad ) integer , intent ( in ) :: degrees rad = degrees / 18 0.0 * PI end function elemental real ( SGL ) function rad_to_deg_sgl ( rad ) result ( degrees ) real ( SGL ), intent ( in ) :: rad degrees = rad / PI * 18 0.0 end function elemental real ( DBL ) function rad_to_deg_dbl ( rad ) result ( degrees ) real ( DBL ), intent ( in ) :: rad degrees = rad / PI_D * 18 0.0 end function elemental real ( SGL ) function rad_to_deg_int ( rad ) result ( degrees ) integer , intent ( in ) :: rad degrees = rad / PI * 18 0.0 end function end module","tags":"","loc":"sourcefile/trig.f90.html"},{"title":"prototype.f90 – Fortran Program","text":"Contents Modules prototype Source Code prototype.f90 Source Code !------------------------------------------------------------------------------ ! MODULE prototype ! !       A collection of submodules that contain functions and !       problems worthy of collection and organization into !       a library ! !------------------------------------------------------------------------------ module prototype ! This module contains all of the functions that I find necessary/want ! to highlight on my github page implicit none public :: least_squares_fit , solve_n !------------------------------------------------------------------------------ ! SUBMODULE least_squares ! !       A series of subroutines and functions that are used to solve a system !       of linear equations to find the least-squares fits of two dimensional !       data points, using polynomials. ! !------------------------------------------------------------------------------ interface !-------------------------------------------------------------------------- ! SUBROUTINE least_squares_fit ! !       Solve a least_squares problem and give the coefficients of !       a polynomial of order ORDER. module subroutine least_squares_fit ( X , Y , order , c ) ! Data dictionary real ( 8 ), dimension (:), intent ( in ) :: X , Y ! The x and y coordinates to be fit integer , intent ( in ) :: order ! The order of the polynomial to fit real ( 8 ), dimension (:), allocatable , intent ( out ) :: c ! The right hand side of Ac = u end subroutine !-------------------------------------------------------------------------- ! SUBROUTINE generate_sys_eqns ! !       Generate a sys of equations to solve a polynomial least squares !       problem of order n. ! module subroutine generate_sys_eqns ( X , Y , order , A , u ) ! Data dictionary real ( 8 ), dimension (:), intent ( in ) :: X , Y ! The x and y coordinates to be fit integer , intent ( in ) :: order ! The order of the polynomial to fit real ( 8 ), dimension (:,:), allocatable , intent ( out ) :: A ! The system of equations we will solve real ( 8 ), dimension (:), allocatable , intent ( out ) :: u ! The right hand side of Ac = u end subroutine !-------------------------------------------------------------------------- ! SUBROUTINE solve_n ! !       Solve a system of n equations by gaussian elimination !       of the form Ax = y. !-------------------------------------------------------------------------- module subroutine solve_n ( A , x , y ) ! Purpose !   To solve the system of equations Ax = y, where A is a nxn matrix ! Data dictionary real ( 8 ), dimension (:,:), allocatable , intent ( in ) :: A ! The linear transformation real ( 8 ), dimension (:), intent ( out ) :: x ! The vector that A acts upon real ( 8 ), dimension (:), intent ( inout ) :: y ! The right hand side of Ax = y end subroutine !-------------------------------------------------------------------------- ! SUBROUTINE switch_rows(A, row1, row2) ! !       Switch rows row1 and row2 for m x n matrix A ! !-------------------------------------------------------------------------- module subroutine switch_rows ( A , row1 , row2 ) real ( 8 ), dimension (:,:), intent ( inout ) :: A integer , intent ( in ) :: row1 , row2 end subroutine !-------------------------------------------------------------------------- ! SUBROUTINE back_sub(U, x, y) ! !       When given an Upper triangular matrix whose diagonals !       are unit undergoe the backwards substitution step of !       Gauss's method. ! !-------------------------------------------------------------------------- module subroutine back_sub ( U , x , y ) ! Data dictionary real ( 8 ), dimension (:,:), intent ( in ) :: U ! The upper Triangular matrix real ( 8 ), dimension (:), intent ( inout ) :: x , y ! Ux = y end subroutine !-------------------------------------------------------------------------- ! SUBROUTINE elim_col(A, icol) ! !       Perform Gaussian row elimination for a specified !       column. Reduces each pivot to unit and stops !       if the matrix is singular. ! !-------------------------------------------------------------------------- module subroutine elim_col ( A , icol ) ! Purpose !   To reduce the pivots of a given column.  The row pivot to divide by is assumed to be the same as the column number ! Data dictionary real ( 8 ), dimension (:,:), intent ( inout ) :: A ! The matrix whose column we want to eliminate integer , intent ( in ) :: icol ! The column to eliminate end subroutine !-------------------------------------------------------------------------- ! ELEMENTAL LOGICAL FUNCTION is_zero(X) ! !       Perform Gaussian row elimination for a specified !       column. Reduces each pivot to unit and stops !       if the matrix is singular. ! !-------------------------------------------------------------------------- module elemental logical function is_zero ( X ) real ( 8 ), intent ( in ) :: X end function !-------------------------------------------------------------------------- ! SUBROUTINE add_noise(Y, noise, Y_noise, min, max) ! !       Add a uniform distribution of random noise in the range !       [min, max) to the vector Y. ! !-------------------------------------------------------------------------- module subroutine add_noise ( Y , noise , Y_noise , min , max ) real ( 8 ), dimension (:), intent ( in ) :: Y real ( 8 ), dimension (:), intent ( inout ) :: noise , Y_noise real ( 4 ), intent ( in ) :: min , max end subroutine end interface !------------------------------------------------------------------------------ ! GENERIC SUBROUTINE print_mat2(X) ! !       Print out a rank 2 matrix with the first dimension !       represented as rows and the second as columns ! !------------------------------------------------------------------------------ interface print_mat2 module subroutine print_mati ( A ) integer , dimension (:,:), intent ( in ) :: A end subroutine module subroutine print_matr ( A ) real , dimension (:,:), intent ( in ) :: A end subroutine module subroutine print_matd ( A ) real ( 8 ), dimension (:,:), intent ( in ) :: A end subroutine module subroutine print_matc ( A ) complex , dimension (:,:), intent ( in ) :: A end subroutine end interface contains !-------------------------------------------------------------------------- ! REAL FUNCTION urand(min,max) ! !       Return a real value between [min, max) !       Uniform distribution ! !-------------------------------------------------------------------------- real function urand ( min , max ) real , intent ( in ) :: min , max real :: temp_rand ! A value between 0 and 1 real , parameter :: rand_mid = 0.5 real :: scale ! What we should multiply the range by real :: shift ! What we should shift the dist by ! mid_point = (min + max) / 2 shift = min scale = max - min call random_number ( temp_rand ) ! print *, temp_rand ! Shift the midpoint to the midpoint of the new range urand = temp_rand * scale + shift end function end module prototype","tags":"","loc":"sourcefile/prototype.f90.html"},{"title":"compass_trig.f90 – Fortran Program","text":"Contents Submodules compass Source Code compass_trig.f90 Source Code submodule ( coordinates ) compass use trig contains end submodule","tags":"","loc":"sourcefile/compass_trig.f90.html"},{"title":"my_matmul.f90 – Fortran Program","text":"Contents Modules my_matmul_mod Source Code my_matmul.f90 Source Code module my_matmul_mod Contains subroutine my_matmul ( A , B , C , dimA , dimB , dimC , ierr ) ! Purpose: !   To multiply two matrices, A and B. implicit none ! Data dictionary integer , dimension ( 2 ), intent ( in ) :: dimA , dimB , dimC integer , intent ( inout ) :: ierr real , dimension ( dimA ( 1 ), dimA ( 2 )), intent ( in ) :: A real , dimension ( dimB ( 1 ), dimB ( 2 )), intent ( in ) :: B real , dimension ( dimC ( 1 ), dimC ( 2 )), intent ( out ) :: C integer :: i , j , k real :: sum ! Error flags dictionary ! 0        Successful matrix multiplication ! 1        Matrices A and B are incompatible ! 2        Matrix C is not large enough to contain the result ! 3        Matrix C is not the appropriate size ! See if A and B are compatible if ( dimA ( 2 ) == dimB ( 1 )) then print * , \"A and B are compatible for matrix multiplication\" if ( size ( C ) >= dimA ( 1 ) * dimB ( 2 )) then print * , \"C is large enough to hold the matrix product\" if ( dimC ( 1 ) == dimA ( 1 ) . and . dimC ( 2 ) == dimB ( 2 )) then print * , \"C is the proper shape to hold the matrix product\" ierr = 0 ! Let's actually compute the matrix now ! The common value is the colA and rowB. This is the number of operations per element in C print * , \"Computing the matrix multiplication\" do i = 1 , dimC ( 1 ) do j = 1 , dimC ( 2 ) sum = 0 do k = 1 , dimA ( 2 ) ! First column of C is 1st col of B times first row of A ! Second column of C is the 2nd col of B times the first row of A sum = sum + ( B ( k , j ) * A ( i , k )) print 100 , k , j , i , k 100 format ( \"B(\" , I0 , \",\" , I0 , \") * A(\" , I0 , \",\" , I0 , \")\" ) 111 format ( 20 ( \"*\" )) end do print 111 C ( i , j ) = sum end do end do else print * , \"C is not the proper shape to hold the matrix product\" ierr = 3 end if else print * , \"C is not large enough to hold the matrix product\" print * , \"The size of C is: \" , size ( C ) print * , \"The shape of C is: \" , shape ( C ) ierr = 2 end if else ierr = 1 print * , \"Matrices are not compatible\" end if ! print *, \"The shape of C inside the subroutine is: \", shape(C) end subroutine end module","tags":"","loc":"sourcefile/my_matmul.f90.html"},{"title":"ejovo_types@point.f90 – Fortran Program","text":"Contents Submodules point Source Code ejovo_types@point.f90 Source Code submodule ( ejovo_types ) point contains module procedure distance_between_points real :: delta_x , delta_y delta_x = p2 % x - p1 % x delta_y = p2 % y - p1 % y dist = sqrt ( delta_x ** 2 + delta_y ** 2 ) end procedure module procedure find_line real :: delta_x , delta_y if ( p1 % x == p2 % x . and . p1 % y == p2 % y ) then l % m = 0 l % b = 0 else delta_x = p2 % x - p1 % x delta_y = p2 % y - p1 % y l % m = delta_y / delta_x l % b = p1 % y - ( l % m * p1 % x ) end if end procedure end submodule","tags":"","loc":"sourcefile/ejovo_types@point.f90.html"},{"title":"lib_test.f90 – Fortran Program","text":"Contents Programs lib_test Source Code lib_test.f90 Source Code program lib_test use prototype implicit none real ( 8 ), dimension (:,:), allocatable :: A real ( 8 ), dimension (:), allocatable :: u real ( 8 ), dimension ( 5 ) :: c real ( 8 ), dimension ( 6 ) :: x , y x = [ - 2.0 , - 1.0 , 0.0 , 1.0 , 2.0 , 3.0 ] y = [ 1 6.0 , 1. , 0.0 , 1.0 , 1 6.0 , 8 1.0 ] call generate_sys_eqns ( x , y , 4 , A , u ) call solve_n ( A , c , u ) ! Test the fitting of a polynomial of order 4 end program","tags":"","loc":"sourcefile/lib_test.f90.html"},{"title":"ejovo_types@polar.f90 – Fortran Program","text":"Contents Submodules polar Source Code ejovo_types@polar.f90 Source Code submodule ( ejovo_types ) polar contains module procedure comp2pol real :: magnitude , theta , x , y x = realpart ( c ) y = imagpart ( c ) magnitude = sqrt ( realpart ( c ) ** 2 + imagpart ( c ) ** 2 ) theta = atan2 ( y , x ) theta = theta * ( 18 0.0 / PI ) pol % r = magnitude pol % theta = theta end procedure module procedure pol2comp real :: theta_rads , x , y theta_rads = ( pol % theta / 180 ) * PI x = pol % r * cos ( theta_rads ) y = pol % r * sin ( theta_rads ) c = complex ( x , y ) end procedure module procedure mult p3 % r = p1 % r * p2 % r p3 % theta = p1 % theta + p2 % theta if ( p3 % theta > 18 0.0 ) then p3 % theta = p3 % theta - 36 0.0 else if ( p3 % theta < - 18 0.0 ) then p3 % theta = p3 % theta + 360 end if end procedure module procedure div p3 % r = p1 % r / p2 % r p3 % theta = p1 % theta - p2 % theta if ( p3 % theta > 18 0.0 ) then p3 % theta = p3 % theta - 36 0.0 else if ( p3 % theta < - 18 0.0 ) then p3 % theta = p3 % theta + 360 end if end procedure end submodule","tags":"","loc":"sourcefile/ejovo_types@polar.f90.html"},{"title":"points_t.f90 – Fortran Program","text":"Contents Programs test_drive Modules points_t Source Code points_t.f90 Source Code ! A module that defines the polar type, which is a coordinate represented in ! polar coordinates. module points_t type , abstract :: point integer :: kind = 8 end type type , extends ( point ) :: polar real :: r real :: th contains ! generic :: operator(+) => add_pol procedure :: to_cart => pol_to_cart ! procedure :: add_pol => pol_plus_cart, pol_plus_pol end type type , extends ( point ) :: cart real :: x real :: y contains ! generic :: operator(+) => add procedure :: to_pol => cart_to_pol ! procedure :: add => cart_plus_cart, cart_plus_pol end type interface ! module type(polar) function pol_plus_pol(p1, p2) !     class(polar), intent(in) :: p1, p2 ! end function ! module type(polar) function pol_plus_cart(p1, c1) !     class(polar), intent(in) :: p1 !     class(cart), intent(in) :: c1 ! end function ! module type(cart) function cart_plus_cart(c1, c2) !     class(cart), intent(in) :: c1, c2 ! end function ! module type(cart) function cart_plus_pol(c1, p1) !     class(cart), intent(in) :: c1 !     class(polar), intent(in) :: p1 ! end function module type ( cart ) function pol_to_cart ( p1 ) result ( c1 ) class ( polar ), intent ( in ) :: p1 end function module type ( polar ) function cart_to_pol ( c1 ) result ( p1 ) class ( cart ), intent ( in ) :: c1 end function end interface end module program test_drive use points_t type ( polar ) :: my_p type ( cart ) :: my_c my_p = polar ( kind = 8 , r = 3 , th = 10 ) print * , my_p my_c = my_p % to_cart () print * , my_c end program","tags":"","loc":"sourcefile/points_t.f90.html"},{"title":"my_matmul_mod_parent.f90 – Fortran Program","text":"Contents Modules my_matmul_mod_parent Source Code my_matmul_mod_parent.f90 Source Code module my_matmul_mod_parent interface module subroutine my_matmul ( A , B , C , ierr ) ! Purpose: !   To multiply two matrices, A and B. implicit none ! Data dictionary integer , intent ( inout ) :: ierr real , dimension (:,:), intent ( in ) :: A , B real , dimension (:,:), intent ( out ) :: C end subroutine end interface end module","tags":"","loc":"sourcefile/my_matmul_mod_parent.f90.html"},{"title":"prototype@print_functions.f90 – Fortran Program","text":"Contents Submodules print_functions Source Code prototype@print_functions.f90 Source Code submodule ( prototype ) print_functions contains module procedure print_mati integer , dimension ( 2 ) :: shape_A integer :: nrows , i shape_A = shape ( A ) nrows = shape_A ( 1 ) do i = 1 , nrows print * , A ( i ,:) end do end procedure module procedure print_matr integer , dimension ( 2 ) :: shape_A integer :: nrows , i shape_A = shape ( A ) nrows = shape_A ( 1 ) do i = 1 , nrows print * , A ( i ,:) end do end procedure module procedure print_matd integer , dimension ( 2 ) :: shape_A integer :: nrows , i shape_A = shape ( A ) nrows = shape_A ( 1 ) do i = 1 , nrows print * , A ( i ,:) end do end procedure module procedure print_matc integer , dimension ( 2 ) :: shape_A integer :: nrows , i shape_A = shape ( A ) nrows = shape_A ( 1 ) do i = 1 , nrows print * , A ( i ,:) end do end procedure end submodule","tags":"","loc":"sourcefile/prototype@print_functions.f90.html"},{"title":"ejovo_types@line.f90 – Fortran Program","text":"Contents Submodules line Source Code ejovo_types@line.f90 Source Code submodule ( ejovo_types ) line contains module procedure print print 99 , line1 % m , line1 % b 99 format ( \"y = \" , F10 . 3 , \"x + \" , F10 . 3 ) end procedure end submodule","tags":"","loc":"sourcefile/ejovo_types@line.f90.html"},{"title":"rand001.f90 – Fortran Program","text":"Contents Modules ran001 Source Code rand001.f90 Source Code MODULE ran001 ! ! Purpose: ! !  To declare data shared between subs random0 and seed. ! ! Record of revisions: ! !  Date        Programmer       Description of change !  ====        ==========       ===================== !  11/23/15    S. J. Chapman    Original code ! IMPLICIT NONE SAVE INTEGER :: n = 9876 CONTAINS !***************************************************************** !***************************************************************** SUBROUTINE random0 ( ran ) ! ! Purpose: ! !  Subroutine to generate a pseudorandom number with a uniform ! !  distribution in the range 0. <= ran < 1.0. ! ! Record of revisions: ! !  Date      Programmer      Description of change !  ====      ==========      ===================== ! 11/23/15   S. J. Chapman  Original code ! ! Shared seed IMPLICIT NONE ! Data dictionary: declare calling parameter types & definitions REAL , INTENT ( OUT ) :: ran ! Random number ! Calculate next number n = MOD ( 8121 * n + 28411 , 134456 ) ! Generate random value from this number ran = REAL ( n ) / 13445 6. END SUBROUTINE random0 !****************************************************** !****************************************************** SUBROUTINE seed ( iseed ) ! ! Purpose: ! !  To set the seed for random number generator random0. ! ! Record of revisions: !  Date     Programmer     Description of change !  ====     ==========     ===================== ! 11/23/15  S. J. Chapman  Original code ! ! Shared seed IMPLICIT NONE ! Data dictionary: declare calling parameter types & definitions INTEGER , INTENT ( IN ) :: iseed ! Value to initialize sequence ! Set seed n = ABS ( iseed ) END SUBROUTINE seed END MODULE ran001","tags":"","loc":"sourcefile/rand001.f90.html"},{"title":"radar.f90 – Fortran Program","text":"Contents Modules radar Source Code radar.f90 Source Code module radar use trig real , parameter :: ALPHA = 0.7 real , parameter :: BETA = 0.38 type :: vector real :: x real :: y contains generic :: operator ( + ) => vector_addition generic :: operator ( - ) => vector_substraction generic :: operator ( * ) => vector_times_scalar generic :: operator ( / ) => vector_divided_scalar procedure :: vector_addition procedure :: vector_substraction procedure :: vector_times_scalar procedure :: vector_divided_scalar end type type :: detection real :: range real :: azimuth ! The azimuth in compass degrees real :: time ! The time of detection type ( vector ) :: cart = vector ( 0.0 , 0.0 ) contains procedure :: to_cart procedure :: time_diff procedure :: pos_diff procedure :: compute_velocity end type interface detection procedure :: new_detection end interface interface operator ( * ) procedure :: scalar_times_vector end interface contains type ( detection ) function new_detection ( range , azimuth , time ) real , intent ( in ) :: range , azimuth , time new_detection % range = range new_detection % azimuth = azimuth new_detection % time = time new_detection % cart = new_detection % to_cart () print * , \"new_detection called\" end function elemental type ( vector ) function to_cart ( detect ) result ( cart ) class ( detection ), intent ( in ) :: detect real :: theta theta = compass_to_theta ( detect % azimuth ) cart % x = detect % range * cosd ( theta ) cart % y = detect % range * sind ( theta ) end function elemental real function compass_to_theta ( azimuth ) result ( theta ) ! Convert compass angle to standard unit circle angle real , intent ( in ) :: azimuth theta = azimuth * ( - 1 ) + 90 if ( theta < 0 ) then theta = theta + 36 0.0 else if ( theta >= 36 0.0 ) then theta = theat - 36 0.0 end if end function elemental real function time_diff ( det1 , det2 ) class ( detection ), intent ( in ) :: det1 , det2 time_diff = det2 % time - det1 % time end function elemental type ( vector ) function pos_diff ( det1 , det2 ) class ( detection ), intent ( in ) :: det1 , det2 pos_diff = det1 % cart - det2 % cart end function elemental type ( vector ) function compute_velocity ( det_t0 , det_tf ) class ( detection ), intent ( in ) :: det_t0 , det_tf real :: delta_time type ( vector ) :: delta_pos delta_time = det_t0 % time_diff ( det_tf ) delta_pos = det_t0 % pos_diff ( det_tf ) compute_velocity = delta_pos / delta_time end function elemental type ( vector ) function vector_addition ( v1 , v2 ) result ( v3 ) class ( vector ), intent ( in ) :: v1 , v2 v3 % x = v1 % x + v2 % x v3 % y = v1 % y + v2 % y end function elemental type ( vector ) function vector_substraction ( v1 , v2 ) result ( v3 ) class ( vector ), intent ( in ) :: v1 , v2 v3 % x = v1 % x - v2 % x v3 % y = v1 % y - v2 % y end function elemental type ( vector ) function scalar_times_vector ( scalar , vec ) result ( v2 ) real , intent ( in ) :: scalar class ( vector ), intent ( in ) :: vec v2 % x = vec % x * scalar v2 % y = vec % y * scalar end function elemental type ( vector ) function vector_times_scalar ( vec , scalar ) result ( v2 ) class ( vector ), intent ( in ) :: vec real , intent ( in ) :: scalar v2 % x = vec % x * scalar v2 % y = vec % y * scalar end function elemental type ( vector ) function vector_divided_scalar ( vec , scalar ) result ( v2 ) class ( vector ), intent ( in ) :: vec real , intent ( in ) :: scalar v2 % x = vec % x / scalar v2 % y = vec % y / scalar end function elemental type ( vector ) function predict_position ( smooth_pos , prev_velocity , delta_time ) type ( vector ), intent ( in ) :: smooth_pos , prev_velocity real , intent ( in ) :: delta_time predict_position = smooth_pos + ( prev_velocity * delta_time ) end function elemental type ( vector ) function update_velocity ( prev_velocity , measured_pos , predicted_position , delta_time ) type ( vector ), intent ( in ) :: prev_velocity , measured_pos , predicted_position real , intent ( in ) :: delta_time update_velocity = prev_velocity + ( BETA / delta_time ) * ( measured_pos - predicted_position ) end function elemental type ( vector ) function update_position ( predicted_position , measured_position ) type ( vector ), intent ( in ) :: predicted_position , measured_position update_position = predicted_position + ALPHA * ( measured_position - predicted_position ) end function end module","tags":"","loc":"sourcefile/radar.f90.html"},{"title":"points_t@polar.f90 – Fortran Program","text":"Contents Submodules polar cart Source Code points_t@polar.f90 Source Code ! This module implements the polar functions submodule ( points_t ) polar contains ! module procedure pol_plus_pol ! end procedure module procedure pol_to_cart c1 % x = p1 % r c1 % y = p1 % th end procedure end submodule submodule ( points_t ) cart contains ! module procedure pol_plus_pol ! end procedure module procedure cart_to_pol p1 % r = c1 % x p1 % th = c1 % y end procedure end submodule","tags":"","loc":"sourcefile/points_t@polar.f90.html"},{"title":"ejovo.f90 – Fortran Program","text":"Contents Modules ejovo Source Code ejovo.f90 Source Code ! This module contains some test functions to explore chapter 7 - procedures module ejovo save contains subroutine return_10 () end subroutine subroutine three_args ( x , y , error ) integer , intent ( in ) :: x , y integer , intent ( out ) :: error if ( x > y ) then error = 1 print * , \"Not supposed to happen, exiting program\" stop \"underflow\" else error = 0 print * , \"All is well\" end if end subroutine end module ejovo","tags":"","loc":"sourcefile/ejovo.f90.html"},{"title":"test_radar.f90 – Fortran Program","text":"Contents Programs radar_test Source Code test_radar.f90 Source Code ! This program tests the radar module functionality program radar_test use radar implicit none type ( detection ) :: det1 , det2 type ( vector ) :: my_velocity det1 = new_detection ( range = 1 0.0 , azimuth = 4 5.0 , time = 1 0.0 ) det2 = new_detection ( range = 1 5.0 , azimuth = 9 0.0 , time = 1 5.0 ) my_velocity = det1 % compute_velocity ( det2 ) print * , det1 print * , det2 print * , \"The change in pos between det1 and det2 is: \" , det1 % pos_diff ( det2 ) print * , \"Velocity is :\" , my_velocity print * , \"The difference in detection between 1 and 2 is: \" , det1 % time_diff ( det2 ) end program","tags":"","loc":"sourcefile/test_radar.f90.html"},{"title":"my_matmul_explicit.f90 – Fortran Program","text":"Contents Modules my_matmul_mod_explicit Source Code my_matmul_explicit.f90 Source Code module my_matmul_mod_explicit ! interface !     module subroutine my_matmul(A, B, C, ierr) !         implicit none !         integer, intent(inout) :: ierr !         real, dimension(:,:), intent(in) :: A, B !         real, dimension(:,:), intent(out) :: C !     end subroutine ! end interface contains module subroutine my_matmul ( A , B , C , ierr ) ! Purpose: !   To multiply two matrices, A and B. implicit none ! Data dictionary integer , dimension ( 2 ) :: dimA , dimB , dimC integer , intent ( inout ) :: ierr real , dimension (:,:), intent ( in ) :: A , B real , dimension (:,:), intent ( out ) :: C integer :: i , j , k real :: sum dimA = shape ( A ) dimB = shape ( B ) dimC = shape ( C ) ! Error flags dictionary ! 0        Successful matrix multiplication ! 1        Matrices A and B are incompatible ! 2        Matrix C is not large enough to contain the result ! 3        Matrix C is not the appropriate size ! See if A and B are compatible if ( dimA ( 2 ) == dimB ( 1 )) then print * , \"A and B are compatible for matrix multiplication\" if ( size ( C ) >= dimA ( 1 ) * dimB ( 2 )) then print * , \"C is large enough to hold the matrix product\" if ( dimC ( 1 ) == dimA ( 1 ) . and . dimC ( 2 ) == dimB ( 2 )) then print * , \"C is the proper shape to hold the matrix product\" ierr = 0 ! Let's actually compute the matrix now ! The common value is the colA and rowB. This is the number of operations per element in C print * , \"Computing the matrix multiplication\" do i = 1 , dimC ( 1 ) do j = 1 , dimC ( 2 ) sum = 0 do k = 1 , dimA ( 2 ) ! First column of C is 1st col of B times first row of A ! Second column of C is the 2nd col of B times the first row of A sum = sum + ( B ( k , j ) * A ( i , k )) print 100 , k , j , i , k 100 format ( \"B(\" , I0 , \",\" , I0 , \") * A(\" , I0 , \",\" , I0 , \")\" ) 111 format ( 20 ( \"*\" )) end do print 111 C ( i , j ) = sum end do end do else print * , \"C is not the proper shape to hold the matrix product\" ierr = 3 end if else print * , \"C is not large enough to hold the matrix product\" print * , \"The size of C is: \" , size ( C ) print * , \"The shape of C is: \" , shape ( C ) ierr = 2 end if else ierr = 1 print * , \"Matrices are not compatible\" end if ! print *, \"The shape of C inside the subroutine is: \", shape(C) end subroutine end module","tags":"","loc":"sourcefile/my_matmul_explicit.f90.html"},{"title":"trig_degrees.f90 – Fortran Program","text":"Contents Submodules trig_degrees Source Code trig_degrees.f90 Source Code submodule ( trig ) trig_degrees contains module procedure sind sind = sin ( deg_to_rad ( theta )) end procedure module procedure cosd cosd = cos ( deg_to_rad ( theta )) end procedure module procedure tand tand = tan ( deg_to_rad ( theta )) end procedure module procedure acosd acosd = acos ( deg_to_rad ( theta )) end procedure module procedure asind asind = asin ( deg_to_rad ( theta )) end procedure module procedure atand atand = atan ( deg_to_rad ( theta )) end procedure end submodule","tags":"","loc":"sourcefile/trig_degrees.f90.html"},{"title":"prototype@least_squares.f90 – Fortran Program","text":"Contents Submodules least_squares Source Code prototype@least_squares.f90 Source Code submodule ( prototype ) least_squares contains module procedure least_squares_fit real ( 8 ), dimension (:,:), allocatable :: A real ( 8 ), dimension (:), allocatable :: u allocate ( c ( order + 1 )) call generate_sys_eqns ( x , y , order , A , u ) call solve_n ( A , c , u ) end procedure module procedure generate_sys_eqns integer :: i , j , ndim ndim = order + 1 allocate ( A ( ndim , ndim ), u ( ndim )) do i = 1 , ndim do j = 1 , ndim A ( i , j ) = sum ( X ** ( i + j - 2 )) end do end do A ( 1 , 1 ) = size ( X ) do i = 1 , ndim u ( i ) = sum ( Y * ( X ** ( i - 1 ))) end do end procedure module procedure solve_n real ( 8 ) :: max_pivot integer :: i , ipivot , nstep , n integer , dimension ( 2 ) :: A_shape ! What follows is a really crude version of gaussian elimination real ( 8 ), dimension (:,:), allocatable :: A_aux A_shape = shape ( A ) n = A_shape ( 1 ) allocate ( A_aux ( n , n + 1 )) A_aux ( 1 : n , 1 : n ) = A A_aux ( 1 : n , n + 1 ) = y ! Switch the pivot columns ! Eliminate the first column do nstep = 1 , n ! Find the largest pivot in A_aux max_pivot = A_aux ( nstep , nstep ) do i = nstep , n if ( abs ( A_aux ( i , nstep )) >= max_pivot ) then max_pivot = A_aux ( i , nstep ) ipivot = i end if end do ! print *, \"max_pivot for col \", nstep, \" = \", max_pivot if ( is_zero ( max_pivot )) then STOP \"Matrix is singular, stopping elimination\" end if call switch_rows ( A_aux , ipivot , nstep ) call elim_col ( A_aux , nstep ) ! print *, \"A after elimination: \" ! do i = 1,n !     print *, A_aux(i,:) ! end do end do y = A_aux (:, n + 1 ) call back_sub ( A_aux ( 1 : n , 1 : n ), x , y ) do i = 1 , n print 111 , i , x ( i ) end do 111 format ( \"X(\" , I0 , \") = \" , F12 . 7 ) end procedure module procedure switch_rows real ( 8 ), dimension (:), allocatable :: temp_row temp_row = A ( row1 ,:) A ( row1 ,:) = A ( row2 ,:) A ( row2 ,:) = temp_row end procedure module procedure back_sub integer :: n , i , j integer , dimension ( 2 ) :: U_shape U_shape = shape ( U ) n = U_shape ( 1 ) ! print *, \"Entering backsub\" ! print *, \"n = \", n ! print *, \"size(x) = \", size(x) ! print *, \"size(y) = \", size(y) do i = n , 1 , - 1 do j = i , n ! print *, \"i,j = \", i, j if ( i == j ) then x ( i ) = y ( i ) else x ( i ) = x ( i ) - U ( i , j ) * x ( j ) end if end do end do end procedure module procedure elim_col real ( 8 ) :: coeff real ( 8 ) :: working_pivot integer , dimension ( 2 ) :: A_shape integer :: nrows , i coeff = A ( icol , icol ) A_shape = shape ( A ) nrows = A_shape ( 1 ) do i = icol + 1 , nrows working_pivot = A ( i , icol ) coeff = working_pivot / A ( icol , icol ) A ( i ,:) = A ( i ,:) - ( coeff * A ( icol ,:)) end do A ( icol ,:) = A ( icol ,:) * ( 1 / A ( icol , icol )) end procedure module procedure is_zero if ( abs ( X ) < 1E-9 ) then is_zero = . true . else is_zero = . false . end if end procedure module procedure add_noise integer :: i do i = 1 , 51 noise ( i ) = urand ( min , max ) end do Y_noise = Y + noise end procedure end submodule","tags":"","loc":"sourcefile/prototype@least_squares.f90.html"},{"title":"hyperbolics.f90 – Fortran Program","text":"Contents Modules hyperbolics Source Code hyperbolics.f90 Source Code module hyperbolics implicit none contains function my_sinh ( x ) result ( sinhx ) real , intent ( in ) :: x real :: sinhx sinhx = ( exp ( x ) - exp ( - x )) / 2 end function function my_cosh ( x ) result ( coshx ) real , intent ( in ) :: x real :: coshx coshx = ( exp ( x ) + exp ( - x )) / 2 end function function my_tanh ( x ) result ( tanhx ) real , intent ( in ) :: x real :: tanhx tanhx = my_sinh ( x ) / my_cosh ( x ) end function end module hyperbolics","tags":"","loc":"sourcefile/hyperbolics.f90.html"},{"title":"my_matmul_sub.f90 – Fortran Program","text":"Contents Submodules my_matmul_mod_child Source Code my_matmul_sub.f90 Source Code submodule ( my_matmul_mod_parent ) my_matmul_mod_child implicit none contains module procedure my_matmul integer , dimension ( 2 ) :: dimA , dimB , dimC integer :: i , j , k real :: sum dimA = shape ( A ) dimB = shape ( B ) dimC = shape ( C ) ! Error flags dictionary ! 0        Successful matrix multiplication ! 1        Matrices A and B are incompatible ! 2        Matrix C is not large enough to contain the result ! 3        Matrix C is not the appropriate size ! See if A and B are compatible if ( dimA ( 2 ) == dimB ( 1 )) then print * , \"A and B are compatible for matrix multiplication\" if ( size ( C ) >= dimA ( 1 ) * dimB ( 2 )) then print * , \"C is large enough to hold the matrix product\" if ( dimC ( 1 ) == dimA ( 1 ) . and . dimC ( 2 ) == dimB ( 2 )) then print * , \"C is the proper shape to hold the matrix product\" ierr = 0 ! Let's actually compute the matrix now ! The common value is the colA and rowB. This is the number of operations per element in C print * , \"Computing the matrix multiplication\" do i = 1 , dimC ( 1 ) do j = 1 , dimC ( 2 ) sum = 0 do k = 1 , dimA ( 2 ) ! First column of C is 1st col of B times first row of A ! Second column of C is the 2nd col of B times the first row of A sum = sum + ( B ( k , j ) * A ( i , k )) print 100 , k , j , i , k 100 format ( \"B(\" , I0 , \",\" , I0 , \") * A(\" , I0 , \",\" , I0 , \")\" ) 111 format ( 20 ( \"*\" )) end do print 111 C ( i , j ) = sum end do end do else print * , \"C is not the proper shape to hold the matrix product\" ierr = 3 end if else print * , \"C is not large enough to hold the matrix product\" print * , \"The size of C is: \" , size ( C ) print * , \"The shape of C is: \" , shape ( C ) ierr = 2 end if else ierr = 1 print * , \"Matrices are not compatible\" end if end procedure end submodule","tags":"","loc":"sourcefile/my_matmul_sub.f90.html"},{"title":"coordinates.f90 – Fortran Program","text":"Contents Modules coordinates Source Code coordinates.f90 Source Code module coordinates interface compass_to_cart ! Convert from compass coordinates to cartesian module subroutine compass_to_cart end subroutine end interface end module","tags":"","loc":"sourcefile/coordinates.f90.html"},{"title":"new_types.f90 – Fortran Program","text":"Contents Modules new_types Source Code new_types.f90 Source Code module new_types implicit none type vector real :: x real :: y character ( 10 ) :: name = \"default\" end type end module","tags":"","loc":"sourcefile/new_types.f90.html"},{"title":"ejovo_types.f90 – Fortran Program","text":"Contents Modules ejovo_types Source Code ejovo_types.f90 Source Code module ejovo_types implicit none real , parameter :: PI = 3.141592653589793 type polar real :: r real :: theta ! The principal argument in degrees contains procedure , pass :: mult procedure , pass :: div end type type line real :: m real :: b contains procedure , pass :: print end type type point real :: x real :: y contains procedure , pass :: dist => distance_between_points procedure , pass :: find_line end type interface ! Polar type code and functions module function comp2pol ( c ) result ( pol ) complex , intent ( in ) :: c type ( polar ) :: pol end function module function pol2comp ( pol ) result ( c ) type ( polar ), intent ( in ) :: pol complex :: c end function module pure function mult ( p1 , p2 ) result ( p3 ) class ( polar ), intent ( in ) :: p1 , p2 type ( polar ) :: p3 end function module pure function div ( p1 , p2 ) result ( p3 ) class ( polar ), intent ( in ) :: p1 , p2 type ( polar ) :: p3 end function end interface interface ! Line module subroutine print ( line1 ) class ( line ), intent ( in ) :: line1 end subroutine end interface interface ! Point ! Find the distance between two points module pure function distance_between_points ( p1 , p2 ) result ( d1 ) class ( point ), intent ( in ) :: p1 , p2 real :: d1 end function module pure function find_line ( p1 , p2 ) result ( l ) class ( point ), intent ( in ) :: p1 , p2 type ( line ) :: l end function end interface end module","tags":"","loc":"sourcefile/ejovo_types.f90.html"},{"title":"point – Fortran Program ","text":"type, public, abstract :: point Contents Variables kind Components Type Visibility Attributes Name Initial integer, public :: kind = 8","tags":"","loc":"type/point~2.html"},{"title":"polar – Fortran Program ","text":"type, public, extends( point ) :: polar Contents Variables kind r th Type-Bound Procedures to_cart Components Type Visibility Attributes Name Initial integer, public :: kind = 8 real, public :: r real, public :: th Type-Bound Procedures procedure, public :: to_cart => pol_to_cart interface public module function pol_to_cart(p1) result(c1) Arguments Type Intent Optional Attributes Name class( polar ), intent(in) :: p1 Return Value type( cart )","tags":"","loc":"type/polar~2.html"},{"title":"cart – Fortran Program ","text":"type, public, extends( point ) :: cart Contents Variables kind x y Type-Bound Procedures to_pol Components Type Visibility Attributes Name Initial integer, public :: kind = 8 real, public :: x real, public :: y Type-Bound Procedures procedure, public :: to_pol => cart_to_pol interface public module function cart_to_pol(c1) result(p1) Arguments Type Intent Optional Attributes Name class( cart ), intent(in) :: c1 Return Value type( polar )","tags":"","loc":"type/cart.html"},{"title":"vector – Fortran Program ","text":"type, public :: vector Contents Variables x y Type-Bound Procedures operator(+) operator(-) operator(*) operator(/) vector_addition vector_substraction vector_times_scalar vector_divided_scalar Components Type Visibility Attributes Name Initial real, public :: x real, public :: y Type-Bound Procedures generic, public :: operator(+) => vector_addition public elemental function vector_addition (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: v1 class( vector ), intent(in) :: v2 Return Value type( vector ) generic, public :: operator(-) => vector_substraction public elemental function vector_substraction (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: v1 class( vector ), intent(in) :: v2 Return Value type( vector ) generic, public :: operator(*) => vector_times_scalar public elemental function vector_times_scalar (vec, scalar) result(v2) Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: vec real, intent(in) :: scalar Return Value type( vector ) generic, public :: operator(/) => vector_divided_scalar public elemental function vector_divided_scalar (vec, scalar) result(v2) Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: vec real, intent(in) :: scalar Return Value type( vector ) procedure, public :: vector_addition public elemental function vector_addition (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: v1 class( vector ), intent(in) :: v2 Return Value type( vector ) procedure, public :: vector_substraction public elemental function vector_substraction (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: v1 class( vector ), intent(in) :: v2 Return Value type( vector ) procedure, public :: vector_times_scalar public elemental function vector_times_scalar (vec, scalar) result(v2) Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: vec real, intent(in) :: scalar Return Value type( vector ) procedure, public :: vector_divided_scalar public elemental function vector_divided_scalar (vec, scalar) result(v2) Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: vec real, intent(in) :: scalar Return Value type( vector )","tags":"","loc":"type/vector.html"},{"title":"detection – Fortran Program ","text":"type, public :: detection Contents Variables range azimuth time cart Constructor detection Type-Bound Procedures to_cart time_diff pos_diff compute_velocity Components Type Visibility Attributes Name Initial real, public :: range real, public :: azimuth real, public :: time type( vector ), public :: cart = vector(0.0, 0.0) Constructor public interface detection public function new_detection (range, azimuth, time) Arguments Type Intent Optional Attributes Name real, intent(in) :: range real, intent(in) :: azimuth real, intent(in) :: time Return Value type( detection ) Type-Bound Procedures procedure, public :: to_cart public elemental function to_cart (detect) result(cart) Arguments Type Intent Optional Attributes Name class( detection ), intent(in) :: detect Return Value type( vector ) procedure, public :: time_diff public elemental function time_diff (det1, det2) Arguments Type Intent Optional Attributes Name class( detection ), intent(in) :: det1 class( detection ), intent(in) :: det2 Return Value real procedure, public :: pos_diff public elemental function pos_diff (det1, det2) Arguments Type Intent Optional Attributes Name class( detection ), intent(in) :: det1 class( detection ), intent(in) :: det2 Return Value type( vector ) procedure, public :: compute_velocity public elemental function compute_velocity (det_t0, det_tf) Arguments Type Intent Optional Attributes Name class( detection ), intent(in) :: det_t0 class( detection ), intent(in) :: det_tf Return Value type( vector )","tags":"","loc":"type/detection.html"},{"title":"vector – Fortran Program ","text":"type, public :: vector Contents Variables x y name Components Type Visibility Attributes Name Initial real, public :: x real, public :: y character(len=10), public :: name = \"default\"","tags":"","loc":"type/vector~2.html"},{"title":"polar – Fortran Program ","text":"type, public :: polar Contents Variables r theta Type-Bound Procedures mult div Components Type Visibility Attributes Name Initial real, public :: r real, public :: theta Type-Bound Procedures procedure, public, pass :: mult interface public pure module function mult(p1, p2) result(p3) Arguments Type Intent Optional Attributes Name class( polar ), intent(in) :: p1 class( polar ), intent(in) :: p2 Return Value type( polar ) procedure, public, pass :: div interface public pure module function div(p1, p2) result(p3) Arguments Type Intent Optional Attributes Name class( polar ), intent(in) :: p1 class( polar ), intent(in) :: p2 Return Value type( polar )","tags":"","loc":"type/polar.html"},{"title":"line – Fortran Program ","text":"type, public :: line Contents Variables m b Type-Bound Procedures print Components Type Visibility Attributes Name Initial real, public :: m real, public :: b Type-Bound Procedures procedure, public, pass :: print interface public module subroutine print(line1) Arguments Type Intent Optional Attributes Name class( line ), intent(in) :: line1","tags":"","loc":"type/line.html"},{"title":"point – Fortran Program ","text":"type, public :: point Contents Variables x y Type-Bound Procedures dist find_line Components Type Visibility Attributes Name Initial real, public :: x real, public :: y Type-Bound Procedures procedure, public, pass :: dist => distance_between_points interface public pure module function distance_between_points(p1, p2) result(d1) Arguments Type Intent Optional Attributes Name class( point ), intent(in) :: p1 class( point ), intent(in) :: p2 Return Value real procedure, public, pass :: find_line interface public pure module function find_line(p1, p2) result(l) Arguments Type Intent Optional Attributes Name class( point ), intent(in) :: p1 class( point ), intent(in) :: p2 Return Value type( line )","tags":"","loc":"type/point.html"},{"title":"is_alphnum – Fortran Program","text":"public function is_alphnum(char) Test whether an ASCII character is alpha-numeric Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: char Return Value logical Contents None","tags":"","loc":"proc/is_alphnum.html"},{"title":"is_alph – Fortran Program","text":"public function is_alph(char) Test whether an ASCII character is a letter Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: char Return Value logical Contents None","tags":"","loc":"proc/is_alph.html"},{"title":"is_num – Fortran Program","text":"public function is_num(char) Test whether an ASCII character is numeric Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: char Return Value logical Contents None","tags":"","loc":"proc/is_num.html"},{"title":"is_lower – Fortran Program","text":"public function is_lower(char) Test whether an ASCII character is a lowercase letter Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: char Return Value logical Contents None","tags":"","loc":"proc/is_lower.html"},{"title":"is_upper – Fortran Program","text":"public function is_upper(char) Test whether an ASCII character is an uppercase letter Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: char Return Value logical Contents None","tags":"","loc":"proc/is_upper.html"},{"title":"calc_current_flow – Fortran Program","text":"public elemental function calc_current_flow(v_D, I_O, T) result(i_D) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: v_D The voltage across the diode, in volts real(kind=real64), intent(in) :: I_O The leakage current of the diode, in amperes real(kind=real64), intent(in) :: T Temperature, in kelvins (K) Return Value real(kind=real64) The current flow through the diode in amperes Contents None","tags":"","loc":"proc/calc_current_flow.html"},{"title":"to_kelvin – Fortran Program","text":"public elemental function to_kelvin(F) Convert a temperature in Fahrenheit to Kelvin Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: F Return Value real(kind=real64) Contents None","tags":"","loc":"proc/to_kelvin.html"},{"title":"to_celcius – Fortran Program","text":"public elemental function to_celcius(F) Convert a temperature from Fahrenheit to celcius Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: F Return Value real(kind=real64) Contents None","tags":"","loc":"proc/to_celcius.html"},{"title":"p4_1 – Fortran Program","text":"public subroutine p4_1() Test if the following equalities are valid statements, and if they are,\n evaluate them Arguments None Contents None","tags":"","loc":"proc/p4_1.html"},{"title":"p4_3 – Fortran Program","text":"public subroutine p4_3() Write a Fortran program to evaluate the equation y(x) = x&#94;2 - 3x + 2 for all values between -1 and 3,\n in steps of 0.1. Arguments None Contents None","tags":"","loc":"proc/p4_3.html"},{"title":"p4_4 – Fortran Program","text":"public subroutine p4_4() Write the Fortran statements required to calculate y(t) from the equation: y(t) = ------ -3t&#94;2 + 5    t >= 0\n           ---   3t&#94;2 + 5    t < 0 Arguments None Contents None","tags":"","loc":"proc/p4_4.html"},{"title":"p4_5 – Fortran Program","text":"public subroutine p4_5() Write a Fortran program to calculate the factorial function. Be sure to handle the special \n cases of 0! and of illegal input values. Arguments None Contents None","tags":"","loc":"proc/p4_5.html"},{"title":"p4_6 – Fortran Program","text":"public subroutine p4_6() What is the difference in behavior between a cycle statement and an exit statement? Arguments None Contents None","tags":"","loc":"proc/p4_6.html"},{"title":"p4_7 – Fortran Program","text":"public subroutine p4_7() Modify program stats_2 to use the DO WHILE construct instaed of the while construct currently in the program A modified statistical analysis program that avoids the divide-by-zero problems inherent in program stats_1. Purpose: To calculate mean and the standard deviation of an input data set containing an arbitrary number of input values. Record of revisions: Date      Programmer     Description of change\n  ====      ==========     =====================\n 11/10/15  S. J. Chapman   Original code\n 11/12/15  S. J. Chapman   Correct divide-by-0 error if\n                           0 or 1 input values given.\n 02/16/21  E. J. Voyles    Add do-while construct Arguments None Contents None","tags":"","loc":"proc/p4_7.html"},{"title":"p4_8 – Fortran Program","text":"public subroutine p4_8() Examine the following DO statements and determine how many times each loop will\n be exectued. !!! This for loop shows an error, since the increment is 0 !!!!!!!!!! Arguments None Contents None","tags":"","loc":"proc/p4_8.html"},{"title":"p4_9 – Fortran Program","text":"public subroutine p4_9() Examine the following loops, determine the value of ires and the number of times\n each loop executes Arguments None Contents None","tags":"","loc":"proc/p4_9.html"},{"title":"p4_10 – Fortran Program","text":"public subroutine p4_10() Examine the followin while loops and determine the value of ires at the end of each of \n the loops. Arguments None Contents None","tags":"","loc":"proc/p4_10.html"},{"title":"p4_11 – Fortran Program","text":"public subroutine p4_11() Modify program ball from example 4-7 to read in the acceleration due to gravity\n at a particular location, and to calculate the maximum range of the ball for that acceleration.\n After modifying the program, run it with accelerations of -9.8, -9.7, and -9.6m/s2. What effect does the reduction in gravitational attraction have on the range ofthe ball?\n What effect does the reduction in gravitational attraction have on the best angle theta at which to throw the ball? Arguments None Contents None","tags":"","loc":"proc/p4_11.html"},{"title":"p4_12 – Fortran Program","text":"public subroutine p4_12() Modify program ball from Example 4-7 to read in the initial velocity with which the ball\n is thrown. After modifying the program, run it with initial velocities of 10, 20, and 20 \n m/sec. What effect does changin the initial velocity have on the range of the ball? What\n effect does it have on the best angle theta at which to throw the ball? Arguments None Contents None","tags":"","loc":"proc/p4_12.html"},{"title":"p4_13 – Fortran Program","text":"public subroutine p4_13() Arguments None Contents None","tags":"","loc":"proc/p4_13.html"},{"title":"p4_14 – Fortran Program","text":"public subroutine p4_14() Write a Fortran program to evaluate the function \n y(x) = ln(1/1-x)\n for any user-specified value of x, where ln is the natural logarithm.\n Write the program with a while loop, so that the program repeats the calculation \n for each legal value of x entered into the program. When an illegal value of x is entered,\n terminate the program. Arguments None Contents None","tags":"","loc":"proc/p4_14.html"},{"title":"p4_15 – Fortran Program","text":"public subroutine p4_15() Write a Fortran program to convert all uppercase characters in a user-supplied character\n string to lowercase, without changing the uppercase and nonalphabetic characters in the string.\n Assume that your computer uses the ASCII collating sequence. Arguments None Contents None","tags":"","loc":"proc/p4_15.html"},{"title":"p4_16 – Fortran Program","text":"public subroutine p4_16() Calculating Orbits. When a satellinte orbits the Eath, the satellite's orbit will form an ellipse with the \n Earth located at one of the focal points of the ellipse. The satellite's orbit can be \n expressed in polar coordintaes as r = p/(1 - \\epsilon * cos( \\theta )) Where r and theta are the distance and angle of the satellite from the center of the earth,\n p is a parameter specifying the size of the orbit, and \\epsilon is a parameter representing the\n eccentricity of the orbit. A circular orbit has an eccentricity of zero. An elliptical orbit has \n an eccentricity of 0 <= e <= 1. If \\epsilon > 1, the satellite follows a hyperbolic path and escapes\n from Earth's gravitational field. Consider a satellite with a size parameter p = 1200 km. Write a program to calculate the \n distance of the satellite from the center of the Earth as a function of theta if the satellite has \n an eccentricity of (a) e = 0; (b) e = 0.25; (c) e = 0.5. Write a single program in which\n r and e are both input values. How close does each orbit come to the earth? How far away does each orbit get from the earth? Arguments None Contents None","tags":"","loc":"proc/p4_16.html"},{"title":"p4_17 – Fortran Program","text":"public subroutine p4_17() Write a program caps that reads in a character string, searches for all of the words \n within the string, and capitalizes the first letter of each word, while shifting the \n remainder of the word to lowercase. Assume that all nonalphabetic and nonumeric characters\n can mark the boundaries of a word within the character variable (periods, commas,etc.). \n Nonalphabetic characters should be left unchanged. Arguments None Contents None","tags":"","loc":"proc/p4_17.html"},{"title":"p4_18 – Fortran Program","text":"public subroutine p4_18() Write a computer program to calculate the current flowing through this diode\n for all voltages from -1.0V to +0.6 V, in 0.1 V steps. Repeat this process for the \n following temperatures: 75F, 100F, and 125F Arguments None Contents None","tags":"","loc":"proc/p4_18.html"},{"title":"p4_19 – Fortran Program","text":"public subroutine p4_19() Write a program that promps a user for a binary number, which will be entered as a string\n of 0s and 1s in a character variable. This program should be able to handle numbers whos\n binary representation is up to 10 bits, corresponding to values from 0 to 1023. Arguments None Contents None","tags":"","loc":"proc/p4_19.html"},{"title":"to_lower – Fortran Program","text":"public subroutine to_lower(char) Convert a single character to lowercase Arguments Type Intent Optional Attributes Name character(len=1), intent(inout) :: char Contents None","tags":"","loc":"proc/to_lower.html"},{"title":"to_upper – Fortran Program","text":"public subroutine to_upper(char) Convert a single character to uppercase Arguments Type Intent Optional Attributes Name character(len=1), intent(inout) :: char Contents None","tags":"","loc":"proc/to_upper.html"},{"title":"p7_1 – Fortran Program","text":"public subroutine p7_1() DISCUSSION QUESTION What is the difference between a subroutine and a function? Arguments None Contents None","tags":"","loc":"proc/p7_1.html"},{"title":"p7_2 – Fortran Program","text":"public subroutine p7_2() DISCUSSION QUESTION When a subroutine is called, how is data passed from the calling program to the subroutine,\n and how are the results of the subroutine returned to the calling program? Arguments None Contents None","tags":"","loc":"proc/p7_2.html"},{"title":"p7_3 – Fortran Program","text":"public subroutine p7_3() DISCUSSION QUESTION What are the advantages and disadvantages of the pass-by-reference scheme used in Fortran? Arguments None Contents None","tags":"","loc":"proc/p7_3.html"},{"title":"p7_4 – Fortran Program","text":"public subroutine p7_4() DISCUSSION QUESTION What are the advantages and disadvantages of each procedure array type? Arguments None Contents None","tags":"","loc":"proc/p7_4.html"},{"title":"p7_5 – Fortran Program","text":"public subroutine p7_5() DISCUSSION QUESTION Suppose a 15-element array is passed to a subroutine. What happens if the subroutine attempts\n to write to element a(16)? Arguments None Contents None","tags":"","loc":"proc/p7_5.html"},{"title":"p7_6 – Fortran Program","text":"public subroutine p7_6() DISCUSSION QUESTION If a real value is passed to a subroutine in an argument that is declared to be an integer,\n what happens? Arguments None Contents None","tags":"","loc":"proc/p7_6.html"},{"title":"p7_7 – Fortran Program","text":"public subroutine p7_7() DISCUSSION QUESTION How can p7_6 be modified so that the compiler catches the argument mismatch between\n the actual argument and the dummy argument in the subroutine? Arguments None Contents None","tags":"","loc":"proc/p7_7.html"},{"title":"p7_8 – Fortran Program","text":"public subroutine p7_8() DISCUSSION QUESTION What is the purpose of the INTENT attribute? Where can it be used? Why should it be used? Arguments None Contents None","tags":"","loc":"proc/p7_8.html"},{"title":"p7_9 – Fortran Program","text":"public subroutine p7_9() NOT APPLICABLE Arguments None Contents None","tags":"","loc":"proc/p7_9.html"},{"title":"p7_10 – Fortran Program","text":"public subroutine p7_10() NOT APPLICABLE Arguments None Contents None","tags":"","loc":"proc/p7_10.html"},{"title":"p6_1 – Fortran Program","text":"public subroutine p6_1() DISCUSSION QUESTION How may arrays be declared? Arguments None Contents None","tags":"","loc":"proc/p6_1.html"},{"title":"p6_3 – Fortran Program","text":"public subroutine p6_3() DISCUSSION QUESTION Execute this subroutine on your computer with both bounds checking turned on and \n bounds checking turned off. What happens? Arguments None Contents None","tags":"","loc":"proc/p6_3.html"},{"title":"p6_4 – Fortran Program","text":"public subroutine p6_4() DISCUSSION QUESTION Determine the shape and size of the arrays specified by the following statements: Arguments None Contents None","tags":"","loc":"proc/p6_4.html"},{"title":"p6_5 – Fortran Program","text":"public subroutine p6_5() DISCUSSION QUESTION Determine which of the following Fortran program fragments are valid. For each valid statement,\n specify what will happen in the program. (Assume default typing for any variables that are not \n explicitly typed within the program fragments.) Arguments None Contents None","tags":"","loc":"proc/p6_5.html"},{"title":"p6_6 – Fortran Program","text":"public subroutine p6_6() DISCUSSION QUESTION What is meant by each of the following array terms? Size, shape, extent, rank, conformable. Arguments None Contents None","tags":"","loc":"proc/p6_6.html"},{"title":"p6_7 – Fortran Program","text":"public subroutine p6_7() DISCUSSION QUESTION Given an array my_array defined as shown, determine whether each of the following\n array sections is valid Arguments None Contents None","tags":"","loc":"proc/p6_7.html"},{"title":"p6_8 – Fortran Program","text":"public subroutine p6_8() DISCUSSION QUESTION What will the output from each of the WRITE statements in the following subroutine be?\n Why is the output of the two statements different? Arguments None Contents None","tags":"","loc":"proc/p6_8.html"},{"title":"p6_10 – Fortran Program","text":"public subroutine p6_10() Polar to Rectangular Conversion Write a program that reads the polar coordinates of a 2D vector into a rank\n 1 array POLAR. polar(1) will contain the mgnitude and polar(2) will contain the \n angle theta in degrees, and converts the vector from\n polar to rectangular form, storing the result in a rank1 array RECT.\n Rect(1) should be the x component and rect(2) will be the y component. Arguments None Contents None","tags":"","loc":"proc/p6_10.html"},{"title":"p6_11 – Fortran Program","text":"public subroutine p6_11() Rectangular to Polar Conversion Write a program that reads the rectangular components of a 2D vector into a rank 1\n array rect. Arguments None Contents None","tags":"","loc":"proc/p6_11.html"},{"title":"p5_1 – Fortran Program","text":"public subroutine p5_1() DISCUSSION QUESTION What is the purpose of a format? What are the three ways to define a format? Arguments None Contents None","tags":"","loc":"proc/p5_1.html"},{"title":"p5_2 – Fortran Program","text":"public subroutine p5_2() DISCUSSION QUESTION What is printed out by the following Fortran statements? Arguments None Contents None","tags":"","loc":"proc/p5_2.html"},{"title":"p5_3 – Fortran Program","text":"public subroutine p5_3() DISCUSSION QUESTION What is printed out by the following Fortran statements? Arguments None Contents None","tags":"","loc":"proc/p5_3.html"},{"title":"p5_4 – Fortran Program","text":"public subroutine p5_4(file_name) DISCUSSION QUESTION Read in 5_4.dat and find out what the output will be for the following statements: Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name Contents None","tags":"","loc":"proc/p5_4.html"},{"title":"p5_5 – Fortran Program","text":"public subroutine p5_5(file_name) DISCUSSION QUESTION Read in 5_5.dat and find out what the value of each variable will be when the \n READ statements have been completed Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name Contents None","tags":"","loc":"proc/p5_5.html"},{"title":"p5_6 – Fortran Program","text":"public subroutine p5_6() Generate a table of the base 10 logarithms between 1 and 10 in steps of 0.1 Arguments None Contents None","tags":"","loc":"proc/p5_6.html"},{"title":"sind – Fortran Program","text":"public interface sind Contents Module Procedures sind_r32 sind_r64 Module Procedures public interface sind_r32 () Arguments None public interface sind_r64 () Arguments None","tags":"","loc":"interface/sind.html"},{"title":"cosd – Fortran Program","text":"public interface cosd Contents Module Procedures cosd_r32 cosd_r64 Module Procedures public interface cosd_r32 () Arguments None public interface cosd_r64 () Arguments None","tags":"","loc":"interface/cosd.html"},{"title":"tand – Fortran Program","text":"public interface tand Contents Module Procedures tand_r32 tand_r64 Module Procedures public interface tand_r32 () Arguments None public interface tand_r64 () Arguments None","tags":"","loc":"interface/tand.html"},{"title":"asind – Fortran Program","text":"public interface asind Contents Module Procedures asind_r32 asind_r64 Module Procedures public interface asind_r32 () Arguments None public interface asind_r64 () Arguments None","tags":"","loc":"interface/asind.html"},{"title":"acosd – Fortran Program","text":"public interface acosd Contents Module Procedures acosd_r32 acosd_r64 Module Procedures public interface acosd_r32 () Arguments None public interface acosd_r64 () Arguments None","tags":"","loc":"interface/acosd.html"},{"title":"atand – Fortran Program","text":"public interface atand Contents Module Procedures atand_r32 atand_r64 Module Procedures public interface atand_r32 () Arguments None public interface atand_r64 () Arguments None","tags":"","loc":"interface/atand.html"},{"title":"sinhd – Fortran Program","text":"public interface sinhd Contents Module Procedures sinhd_r32 sinhd_r64 Module Procedures public interface sinhd_r32 () Arguments None public interface sinhd_r64 () Arguments None","tags":"","loc":"interface/sinhd.html"},{"title":"coshd – Fortran Program","text":"public interface coshd Contents Module Procedures coshd_r32 coshd_r64 Module Procedures public interface coshd_r32 () Arguments None public interface coshd_r64 () Arguments None","tags":"","loc":"interface/coshd.html"},{"title":"tanhd – Fortran Program","text":"public interface tanhd Contents Module Procedures tanhd_r32 tanhd_r64 Module Procedures public interface tanhd_r32 () Arguments None public interface tanhd_r64 () Arguments None","tags":"","loc":"interface/tanhd.html"},{"title":"deg_to_rad – Fortran Program","text":"public interface deg_to_rad Contents Module Procedures deg_to_rad_r32 deg_to_rad_r64 Module Procedures public interface deg_to_rad_r32 () Arguments None public interface deg_to_rad_r64 () Arguments None","tags":"","loc":"interface/deg_to_rad.html"},{"title":"rad_to_deg – Fortran Program","text":"public interface rad_to_deg Contents Module Procedures rad_to_deg_r32 rad_to_deg_r64 Module Procedures public interface rad_to_deg_r32 () Arguments None public interface rad_to_deg_r64 () Arguments None","tags":"","loc":"interface/rad_to_deg.html"},{"title":"intersection – Fortran Program","text":"public interface intersection Contents Module Procedures intersection_int intersection_r32 intersection_r64 Module Procedures public interface intersection_int () Arguments None public interface intersection_r32 () Arguments None public interface intersection_r64 () Arguments None","tags":"","loc":"interface/intersection.html"},{"title":"union – Fortran Program","text":"public interface union Contents Module Procedures union_int union_r32 union_r64 Module Procedures public interface union_int () Arguments None public interface union_r32 () Arguments None public interface union_r64 () Arguments None","tags":"","loc":"interface/union.html"},{"title":"belongs_to – Fortran Program","text":"public interface belongs_to Contents Module Procedures belongs_to_int belongs_to_r32 belongs_to_r64 Module Procedures public interface belongs_to_int () Arguments None public interface belongs_to_r32 () Arguments None public interface belongs_to_r64 () Arguments None","tags":"","loc":"interface/belongs_to.html"},{"title":"array_epsilon – Fortran Program","text":"public interface array_epsilon Contents Module Procedures array_epsilon_r32 array_epsilon_r64 Module Procedures public interface array_epsilon_r32 () Arguments None public interface array_epsilon_r64 () Arguments None","tags":"","loc":"interface/array_epsilon.html"},{"title":"abs_max_val – Fortran Program","text":"public interface abs_max_val Contents Module Procedures abs_max_val_r32 abs_max_val_r64 Module Procedures public interface abs_max_val_r32 () Arguments None public interface abs_max_val_r64 () Arguments None","tags":"","loc":"interface/abs_max_val.html"},{"title":"sind_r32 – Fortran Program","text":"interface public elemental module function sind_r32(theta) result(sind) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: theta Return Value real(kind=real32)","tags":"","loc":"interface/sind_r32.html"},{"title":"sind_r64 – Fortran Program","text":"interface public elemental module function sind_r64(theta) result(sind) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: theta Return Value real(kind=real64)","tags":"","loc":"interface/sind_r64.html"},{"title":"cosd_r32 – Fortran Program","text":"interface public elemental module function cosd_r32(theta) result(cosd) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: theta Return Value real(kind=real32)","tags":"","loc":"interface/cosd_r32.html"},{"title":"cosd_r64 – Fortran Program","text":"interface public elemental module function cosd_r64(theta) result(cosd) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: theta Return Value real(kind=real64)","tags":"","loc":"interface/cosd_r64.html"},{"title":"tand_r32 – Fortran Program","text":"interface public elemental module function tand_r32(theta) result(tand) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: theta Return Value real(kind=real32)","tags":"","loc":"interface/tand_r32.html"},{"title":"tand_r64 – Fortran Program","text":"interface public elemental module function tand_r64(theta) result(tand) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: theta Return Value real(kind=real64)","tags":"","loc":"interface/tand_r64.html"},{"title":"asind_r32 – Fortran Program","text":"interface public elemental module function asind_r32(theta) result(asind) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: theta Return Value real(kind=real32)","tags":"","loc":"interface/asind_r32.html"},{"title":"asind_r64 – Fortran Program","text":"interface public elemental module function asind_r64(theta) result(asind) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: theta Return Value real(kind=real64)","tags":"","loc":"interface/asind_r64.html"},{"title":"acosd_r32 – Fortran Program","text":"interface public elemental module function acosd_r32(theta) result(acosd) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: theta Return Value real(kind=real32)","tags":"","loc":"interface/acosd_r32.html"},{"title":"acosd_r64 – Fortran Program","text":"interface public elemental module function acosd_r64(theta) result(acosd) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: theta Return Value real(kind=real64)","tags":"","loc":"interface/acosd_r64.html"},{"title":"atand_r32 – Fortran Program","text":"interface public elemental module function atand_r32(theta) result(atand) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: theta Return Value real(kind=real32)","tags":"","loc":"interface/atand_r32.html"},{"title":"atand_r64 – Fortran Program","text":"interface public elemental module function atand_r64(theta) result(atand) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: theta Return Value real(kind=real64)","tags":"","loc":"interface/atand_r64.html"},{"title":"sinhd_r32 – Fortran Program","text":"interface public elemental module function sinhd_r32(theta) result(sinhd) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: theta Return Value real(kind=real32)","tags":"","loc":"interface/sinhd_r32.html"},{"title":"sinhd_r64 – Fortran Program","text":"interface public elemental module function sinhd_r64(theta) result(sinhd) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: theta Return Value real(kind=real64)","tags":"","loc":"interface/sinhd_r64.html"},{"title":"coshd_r32 – Fortran Program","text":"interface public elemental module function coshd_r32(theta) result(coshd) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: theta Return Value real(kind=real32)","tags":"","loc":"interface/coshd_r32.html"},{"title":"coshd_r64 – Fortran Program","text":"interface public elemental module function coshd_r64(theta) result(coshd) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: theta Return Value real(kind=real64)","tags":"","loc":"interface/coshd_r64.html"},{"title":"tanhd_r32 – Fortran Program","text":"interface public elemental module function tanhd_r32(theta) result(tanhd) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: theta Return Value real(kind=real32)","tags":"","loc":"interface/tanhd_r32.html"},{"title":"tanhd_r64 – Fortran Program","text":"interface public elemental module function tanhd_r64(theta) result(tanhd) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: theta Return Value real(kind=real64)","tags":"","loc":"interface/tanhd_r64.html"},{"title":"deg_to_rad_r32 – Fortran Program","text":"interface public elemental module function deg_to_rad_r32(degrees) result(radians) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: degrees Return Value real(kind=real32)","tags":"","loc":"interface/deg_to_rad_r32.html"},{"title":"deg_to_rad_r64 – Fortran Program","text":"interface public elemental module function deg_to_rad_r64(degrees) result(radians) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: degrees Return Value real(kind=real64)","tags":"","loc":"interface/deg_to_rad_r64.html"},{"title":"rad_to_deg_r32 – Fortran Program","text":"interface public elemental module function rad_to_deg_r32(radians) result(degrees) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: radians Return Value real(kind=real32)","tags":"","loc":"interface/rad_to_deg_r32.html"},{"title":"rad_to_deg_r64 – Fortran Program","text":"interface public elemental module function rad_to_deg_r64(radians) result(degrees) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: radians Return Value real(kind=real64)","tags":"","loc":"interface/rad_to_deg_r64.html"},{"title":"intersection_int – Fortran Program","text":"interface public module function intersection_int(setA, setB) result(inters) Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:) :: setA integer, intent(in), dimension(:) :: setB Return Value integer,\n  dimension(:),allocatable","tags":"","loc":"interface/intersection_int.html"},{"title":"intersection_r32 – Fortran Program","text":"interface public module function intersection_r32(setA, setB) result(inters) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), dimension(:) :: setA real(kind=real32), intent(in), dimension(:) :: setB Return Value real(kind=real32),\n  dimension(:),allocatable","tags":"","loc":"interface/intersection_r32.html"},{"title":"intersection_r64 – Fortran Program","text":"interface public module function intersection_r64(setA, setB) result(inters) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:) :: setA real(kind=real64), intent(in), dimension(:) :: setB Return Value real(kind=real64),\n  dimension(:),allocatable","tags":"","loc":"interface/intersection_r64.html"},{"title":"union_int – Fortran Program","text":"interface public module function union_int(setA, setB) result(union_set) Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:) :: setA integer, intent(in), dimension(:) :: setB Return Value integer,\n  dimension(:),allocatable","tags":"","loc":"interface/union_int.html"},{"title":"union_r32 – Fortran Program","text":"interface public module function union_r32(setA, setB) result(union_set) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), dimension(:) :: setA real(kind=real32), intent(in), dimension(:) :: setB Return Value real(kind=real32),\n  dimension(:),allocatable","tags":"","loc":"interface/union_r32.html"},{"title":"union_r64 – Fortran Program","text":"interface public module function union_r64(setA, setB) result(union_set) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:) :: setA real(kind=real64), intent(in), dimension(:) :: setB Return Value real(kind=real64),\n  dimension(:),allocatable","tags":"","loc":"interface/union_r64.html"},{"title":"belongs_to_int – Fortran Program","text":"interface public module function belongs_to_int(x, A) result(bool) Arguments Type Intent Optional Attributes Name integer, intent(in) :: x integer, dimension(:) :: A Return Value logical","tags":"","loc":"interface/belongs_to_int.html"},{"title":"belongs_to_r32 – Fortran Program","text":"interface public module function belongs_to_r32(x, A, eps) result(bool) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: x real(kind=real32), dimension(:) :: A real(kind=real32), optional :: eps Return Value logical","tags":"","loc":"interface/belongs_to_r32.html"},{"title":"belongs_to_r64 – Fortran Program","text":"interface public module function belongs_to_r64(x, A, eps) result(bool) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x real(kind=real64), dimension(:) :: A real(kind=real64), optional :: eps Return Value logical","tags":"","loc":"interface/belongs_to_r64.html"},{"title":"array_epsilon_r32 – Fortran Program","text":"interface public module function array_epsilon_r32(array) result(eps) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), dimension(:) :: array Return Value real(kind=real32)","tags":"","loc":"interface/array_epsilon_r32.html"},{"title":"array_epsilon_r64 – Fortran Program","text":"interface public module function array_epsilon_r64(array) result(eps) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:) :: array Return Value real(kind=real64)","tags":"","loc":"interface/array_epsilon_r64.html"},{"title":"abs_max_val_r32 – Fortran Program","text":"interface public module function abs_max_val_r32(array) result(abs_max_val) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), dimension(:) :: array Return Value real(kind=real32)","tags":"","loc":"interface/abs_max_val_r32.html"},{"title":"abs_max_val_r64 – Fortran Program","text":"interface public module function abs_max_val_r64(array) result(abs_max_val) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:) :: array Return Value real(kind=real64)","tags":"","loc":"interface/abs_max_val_r64.html"},{"title":"chapter_select – Fortran Program","text":"subroutine chapter_select() Arguments None Contents None","tags":"","loc":"proc/chapter_select.html"},{"title":"chapter_selected – Fortran Program","text":"subroutine chapter_selected(chp) Arguments Type Intent Optional Attributes Name integer, intent(in) :: chp Contents None","tags":"","loc":"proc/chapter_selected.html"},{"title":"problem_select – Fortran Program","text":"subroutine problem_select() Arguments None Contents None","tags":"","loc":"proc/problem_select.html"},{"title":"program_start – Fortran Program","text":"subroutine program_start() Arguments None Contents None","tags":"","loc":"proc/program_start.html"},{"title":"program_end – Fortran Program","text":"subroutine program_end() Arguments None Contents None","tags":"","loc":"proc/program_end.html"},{"title":"to_continue – Fortran Program","text":"subroutine to_continue() Arguments None Contents None","tags":"","loc":"proc/to_continue.html"},{"title":"deg_to_rad_sgl – Fortran Program","text":"public elemental function deg_to_rad_sgl(degrees) result(rad) Arguments Type Intent Optional Attributes Name real(kind=SGL), intent(in) :: degrees Return Value real(kind=SGL) Contents None","tags":"","loc":"proc/deg_to_rad_sgl.html"},{"title":"deg_to_rad_dbl – Fortran Program","text":"public elemental function deg_to_rad_dbl(degrees) result(rad) Arguments Type Intent Optional Attributes Name real(kind=DBL), intent(in) :: degrees Return Value real(kind=DBL) Contents None","tags":"","loc":"proc/deg_to_rad_dbl.html"},{"title":"deg_to_rad_int – Fortran Program","text":"public elemental function deg_to_rad_int(degrees) result(rad) Arguments Type Intent Optional Attributes Name integer, intent(in) :: degrees Return Value real(kind=SGL) Contents None","tags":"","loc":"proc/deg_to_rad_int.html"},{"title":"rad_to_deg_sgl – Fortran Program","text":"public elemental function rad_to_deg_sgl(rad) result(degrees) Arguments Type Intent Optional Attributes Name real(kind=SGL), intent(in) :: rad Return Value real(kind=SGL) Contents None","tags":"","loc":"proc/rad_to_deg_sgl.html"},{"title":"rad_to_deg_dbl – Fortran Program","text":"public elemental function rad_to_deg_dbl(rad) result(degrees) Arguments Type Intent Optional Attributes Name real(kind=DBL), intent(in) :: rad Return Value real(kind=DBL) Contents None","tags":"","loc":"proc/rad_to_deg_dbl.html"},{"title":"rad_to_deg_int – Fortran Program","text":"public elemental function rad_to_deg_int(rad) result(degrees) Arguments Type Intent Optional Attributes Name integer, intent(in) :: rad Return Value real(kind=SGL) Contents None","tags":"","loc":"proc/rad_to_deg_int.html"},{"title":"deg_to_rad – Fortran Program","text":"public interface deg_to_rad Contents Module Procedures deg_to_rad_sgl deg_to_rad_dbl deg_to_rad_int Module Procedures public elemental function deg_to_rad_sgl (degrees) result(rad) Arguments Type Intent Optional Attributes Name real(kind=SGL), intent(in) :: degrees Return Value real(kind=SGL) public elemental function deg_to_rad_dbl (degrees) result(rad) Arguments Type Intent Optional Attributes Name real(kind=DBL), intent(in) :: degrees Return Value real(kind=DBL) public elemental function deg_to_rad_int (degrees) result(rad) Arguments Type Intent Optional Attributes Name integer, intent(in) :: degrees Return Value real(kind=SGL)","tags":"","loc":"interface/deg_to_rad~2.html"},{"title":"rad_to_deg – Fortran Program","text":"public interface rad_to_deg Contents Module Procedures rad_to_deg_sgl rad_to_deg_dbl rad_to_deg_int Module Procedures public elemental function rad_to_deg_sgl (rad) result(degrees) Arguments Type Intent Optional Attributes Name real(kind=SGL), intent(in) :: rad Return Value real(kind=SGL) public elemental function rad_to_deg_dbl (rad) result(degrees) Arguments Type Intent Optional Attributes Name real(kind=DBL), intent(in) :: rad Return Value real(kind=DBL) public elemental function rad_to_deg_int (rad) result(degrees) Arguments Type Intent Optional Attributes Name integer, intent(in) :: rad Return Value real(kind=SGL)","tags":"","loc":"interface/rad_to_deg~2.html"},{"title":"sind – Fortran Program","text":"interface Trig degrees public elemental module function sind(theta) Arguments Type Intent Optional Attributes Name real, intent(in) :: theta Return Value real","tags":"","loc":"interface/sind~2.html"},{"title":"cosd – Fortran Program","text":"interface Trig degrees public elemental module function cosd(theta) Arguments Type Intent Optional Attributes Name real, intent(in) :: theta Return Value real","tags":"","loc":"interface/cosd~2.html"},{"title":"tand – Fortran Program","text":"interface Trig degrees public elemental module function tand(theta) Arguments Type Intent Optional Attributes Name real, intent(in) :: theta Return Value real","tags":"","loc":"interface/tand~2.html"},{"title":"asind – Fortran Program","text":"interface Trig degrees public elemental module function asind(theta) Arguments Type Intent Optional Attributes Name real, intent(in) :: theta Return Value real","tags":"","loc":"interface/asind~2.html"},{"title":"acosd – Fortran Program","text":"interface Trig degrees public elemental module function acosd(theta) Arguments Type Intent Optional Attributes Name real, intent(in) :: theta Return Value real","tags":"","loc":"interface/acosd~2.html"},{"title":"atand – Fortran Program","text":"interface Trig degrees public elemental module function atand(theta) Arguments Type Intent Optional Attributes Name real, intent(in) :: theta Return Value real","tags":"","loc":"interface/atand~2.html"},{"title":"urand – Fortran Program","text":"public function urand(min, max) Arguments Type Intent Optional Attributes Name real, intent(in) :: min real, intent(in) :: max Return Value real Contents None","tags":"","loc":"proc/urand.html"},{"title":"is_zero – Fortran Program","text":"interface public elemental module function is_zero(X) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: X Return Value logical","tags":"","loc":"interface/is_zero.html"},{"title":"least_squares_fit – Fortran Program","text":"interface public module subroutine least_squares_fit(X, Y, order, c) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in), dimension(:) :: X real(kind=8), intent(in), dimension(:) :: Y integer, intent(in) :: order real(kind=8), intent(out), dimension(:), allocatable :: c","tags":"","loc":"interface/least_squares_fit.html"},{"title":"generate_sys_eqns – Fortran Program","text":"interface public module subroutine generate_sys_eqns(X, Y, order, A, u) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in), dimension(:) :: X real(kind=8), intent(in), dimension(:) :: Y integer, intent(in) :: order real(kind=8), intent(out), dimension(:,:), allocatable :: A real(kind=8), intent(out), dimension(:), allocatable :: u","tags":"","loc":"interface/generate_sys_eqns.html"},{"title":"solve_n – Fortran Program","text":"interface public module subroutine solve_n(A, x, y) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in), dimension(:,:), allocatable :: A real(kind=8), intent(out), dimension(:) :: x real(kind=8), intent(inout), dimension(:) :: y","tags":"","loc":"interface/solve_n.html"},{"title":"switch_rows – Fortran Program","text":"interface public module subroutine switch_rows(A, row1, row2) Arguments Type Intent Optional Attributes Name real(kind=8), intent(inout), dimension(:,:) :: A integer, intent(in) :: row1 integer, intent(in) :: row2","tags":"","loc":"interface/switch_rows.html"},{"title":"back_sub – Fortran Program","text":"interface public module subroutine back_sub(U, x, y) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in), dimension(:,:) :: U real(kind=8), intent(inout), dimension(:) :: x real(kind=8), intent(inout), dimension(:) :: y","tags":"","loc":"interface/back_sub.html"},{"title":"elim_col – Fortran Program","text":"interface public module subroutine elim_col(A, icol) Arguments Type Intent Optional Attributes Name real(kind=8), intent(inout), dimension(:,:) :: A integer, intent(in) :: icol","tags":"","loc":"interface/elim_col.html"},{"title":"add_noise – Fortran Program","text":"interface public module subroutine add_noise(Y, noise, Y_noise, min, max) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in), dimension(:) :: Y real(kind=8), intent(inout), dimension(:) :: noise real(kind=8), intent(inout), dimension(:) :: Y_noise real(kind=4), intent(in) :: min real(kind=4), intent(in) :: max","tags":"","loc":"interface/add_noise.html"},{"title":"print_mat2 – Fortran Program","text":"public interface print_mat2 Contents Subroutines print_mati print_matr print_matd print_matc Subroutines public subroutine print_mati(A) Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:,:) :: A public subroutine print_matr(A) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:,:) :: A public subroutine print_matd(A) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in), dimension(:,:) :: A public subroutine print_matc(A) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:,:) :: A","tags":"","loc":"interface/print_mat2.html"},{"title":"my_matmul – Fortran Program","text":"public subroutine my_matmul(A, B, C, dimA, dimB, dimC, ierr) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(dimA(1), dimA(2)) :: A real, intent(in), dimension(dimB(1), dimB(2)) :: B real, intent(out), dimension(dimC(1), dimC(2)) :: C integer, intent(in), dimension(2) :: dimA integer, intent(in), dimension(2) :: dimB integer, intent(in), dimension(2) :: dimC integer, intent(inout) :: ierr Contents None","tags":"","loc":"proc/my_matmul.html"},{"title":"pol_to_cart – Fortran Program","text":"interface public module function pol_to_cart(p1) result(c1) Arguments Type Intent Optional Attributes Name class( polar ), intent(in) :: p1 Return Value type( cart )","tags":"","loc":"interface/pol_to_cart.html"},{"title":"cart_to_pol – Fortran Program","text":"interface public module function cart_to_pol(c1) result(p1) Arguments Type Intent Optional Attributes Name class( cart ), intent(in) :: c1 Return Value type( polar )","tags":"","loc":"interface/cart_to_pol.html"},{"title":"my_matmul – Fortran Program","text":"interface public module subroutine my_matmul(A, B, C, ierr) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:,:) :: A real, intent(in), dimension(:,:) :: B real, intent(out), dimension(:,:) :: C integer, intent(inout) :: ierr","tags":"","loc":"interface/my_matmul.html"},{"title":"random0 – Fortran Program","text":"public subroutine random0(ran) Arguments Type Intent Optional Attributes Name real, intent(out) :: ran Contents None","tags":"","loc":"proc/random0.html"},{"title":"seed – Fortran Program","text":"public subroutine seed(iseed) Arguments Type Intent Optional Attributes Name integer, intent(in) :: iseed Contents None","tags":"","loc":"proc/seed.html"},{"title":"new_detection – Fortran Program","text":"public function new_detection(range, azimuth, time) Arguments Type Intent Optional Attributes Name real, intent(in) :: range real, intent(in) :: azimuth real, intent(in) :: time Return Value type( detection ) Contents None","tags":"","loc":"proc/new_detection.html"},{"title":"to_cart – Fortran Program","text":"public elemental function to_cart(detect) result(cart) Arguments Type Intent Optional Attributes Name class( detection ), intent(in) :: detect Return Value type( vector ) Contents None","tags":"","loc":"proc/to_cart.html"},{"title":"compass_to_theta – Fortran Program","text":"public elemental function compass_to_theta(azimuth) result(theta) Arguments Type Intent Optional Attributes Name real, intent(in) :: azimuth Return Value real Contents None","tags":"","loc":"proc/compass_to_theta.html"},{"title":"time_diff – Fortran Program","text":"public elemental function time_diff(det1, det2) Arguments Type Intent Optional Attributes Name class( detection ), intent(in) :: det1 class( detection ), intent(in) :: det2 Return Value real Contents None","tags":"","loc":"proc/time_diff.html"},{"title":"pos_diff – Fortran Program","text":"public elemental function pos_diff(det1, det2) Arguments Type Intent Optional Attributes Name class( detection ), intent(in) :: det1 class( detection ), intent(in) :: det2 Return Value type( vector ) Contents None","tags":"","loc":"proc/pos_diff.html"},{"title":"compute_velocity – Fortran Program","text":"public elemental function compute_velocity(det_t0, det_tf) Arguments Type Intent Optional Attributes Name class( detection ), intent(in) :: det_t0 class( detection ), intent(in) :: det_tf Return Value type( vector ) Contents None","tags":"","loc":"proc/compute_velocity.html"},{"title":"vector_addition – Fortran Program","text":"public elemental function vector_addition(v1, v2) result(v3) Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: v1 class( vector ), intent(in) :: v2 Return Value type( vector ) Contents None","tags":"","loc":"proc/vector_addition.html"},{"title":"vector_substraction – Fortran Program","text":"public elemental function vector_substraction(v1, v2) result(v3) Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: v1 class( vector ), intent(in) :: v2 Return Value type( vector ) Contents None","tags":"","loc":"proc/vector_substraction.html"},{"title":"scalar_times_vector – Fortran Program","text":"public elemental function scalar_times_vector(scalar, vec) result(v2) Arguments Type Intent Optional Attributes Name real, intent(in) :: scalar class( vector ), intent(in) :: vec Return Value type( vector ) Contents None","tags":"","loc":"proc/scalar_times_vector.html"},{"title":"vector_times_scalar – Fortran Program","text":"public elemental function vector_times_scalar(vec, scalar) result(v2) Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: vec real, intent(in) :: scalar Return Value type( vector ) Contents None","tags":"","loc":"proc/vector_times_scalar.html"},{"title":"vector_divided_scalar – Fortran Program","text":"public elemental function vector_divided_scalar(vec, scalar) result(v2) Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: vec real, intent(in) :: scalar Return Value type( vector ) Contents None","tags":"","loc":"proc/vector_divided_scalar.html"},{"title":"predict_position – Fortran Program","text":"public elemental function predict_position(smooth_pos, prev_velocity, delta_time) Arguments Type Intent Optional Attributes Name type( vector ), intent(in) :: smooth_pos type( vector ), intent(in) :: prev_velocity real, intent(in) :: delta_time Return Value type( vector ) Contents None","tags":"","loc":"proc/predict_position.html"},{"title":"update_velocity – Fortran Program","text":"public elemental function update_velocity(prev_velocity, measured_pos, predicted_position, delta_time) Arguments Type Intent Optional Attributes Name type( vector ), intent(in) :: prev_velocity type( vector ), intent(in) :: measured_pos type( vector ), intent(in) :: predicted_position real, intent(in) :: delta_time Return Value type( vector ) Contents None","tags":"","loc":"proc/update_velocity.html"},{"title":"update_position – Fortran Program","text":"public elemental function update_position(predicted_position, measured_position) Arguments Type Intent Optional Attributes Name type( vector ), intent(in) :: predicted_position type( vector ), intent(in) :: measured_position Return Value type( vector ) Contents None","tags":"","loc":"proc/update_position.html"},{"title":"detection – Fortran Program","text":"public interface detection Contents Module Procedures new_detection Module Procedures public function new_detection (range, azimuth, time) Arguments Type Intent Optional Attributes Name real, intent(in) :: range real, intent(in) :: azimuth real, intent(in) :: time Return Value type( detection )","tags":"","loc":"interface/detection.html"},{"title":"operator(*) – Fortran Program","text":"public interface operator(*) Contents Module Procedures scalar_times_vector Module Procedures public elemental function scalar_times_vector (scalar, vec) result(v2) Arguments Type Intent Optional Attributes Name real, intent(in) :: scalar class( vector ), intent(in) :: vec Return Value type( vector )","tags":"","loc":"interface/operator(*).html"},{"title":"return_10 – Fortran Program","text":"public subroutine return_10() Arguments None Contents None","tags":"","loc":"proc/return_10.html"},{"title":"three_args – Fortran Program","text":"public subroutine three_args(x, y, error) Arguments Type Intent Optional Attributes Name integer, intent(in) :: x integer, intent(in) :: y integer, intent(out) :: error Contents None","tags":"","loc":"proc/three_args.html"},{"title":"my_matmul – Fortran Program","text":"public subroutine my_matmul(A, B, C, ierr) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:,:) :: A real, intent(in), dimension(:,:) :: B real, intent(out), dimension(:,:) :: C integer, intent(inout) :: ierr Contents None","tags":"","loc":"proc/my_matmul~2.html"},{"title":"my_sinh – Fortran Program","text":"public function my_sinh(x) result(sinhx) Arguments Type Intent Optional Attributes Name real, intent(in) :: x Return Value real Contents None","tags":"","loc":"proc/my_sinh.html"},{"title":"my_cosh – Fortran Program","text":"public function my_cosh(x) result(coshx) Arguments Type Intent Optional Attributes Name real, intent(in) :: x Return Value real Contents None","tags":"","loc":"proc/my_cosh.html"},{"title":"my_tanh – Fortran Program","text":"public function my_tanh(x) result(tanhx) Arguments Type Intent Optional Attributes Name real, intent(in) :: x Return Value real Contents None","tags":"","loc":"proc/my_tanh.html"},{"title":"compass_to_cart – Fortran Program","text":"public interface compass_to_cart Contents Subroutines compass_to_cart Subroutines public subroutine compass_to_cart() Arguments None","tags":"","loc":"interface/compass_to_cart.html"},{"title":"comp2pol – Fortran Program","text":"interface public module function comp2pol(c) result(pol) Arguments Type Intent Optional Attributes Name complex, intent(in) :: c Return Value type( polar )","tags":"","loc":"interface/comp2pol.html"},{"title":"pol2comp – Fortran Program","text":"interface public module function pol2comp(pol) result(c) Arguments Type Intent Optional Attributes Name type( polar ), intent(in) :: pol Return Value complex","tags":"","loc":"interface/pol2comp.html"},{"title":"mult – Fortran Program","text":"interface public pure module function mult(p1, p2) result(p3) Arguments Type Intent Optional Attributes Name class( polar ), intent(in) :: p1 class( polar ), intent(in) :: p2 Return Value type( polar )","tags":"","loc":"interface/mult.html"},{"title":"div – Fortran Program","text":"interface public pure module function div(p1, p2) result(p3) Arguments Type Intent Optional Attributes Name class( polar ), intent(in) :: p1 class( polar ), intent(in) :: p2 Return Value type( polar )","tags":"","loc":"interface/div.html"},{"title":"print – Fortran Program","text":"interface public module subroutine print(line1) Arguments Type Intent Optional Attributes Name class( line ), intent(in) :: line1","tags":"","loc":"interface/print.html"},{"title":"distance_between_points – Fortran Program","text":"interface public pure module function distance_between_points(p1, p2) result(d1) Arguments Type Intent Optional Attributes Name class( point ), intent(in) :: p1 class( point ), intent(in) :: p2 Return Value real","tags":"","loc":"interface/distance_between_points.html"},{"title":"find_line – Fortran Program","text":"interface public pure module function find_line(p1, p2) result(l) Arguments Type Intent Optional Attributes Name class( point ), intent(in) :: p1 class( point ), intent(in) :: p2 Return Value type( line )","tags":"","loc":"interface/find_line.html"},{"title":"chapter_4 – Fortran Program","text":"All of the programming exercises for Chapter 4: Loops and Character Manipulation Uses iso_fortran_env Contents Functions is_alphnum is_alph is_num is_lower is_upper calc_current_flow to_kelvin to_celcius Subroutines p4_1 p4_3 p4_4 p4_5 p4_6 p4_7 p4_8 p4_9 p4_10 p4_11 p4_12 p4_13 p4_14 p4_15 p4_16 p4_17 p4_18 p4_19 to_lower to_upper Functions public function is_alphnum (char) Test whether an ASCII character is alpha-numeric Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: char Return Value logical public function is_alph (char) Test whether an ASCII character is a letter Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: char Return Value logical public function is_num (char) Test whether an ASCII character is numeric Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: char Return Value logical public function is_lower (char) Test whether an ASCII character is a lowercase letter Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: char Return Value logical public function is_upper (char) Test whether an ASCII character is an uppercase letter Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: char Return Value logical public elemental function calc_current_flow (v_D, I_O, T) result(i_D) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: v_D The voltage across the diode, in volts real(kind=real64), intent(in) :: I_O The leakage current of the diode, in amperes real(kind=real64), intent(in) :: T Temperature, in kelvins (K) Return Value real(kind=real64) The current flow through the diode in amperes public elemental function to_kelvin (F) Convert a temperature in Fahrenheit to Kelvin Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: F Return Value real(kind=real64) public elemental function to_celcius (F) Convert a temperature from Fahrenheit to celcius Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: F Return Value real(kind=real64) Subroutines public subroutine p4_1 () Test if the following equalities are valid statements, and if they are,\n evaluate them Arguments None public subroutine p4_3 () Write a Fortran program to evaluate the equation y(x) = x&#94;2 - 3x + 2 for all values between -1 and 3,\n in steps of 0.1. Arguments None public subroutine p4_4 () Write the Fortran statements required to calculate y(t) from the equation: Read more… Arguments None public subroutine p4_5 () Write a Fortran program to calculate the factorial function. Be sure to handle the special \n cases of 0! and of illegal input values. Arguments None public subroutine p4_6 () What is the difference in behavior between a cycle statement and an exit statement? Arguments None public subroutine p4_7 () Modify program stats_2 to use the DO WHILE construct instaed of the while construct currently in the program Read more… Arguments None public subroutine p4_8 () Examine the following DO statements and determine how many times each loop will\n be exectued. Read more… Arguments None public subroutine p4_9 () Examine the following loops, determine the value of ires and the number of times\n each loop executes Arguments None public subroutine p4_10 () Examine the followin while loops and determine the value of ires at the end of each of \n the loops. Arguments None public subroutine p4_11 () Modify program ball from example 4-7 to read in the acceleration due to gravity\n at a particular location, and to calculate the maximum range of the ball for that acceleration.\n After modifying the program, run it with accelerations of -9.8, -9.7, and -9.6m/s2. Read more… Arguments None public subroutine p4_12 () Modify program ball from Example 4-7 to read in the initial velocity with which the ball\n is thrown. After modifying the program, run it with initial velocities of 10, 20, and 20 \n m/sec. What effect does changin the initial velocity have on the range of the ball? What\n effect does it have on the best angle theta at which to throw the ball? Arguments None public subroutine p4_13 () Arguments None public subroutine p4_14 () Write a Fortran program to evaluate the function \n y(x) = ln(1/1-x)\n for any user-specified value of x, where ln is the natural logarithm.\n Write the program with a while loop, so that the program repeats the calculation \n for each legal value of x entered into the program. When an illegal value of x is entered,\n terminate the program. Arguments None public subroutine p4_15 () Write a Fortran program to convert all uppercase characters in a user-supplied character\n string to lowercase, without changing the uppercase and nonalphabetic characters in the string.\n Assume that your computer uses the ASCII collating sequence. Arguments None public subroutine p4_16 () Calculating Orbits. Read more… Arguments None public subroutine p4_17 () Write a program caps that reads in a character string, searches for all of the words \n within the string, and capitalizes the first letter of each word, while shifting the \n remainder of the word to lowercase. Assume that all nonalphabetic and nonumeric characters\n can mark the boundaries of a word within the character variable (periods, commas,etc.). \n Nonalphabetic characters should be left unchanged. Arguments None public subroutine p4_18 () Write a computer program to calculate the current flowing through this diode\n for all voltages from -1.0V to +0.6 V, in 0.1 V steps. Repeat this process for the \n following temperatures: 75F, 100F, and 125F Arguments None public subroutine p4_19 () Write a program that promps a user for a binary number, which will be entered as a string\n of 0s and 1s in a character variable. This program should be able to handle numbers whos\n binary representation is up to 10 bits, corresponding to values from 0 to 1023. Arguments None public subroutine to_lower (char) Convert a single character to lowercase Arguments Type Intent Optional Attributes Name character(len=1), intent(inout) :: char public subroutine to_upper (char) Convert a single character to uppercase Arguments Type Intent Optional Attributes Name character(len=1), intent(inout) :: char","tags":"","loc":"module/chapter_4.html"},{"title":"chapter_7 – Fortran Program","text":"All of the programming exercises for Chapter 7: Procedures Uses iso_fortran_env Contents Subroutines p7_1 p7_2 p7_3 p7_4 p7_5 p7_6 p7_7 p7_8 p7_9 p7_10 Subroutines public subroutine p7_1 () DISCUSSION QUESTION What is the difference between a subroutine and a function? Arguments None public subroutine p7_2 () DISCUSSION QUESTION When a subroutine is called, how is data passed from the calling program to the subroutine,\n and how are the results of the subroutine returned to the calling program? Arguments None public subroutine p7_3 () DISCUSSION QUESTION What are the advantages and disadvantages of the pass-by-reference scheme used in Fortran? Arguments None public subroutine p7_4 () DISCUSSION QUESTION What are the advantages and disadvantages of each procedure array type? Arguments None public subroutine p7_5 () DISCUSSION QUESTION Suppose a 15-element array is passed to a subroutine. What happens if the subroutine attempts\n to write to element a(16)? Arguments None public subroutine p7_6 () DISCUSSION QUESTION If a real value is passed to a subroutine in an argument that is declared to be an integer,\n what happens? Arguments None public subroutine p7_7 () DISCUSSION QUESTION How can p7_6 be modified so that the compiler catches the argument mismatch between\n the actual argument and the dummy argument in the subroutine? Arguments None public subroutine p7_8 () DISCUSSION QUESTION What is the purpose of the INTENT attribute? Where can it be used? Why should it be used? Arguments None public subroutine p7_9 () NOT APPLICABLE Arguments None public subroutine p7_10 () NOT APPLICABLE Arguments None","tags":"","loc":"module/chapter_7.html"},{"title":"chapter_6 – Fortran Program","text":"Arrays Uses iso_fortran_env Contents Subroutines p6_1 p6_3 p6_4 p6_5 p6_6 p6_7 p6_8 p6_10 p6_11 Subroutines public subroutine p6_1 () DISCUSSION QUESTION How may arrays be declared? Arguments None public subroutine p6_3 () DISCUSSION QUESTION Execute this subroutine on your computer with both bounds checking turned on and \n bounds checking turned off. What happens? Arguments None public subroutine p6_4 () DISCUSSION QUESTION Determine the shape and size of the arrays specified by the following statements: Arguments None public subroutine p6_5 () DISCUSSION QUESTION Determine which of the following Fortran program fragments are valid. For each valid statement,\n specify what will happen in the program. (Assume default typing for any variables that are not \n explicitly typed within the program fragments.) Arguments None public subroutine p6_6 () DISCUSSION QUESTION What is meant by each of the following array terms? Size, shape, extent, rank, conformable. Arguments None public subroutine p6_7 () DISCUSSION QUESTION Given an array my_array defined as shown, determine whether each of the following\n array sections is valid Arguments None public subroutine p6_8 () DISCUSSION QUESTION What will the output from each of the WRITE statements in the following subroutine be?\n Why is the output of the two statements different? Arguments None public subroutine p6_10 () Polar to Rectangular Conversion Read more… Arguments None public subroutine p6_11 () Rectangular to Polar Conversion Read more… Arguments None","tags":"","loc":"module/chapter_6.html"},{"title":"chapter_5 – Fortran Program","text":"All of the programming exercises for Chapter 5: Basic IO Uses iso_fortran_env Contents Subroutines p5_1 p5_2 p5_3 p5_4 p5_5 p5_6 Subroutines public subroutine p5_1 () DISCUSSION QUESTION What is the purpose of a format? What are the three ways to define a format? Arguments None public subroutine p5_2 () DISCUSSION QUESTION What is printed out by the following Fortran statements? Arguments None public subroutine p5_3 () DISCUSSION QUESTION What is printed out by the following Fortran statements? Arguments None public subroutine p5_4 (file_name) DISCUSSION QUESTION Read in 5_4.dat and find out what the output will be for the following statements: Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name public subroutine p5_5 (file_name) DISCUSSION QUESTION Read in 5_5.dat and find out what the value of each variable will be when the \n READ statements have been completed Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name public subroutine p5_6 () Generate a table of the base 10 logarithms between 1 and 10 in steps of 0.1 Arguments None","tags":"","loc":"module/chapter_5.html"},{"title":"foreng_matrices – Fortran Program","text":"Top level module for specific matrix operations (elimination, matrix generation, systems of equations) Contents None","tags":"","loc":"module/foreng_matrices.html"},{"title":"foreng_math – Fortran Program","text":"Top level module containing math functions (sets, factorials, trig) Uses foreng Used by Descendants: sets trig Contents Interfaces sind cosd tand asind acosd atand sinhd coshd tanhd deg_to_rad rad_to_deg intersection union belongs_to array_epsilon abs_max_val sind_r32 sind_r64 cosd_r32 cosd_r64 tand_r32 tand_r64 asind_r32 asind_r64 acosd_r32 acosd_r64 atand_r32 atand_r64 sinhd_r32 sinhd_r64 coshd_r32 coshd_r64 tanhd_r32 tanhd_r64 deg_to_rad_r32 deg_to_rad_r64 rad_to_deg_r32 rad_to_deg_r64 intersection_int intersection_r32 intersection_r64 union_int union_r32 union_r64 belongs_to_int belongs_to_r32 belongs_to_r64 array_epsilon_r32 array_epsilon_r64 abs_max_val_r32 abs_max_val_r64 Interfaces public interface sind public interface sind_r32 () Arguments None public interface sind_r64 () Arguments None public interface cosd public interface cosd_r32 () Arguments None public interface cosd_r64 () Arguments None public interface tand public interface tand_r32 () Arguments None public interface tand_r64 () Arguments None public interface asind public interface asind_r32 () Arguments None public interface asind_r64 () Arguments None public interface acosd public interface acosd_r32 () Arguments None public interface acosd_r64 () Arguments None public interface atand public interface atand_r32 () Arguments None public interface atand_r64 () Arguments None public interface sinhd public interface sinhd_r32 () Arguments None public interface sinhd_r64 () Arguments None public interface coshd public interface coshd_r32 () Arguments None public interface coshd_r64 () Arguments None public interface tanhd public interface tanhd_r32 () Arguments None public interface tanhd_r64 () Arguments None public interface deg_to_rad public interface deg_to_rad_r32 () Arguments None public interface deg_to_rad_r64 () Arguments None public interface rad_to_deg public interface rad_to_deg_r32 () Arguments None public interface rad_to_deg_r64 () Arguments None public interface intersection public interface intersection_int () Arguments None public interface intersection_r32 () Arguments None public interface intersection_r64 () Arguments None public interface union public interface union_int () Arguments None public interface union_r32 () Arguments None public interface union_r64 () Arguments None public interface belongs_to public interface belongs_to_int () Arguments None public interface belongs_to_r32 () Arguments None public interface belongs_to_r64 () Arguments None public interface array_epsilon public interface array_epsilon_r32 () Arguments None public interface array_epsilon_r64 () Arguments None public interface abs_max_val public interface abs_max_val_r32 () Arguments None public interface abs_max_val_r64 () Arguments None interface public elemental module function sind_r32(theta) result(sind) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: theta Return Value real(kind=real32) interface public elemental module function sind_r64(theta) result(sind) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: theta Return Value real(kind=real64) interface public elemental module function cosd_r32(theta) result(cosd) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: theta Return Value real(kind=real32) interface public elemental module function cosd_r64(theta) result(cosd) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: theta Return Value real(kind=real64) interface public elemental module function tand_r32(theta) result(tand) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: theta Return Value real(kind=real32) interface public elemental module function tand_r64(theta) result(tand) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: theta Return Value real(kind=real64) interface public elemental module function asind_r32(theta) result(asind) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: theta Return Value real(kind=real32) interface public elemental module function asind_r64(theta) result(asind) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: theta Return Value real(kind=real64) interface public elemental module function acosd_r32(theta) result(acosd) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: theta Return Value real(kind=real32) interface public elemental module function acosd_r64(theta) result(acosd) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: theta Return Value real(kind=real64) interface public elemental module function atand_r32(theta) result(atand) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: theta Return Value real(kind=real32) interface public elemental module function atand_r64(theta) result(atand) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: theta Return Value real(kind=real64) interface public elemental module function sinhd_r32(theta) result(sinhd) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: theta Return Value real(kind=real32) interface public elemental module function sinhd_r64(theta) result(sinhd) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: theta Return Value real(kind=real64) interface public elemental module function coshd_r32(theta) result(coshd) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: theta Return Value real(kind=real32) interface public elemental module function coshd_r64(theta) result(coshd) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: theta Return Value real(kind=real64) interface public elemental module function tanhd_r32(theta) result(tanhd) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: theta Return Value real(kind=real32) interface public elemental module function tanhd_r64(theta) result(tanhd) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: theta Return Value real(kind=real64) interface public elemental module function deg_to_rad_r32(degrees) result(radians) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: degrees Return Value real(kind=real32) interface public elemental module function deg_to_rad_r64(degrees) result(radians) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: degrees Return Value real(kind=real64) interface public elemental module function rad_to_deg_r32(radians) result(degrees) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: radians Return Value real(kind=real32) interface public elemental module function rad_to_deg_r64(radians) result(degrees) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: radians Return Value real(kind=real64) interface public module function intersection_int(setA, setB) result(inters) Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:) :: setA integer, intent(in), dimension(:) :: setB Return Value integer,\n  dimension(:), allocatable interface public module function intersection_r32(setA, setB) result(inters) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), dimension(:) :: setA real(kind=real32), intent(in), dimension(:) :: setB Return Value real(kind=real32),\n  dimension(:), allocatable interface public module function intersection_r64(setA, setB) result(inters) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:) :: setA real(kind=real64), intent(in), dimension(:) :: setB Return Value real(kind=real64),\n  dimension(:), allocatable interface public module function union_int(setA, setB) result(union_set) Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:) :: setA integer, intent(in), dimension(:) :: setB Return Value integer,\n  dimension(:), allocatable interface public module function union_r32(setA, setB) result(union_set) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), dimension(:) :: setA real(kind=real32), intent(in), dimension(:) :: setB Return Value real(kind=real32),\n  dimension(:), allocatable interface public module function union_r64(setA, setB) result(union_set) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:) :: setA real(kind=real64), intent(in), dimension(:) :: setB Return Value real(kind=real64),\n  dimension(:), allocatable interface public module function belongs_to_int(x, A) result(bool) Arguments Type Intent Optional Attributes Name integer, intent(in) :: x integer, dimension(:) :: A Return Value logical interface public module function belongs_to_r32(x, A, eps) result(bool) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: x real(kind=real32), dimension(:) :: A real(kind=real32), optional :: eps Return Value logical interface public module function belongs_to_r64(x, A, eps) result(bool) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x real(kind=real64), dimension(:) :: A real(kind=real64), optional :: eps Return Value logical interface public module function array_epsilon_r32(array) result(eps) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), dimension(:) :: array Return Value real(kind=real32) interface public module function array_epsilon_r64(array) result(eps) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:) :: array Return Value real(kind=real64) interface public module function abs_max_val_r32(array) result(abs_max_val) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), dimension(:) :: array Return Value real(kind=real32) interface public module function abs_max_val_r64(array) result(abs_max_val) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:) :: array Return Value real(kind=real64)","tags":"","loc":"module/foreng_math.html"},{"title":"foreng – Fortran Program","text":"Top level module for all of the useful functions written for Fortran for Scientists and Engineers Uses iso_fortran_env Contents Variables PI_64 PI PI_32 Variables Type Visibility Attributes Name Initial real(kind=real64), public, parameter :: PI_64 = 3.141592653589793 real(kind=real64), public, parameter :: PI = PI_64 real(kind=real32), public, parameter :: PI_32 = 3.14159265","tags":"","loc":"module/foreng.html"},{"title":"trig – Fortran Program","text":"Trig conversion Used by Descendants: trig_degrees Contents Variables PI_D PI SGL DBL Interfaces deg_to_rad rad_to_deg sind cosd tand asind acosd atand Functions deg_to_rad_sgl deg_to_rad_dbl deg_to_rad_int rad_to_deg_sgl rad_to_deg_dbl rad_to_deg_int Variables Type Visibility Attributes Name Initial real(kind=8), public, parameter :: PI_D = 3.141592653589793 real, public, parameter :: PI = 3.14159265 integer, public, parameter :: SGL = selected_int_kind(7) integer, public, parameter :: DBL = selected_int_kind(15) Interfaces public interface deg_to_rad public elemental function deg_to_rad_sgl (degrees) result(rad) Arguments Type Intent Optional Attributes Name real(kind=SGL), intent(in) :: degrees Return Value real(kind=SGL) public elemental function deg_to_rad_dbl (degrees) result(rad) Arguments Type Intent Optional Attributes Name real(kind=DBL), intent(in) :: degrees Return Value real(kind=DBL) public elemental function deg_to_rad_int (degrees) result(rad) Arguments Type Intent Optional Attributes Name integer, intent(in) :: degrees Return Value real(kind=SGL) public interface rad_to_deg public elemental function rad_to_deg_sgl (rad) result(degrees) Arguments Type Intent Optional Attributes Name real(kind=SGL), intent(in) :: rad Return Value real(kind=SGL) public elemental function rad_to_deg_dbl (rad) result(degrees) Arguments Type Intent Optional Attributes Name real(kind=DBL), intent(in) :: rad Return Value real(kind=DBL) public elemental function rad_to_deg_int (rad) result(degrees) Arguments Type Intent Optional Attributes Name integer, intent(in) :: rad Return Value real(kind=SGL) interface Trig degrees public elemental module function sind(theta) Arguments Type Intent Optional Attributes Name real, intent(in) :: theta Return Value real interface Trig degrees public elemental module function cosd(theta) Arguments Type Intent Optional Attributes Name real, intent(in) :: theta Return Value real interface Trig degrees public elemental module function tand(theta) Arguments Type Intent Optional Attributes Name real, intent(in) :: theta Return Value real interface Trig degrees public elemental module function asind(theta) Arguments Type Intent Optional Attributes Name real, intent(in) :: theta Return Value real interface Trig degrees public elemental module function acosd(theta) Arguments Type Intent Optional Attributes Name real, intent(in) :: theta Return Value real interface Trig degrees public elemental module function atand(theta) Arguments Type Intent Optional Attributes Name real, intent(in) :: theta Return Value real Functions public elemental function deg_to_rad_sgl (degrees) result(rad) Arguments Type Intent Optional Attributes Name real(kind=SGL), intent(in) :: degrees Return Value real(kind=SGL) public elemental function deg_to_rad_dbl (degrees) result(rad) Arguments Type Intent Optional Attributes Name real(kind=DBL), intent(in) :: degrees Return Value real(kind=DBL) public elemental function deg_to_rad_int (degrees) result(rad) Arguments Type Intent Optional Attributes Name integer, intent(in) :: degrees Return Value real(kind=SGL) public elemental function rad_to_deg_sgl (rad) result(degrees) Arguments Type Intent Optional Attributes Name real(kind=SGL), intent(in) :: rad Return Value real(kind=SGL) public elemental function rad_to_deg_dbl (rad) result(degrees) Arguments Type Intent Optional Attributes Name real(kind=DBL), intent(in) :: rad Return Value real(kind=DBL) public elemental function rad_to_deg_int (rad) result(degrees) Arguments Type Intent Optional Attributes Name integer, intent(in) :: rad Return Value real(kind=SGL)","tags":"","loc":"module/trig.html"},{"title":"prototype – Fortran Program","text":"Used by Descendants: least_squares print_functions Contents Interfaces is_zero least_squares_fit generate_sys_eqns solve_n switch_rows back_sub elim_col add_noise print_mat2 Functions urand Interfaces interface public elemental module function is_zero(X) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: X Return Value logical interface public module subroutine least_squares_fit(X, Y, order, c) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in), dimension(:) :: X real(kind=8), intent(in), dimension(:) :: Y integer, intent(in) :: order real(kind=8), intent(out), dimension(:), allocatable :: c interface public module subroutine generate_sys_eqns(X, Y, order, A, u) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in), dimension(:) :: X real(kind=8), intent(in), dimension(:) :: Y integer, intent(in) :: order real(kind=8), intent(out), dimension(:,:), allocatable :: A real(kind=8), intent(out), dimension(:), allocatable :: u interface public module subroutine solve_n(A, x, y) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in), dimension(:,:), allocatable :: A real(kind=8), intent(out), dimension(:) :: x real(kind=8), intent(inout), dimension(:) :: y interface public module subroutine switch_rows(A, row1, row2) Arguments Type Intent Optional Attributes Name real(kind=8), intent(inout), dimension(:,:) :: A integer, intent(in) :: row1 integer, intent(in) :: row2 interface public module subroutine back_sub(U, x, y) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in), dimension(:,:) :: U real(kind=8), intent(inout), dimension(:) :: x real(kind=8), intent(inout), dimension(:) :: y interface public module subroutine elim_col(A, icol) Arguments Type Intent Optional Attributes Name real(kind=8), intent(inout), dimension(:,:) :: A integer, intent(in) :: icol interface public module subroutine add_noise(Y, noise, Y_noise, min, max) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in), dimension(:) :: Y real(kind=8), intent(inout), dimension(:) :: noise real(kind=8), intent(inout), dimension(:) :: Y_noise real(kind=4), intent(in) :: min real(kind=4), intent(in) :: max public interface print_mat2 public subroutine print_mati(A) Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(:,:) :: A public subroutine print_matr(A) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:,:) :: A public subroutine print_matd(A) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in), dimension(:,:) :: A public subroutine print_matc(A) Arguments Type Intent Optional Attributes Name complex, intent(in), dimension(:,:) :: A Functions public function urand (min, max) Arguments Type Intent Optional Attributes Name real, intent(in) :: min real, intent(in) :: max Return Value real","tags":"","loc":"module/prototype.html"},{"title":"my_matmul_mod – Fortran Program","text":"Contents Subroutines my_matmul Subroutines public subroutine my_matmul (A, B, C, dimA, dimB, dimC, ierr) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(dimA(1), dimA(2)) :: A real, intent(in), dimension(dimB(1), dimB(2)) :: B real, intent(out), dimension(dimC(1), dimC(2)) :: C integer, intent(in), dimension(2) :: dimA integer, intent(in), dimension(2) :: dimB integer, intent(in), dimension(2) :: dimC integer, intent(inout) :: ierr","tags":"","loc":"module/my_matmul_mod.html"},{"title":"points_t – Fortran Program","text":"Used by Descendants: cart polar Contents Interfaces pol_to_cart cart_to_pol Derived Types point polar cart Interfaces interface public module function pol_to_cart(p1) result(c1) Arguments Type Intent Optional Attributes Name class( polar ), intent(in) :: p1 Return Value type( cart ) interface public module function cart_to_pol(c1) result(p1) Arguments Type Intent Optional Attributes Name class( cart ), intent(in) :: c1 Return Value type( polar ) Derived Types type, public, abstract :: point Components Type Visibility Attributes Name Initial integer, public :: kind = 8 type, public, extends( point ) :: polar Components Type Visibility Attributes Name Initial integer, public :: kind = 8 real, public :: r real, public :: th Type-Bound Procedures procedure, public :: to_cart => pol_to_cart type, public, extends( point ) :: cart Components Type Visibility Attributes Name Initial integer, public :: kind = 8 real, public :: x real, public :: y Type-Bound Procedures procedure, public :: to_pol => cart_to_pol","tags":"","loc":"module/points_t.html"},{"title":"my_matmul_mod_parent – Fortran Program","text":"Used by Descendants: my_matmul_mod_child Contents Interfaces my_matmul Interfaces interface public module subroutine my_matmul(A, B, C, ierr) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:,:) :: A real, intent(in), dimension(:,:) :: B real, intent(out), dimension(:,:) :: C integer, intent(inout) :: ierr","tags":"","loc":"module/my_matmul_mod_parent.html"},{"title":"ran001 – Fortran Program","text":"Contents Variables n Subroutines random0 seed Variables Type Visibility Attributes Name Initial integer, public :: n = 9876 Subroutines public subroutine random0 (ran) Arguments Type Intent Optional Attributes Name real, intent(out) :: ran public subroutine seed (iseed) Arguments Type Intent Optional Attributes Name integer, intent(in) :: iseed","tags":"","loc":"module/ran001.html"},{"title":"radar – Fortran Program","text":"Uses trig Contents Variables ALPHA BETA Interfaces detection operator(*) Derived Types vector detection Functions new_detection to_cart compass_to_theta time_diff pos_diff compute_velocity vector_addition vector_substraction scalar_times_vector vector_times_scalar vector_divided_scalar predict_position update_velocity update_position Variables Type Visibility Attributes Name Initial real, public, parameter :: ALPHA = 0.7 real, public, parameter :: BETA = 0.38 Interfaces public interface detection public function new_detection (range, azimuth, time) Arguments Type Intent Optional Attributes Name real, intent(in) :: range real, intent(in) :: azimuth real, intent(in) :: time Return Value type( detection ) public interface operator(*) public elemental function scalar_times_vector (scalar, vec) result(v2) Arguments Type Intent Optional Attributes Name real, intent(in) :: scalar class( vector ), intent(in) :: vec Return Value type( vector ) Derived Types type, public :: vector Components Type Visibility Attributes Name Initial real, public :: x real, public :: y Type-Bound Procedures generic, public :: operator(+) => vector_addition generic, public :: operator(-) => vector_substraction generic, public :: operator(*) => vector_times_scalar generic, public :: operator(/) => vector_divided_scalar procedure, public :: vector_addition procedure, public :: vector_substraction procedure, public :: vector_times_scalar procedure, public :: vector_divided_scalar type, public :: detection Components Type Visibility Attributes Name Initial real, public :: range real, public :: azimuth real, public :: time type( vector ), public :: cart = vector(0.0, 0.0) Constructor public  function new_detection (range, azimuth, time) Type-Bound Procedures procedure, public :: to_cart procedure, public :: time_diff procedure, public :: pos_diff procedure, public :: compute_velocity Functions public function new_detection (range, azimuth, time) Arguments Type Intent Optional Attributes Name real, intent(in) :: range real, intent(in) :: azimuth real, intent(in) :: time Return Value type( detection ) public elemental function to_cart (detect) result(cart) Arguments Type Intent Optional Attributes Name class( detection ), intent(in) :: detect Return Value type( vector ) public elemental function compass_to_theta (azimuth) result(theta) Arguments Type Intent Optional Attributes Name real, intent(in) :: azimuth Return Value real public elemental function time_diff (det1, det2) Arguments Type Intent Optional Attributes Name class( detection ), intent(in) :: det1 class( detection ), intent(in) :: det2 Return Value real public elemental function pos_diff (det1, det2) Arguments Type Intent Optional Attributes Name class( detection ), intent(in) :: det1 class( detection ), intent(in) :: det2 Return Value type( vector ) public elemental function compute_velocity (det_t0, det_tf) Arguments Type Intent Optional Attributes Name class( detection ), intent(in) :: det_t0 class( detection ), intent(in) :: det_tf Return Value type( vector ) public elemental function vector_addition (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: v1 class( vector ), intent(in) :: v2 Return Value type( vector ) public elemental function vector_substraction (v1, v2) result(v3) Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: v1 class( vector ), intent(in) :: v2 Return Value type( vector ) public elemental function scalar_times_vector (scalar, vec) result(v2) Arguments Type Intent Optional Attributes Name real, intent(in) :: scalar class( vector ), intent(in) :: vec Return Value type( vector ) public elemental function vector_times_scalar (vec, scalar) result(v2) Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: vec real, intent(in) :: scalar Return Value type( vector ) public elemental function vector_divided_scalar (vec, scalar) result(v2) Arguments Type Intent Optional Attributes Name class( vector ), intent(in) :: vec real, intent(in) :: scalar Return Value type( vector ) public elemental function predict_position (smooth_pos, prev_velocity, delta_time) Arguments Type Intent Optional Attributes Name type( vector ), intent(in) :: smooth_pos type( vector ), intent(in) :: prev_velocity real, intent(in) :: delta_time Return Value type( vector ) public elemental function update_velocity (prev_velocity, measured_pos, predicted_position, delta_time) Arguments Type Intent Optional Attributes Name type( vector ), intent(in) :: prev_velocity type( vector ), intent(in) :: measured_pos type( vector ), intent(in) :: predicted_position real, intent(in) :: delta_time Return Value type( vector ) public elemental function update_position (predicted_position, measured_position) Arguments Type Intent Optional Attributes Name type( vector ), intent(in) :: predicted_position type( vector ), intent(in) :: measured_position Return Value type( vector )","tags":"","loc":"module/radar.html"},{"title":"ejovo – Fortran Program","text":"Contents Subroutines return_10 three_args Subroutines public subroutine return_10 () Arguments None public subroutine three_args (x, y, error) Arguments Type Intent Optional Attributes Name integer, intent(in) :: x integer, intent(in) :: y integer, intent(out) :: error","tags":"","loc":"module/ejovo.html"},{"title":"my_matmul_mod_explicit – Fortran Program","text":"Contents Subroutines my_matmul Subroutines public subroutine my_matmul (A, B, C, ierr) Arguments Type Intent Optional Attributes Name real, intent(in), dimension(:,:) :: A real, intent(in), dimension(:,:) :: B real, intent(out), dimension(:,:) :: C integer, intent(inout) :: ierr","tags":"","loc":"module/my_matmul_mod_explicit.html"},{"title":"hyperbolics – Fortran Program","text":"Contents Functions my_sinh my_cosh my_tanh Functions public function my_sinh (x) result(sinhx) Arguments Type Intent Optional Attributes Name real, intent(in) :: x Return Value real public function my_cosh (x) result(coshx) Arguments Type Intent Optional Attributes Name real, intent(in) :: x Return Value real public function my_tanh (x) result(tanhx) Arguments Type Intent Optional Attributes Name real, intent(in) :: x Return Value real","tags":"","loc":"module/hyperbolics.html"},{"title":"coordinates – Fortran Program","text":"Used by Descendants: compass Contents Interfaces compass_to_cart Interfaces public interface compass_to_cart public subroutine compass_to_cart() Arguments None","tags":"","loc":"module/coordinates.html"},{"title":"new_types – Fortran Program","text":"Contents Derived Types vector Derived Types type, public :: vector Components Type Visibility Attributes Name Initial real, public :: x real, public :: y character(len=10), public :: name = \"default\"","tags":"","loc":"module/new_types.html"},{"title":"ejovo_types – Fortran Program","text":"Used by Descendants: line point polar Contents Variables PI Interfaces comp2pol pol2comp mult div print distance_between_points find_line Derived Types polar line point Variables Type Visibility Attributes Name Initial real, public, parameter :: PI = 3.141592653589793 Interfaces interface public module function comp2pol(c) result(pol) Arguments Type Intent Optional Attributes Name complex, intent(in) :: c Return Value type( polar ) interface public module function pol2comp(pol) result(c) Arguments Type Intent Optional Attributes Name type( polar ), intent(in) :: pol Return Value complex interface public pure module function mult(p1, p2) result(p3) Arguments Type Intent Optional Attributes Name class( polar ), intent(in) :: p1 class( polar ), intent(in) :: p2 Return Value type( polar ) interface public pure module function div(p1, p2) result(p3) Arguments Type Intent Optional Attributes Name class( polar ), intent(in) :: p1 class( polar ), intent(in) :: p2 Return Value type( polar ) interface public module subroutine print(line1) Arguments Type Intent Optional Attributes Name class( line ), intent(in) :: line1 interface public pure module function distance_between_points(p1, p2) result(d1) Arguments Type Intent Optional Attributes Name class( point ), intent(in) :: p1 class( point ), intent(in) :: p2 Return Value real interface public pure module function find_line(p1, p2) result(l) Arguments Type Intent Optional Attributes Name class( point ), intent(in) :: p1 class( point ), intent(in) :: p2 Return Value type( line ) Derived Types type, public :: polar Components Type Visibility Attributes Name Initial real, public :: r real, public :: theta Type-Bound Procedures procedure, public, pass :: mult procedure, public, pass :: div type, public :: line Components Type Visibility Attributes Name Initial real, public :: m real, public :: b Type-Bound Procedures procedure, public, pass :: print type, public :: point Components Type Visibility Attributes Name Initial real, public :: x real, public :: y Type-Bound Procedures procedure, public, pass :: dist => distance_between_points procedure, public, pass :: find_line","tags":"","loc":"module/ejovo_types.html"},{"title":"trig – Fortran Program","text":"Uses Ancestors: foreng_math Contents None","tags":"","loc":"module/trig~2.html"},{"title":"sets – Fortran Program","text":"Uses Ancestors: foreng_math Contents None","tags":"","loc":"module/sets.html"},{"title":"compass – Fortran Program","text":"Uses trig Ancestors: coordinates Contents None","tags":"","loc":"module/compass.html"},{"title":"point – Fortran Program","text":"Uses Ancestors: ejovo_types Contents None","tags":"","loc":"module/point.html"},{"title":"polar – Fortran Program","text":"Uses Ancestors: ejovo_types Contents None","tags":"","loc":"module/polar~2.html"},{"title":"print_functions – Fortran Program","text":"Uses Ancestors: prototype Contents None","tags":"","loc":"module/print_functions.html"},{"title":"line – Fortran Program","text":"Uses Ancestors: ejovo_types Contents None","tags":"","loc":"module/line.html"},{"title":"polar – Fortran Program","text":"Uses Ancestors: points_t Contents None","tags":"","loc":"module/polar.html"},{"title":"cart – Fortran Program","text":"Uses Ancestors: points_t Contents None","tags":"","loc":"module/cart.html"},{"title":"trig_degrees – Fortran Program","text":"Uses Ancestors: trig Contents None","tags":"","loc":"module/trig_degrees.html"},{"title":"least_squares – Fortran Program","text":"Uses Ancestors: prototype Contents None","tags":"","loc":"module/least_squares.html"},{"title":"my_matmul_mod_child – Fortran Program","text":"Uses Ancestors: my_matmul_mod_parent Contents None","tags":"","loc":"module/my_matmul_mod_child.html"},{"title":"test_hyper – Fortran Program","text":"Contents Variables x Variables Type Attributes Name Initial real :: x = 4","tags":"","loc":"program/test_hyper.html"},{"title":"trig_test – Fortran Program","text":"Uses foreng_math Contents Variables thetad theta max_vals Variables Type Attributes Name Initial real(kind=real64) :: thetad = 90 real(kind=real64) :: theta real(kind=real64), dimension(3) :: max_vals = [-10.d0, 0d0, 5d0]","tags":"","loc":"program/trig_test.html"},{"title":"sets_test – Fortran Program","text":"Uses foreng_math Contents Variables setA setB uni inters Variables Type Attributes Name Initial real(kind=real32), dimension(10) :: setA = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] real(kind=real32), dimension(10) :: setB = [1, -10, 3, 5, -13, 6, -2, 8, 13, 10] real(kind=real32), dimension(:), allocatable :: uni real(kind=real32), dimension(:), allocatable :: inters","tags":"","loc":"program/sets_test.html"},{"title":"demo – Fortran Program","text":"Uses chapter_4 chapter_5 chapter_6 chapter_7 Contents Variables i j ierr errmsg p7_6_real Subroutines chapter_select chapter_selected problem_select program_start program_end to_continue Variables Type Attributes Name Initial integer :: i = 0 integer :: j = 0 integer :: ierr character(len=100) :: errmsg real :: p7_6_real = 1.0 Subroutines subroutine chapter_select () Arguments None subroutine chapter_selected (chp) Arguments Type Intent Optional Attributes Name integer, intent(in) :: chp subroutine problem_select () Arguments None subroutine program_start () Arguments None subroutine program_end () Arguments None subroutine to_continue () Arguments None","tags":"","loc":"program/demo.html"},{"title":"lib_test – Fortran Program","text":"Uses prototype Contents Variables A u c x y Variables Type Attributes Name Initial real(kind=8), dimension(:,:), allocatable :: A real(kind=8), dimension(:), allocatable :: u real(kind=8), dimension(5) :: c real(kind=8), dimension(6) :: x real(kind=8), dimension(6) :: y","tags":"","loc":"program/lib_test.html"},{"title":"test_drive – Fortran Program","text":"Uses points_t Contents Variables my_p my_c Variables Type Attributes Name Initial type( polar ) :: my_p type( cart ) :: my_c","tags":"","loc":"program/test_drive.html"},{"title":"radar_test – Fortran Program","text":"Uses radar Contents Variables det1 det2 my_velocity Variables Type Attributes Name Initial type( detection ) :: det1 type( detection ) :: det2 type( vector ) :: my_velocity","tags":"","loc":"program/radar_test.html"}]}